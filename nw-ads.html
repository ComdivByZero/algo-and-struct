<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

  <meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.8.0"/>
  <title>A &amp; DS</title>
  <meta name="author" content="Niklaus Wirth"/>

  <link rel='stylesheet' type='text/css' href='nw-ads.css'>
</head>

<body lang="en">

<details class="note"><summary>Note about HTML version of this book.</summary>
 This document has been semi-automatically converted to HTML from
 the <a href="https://informatika-21.ru/ADen/AD2012.pdf">AD2012.pdf</a>,
 containing Niklaus Wirth's book with corrections by Fyodor Tkachov.
 The content remains the same as possible.
 Most of changes relate to the correction of inaccuracies made by automatic conversion.
 Work still not finished.
 If you want to help, you can open an issue or make commit to
 the <a href="https://github.com/comdivbyzero/algo-and-struct">repository</a>.
</details>

<h1>Algorithms and Data Structures</h1>
<p>© N. Wirth 1985 (Oberon version: August 2004).</p>

<span class='note'>
<p><strong>Translator's note</strong>. This book was translated into
Russian in 2009 for specific teaching purposes. Along the way,
Pascal-to-Modula-2-to-Oberon conversion typos were corrected and
some changes to programs were made.
The changes (localized in sects. 1 and 3) were agreed upon with the
author in April, 2009. Their
purpose was to facilitate verification of the program examples that
are now in perfect running order.</p>
<p>Most notably, section 1.9 now
uses the Dijkstra loop introduced in Oberon-07 (see
<a href='#Appendix-C'>Appendix C</a>).</p>

<p>This book can be downloaded from the author's site:</p>
</span>

<a class="self" href="https://people.inf.ethz.ch/wirth/AD.pdf"></a>

<p class="note">The program examples can be downloaded from the site that
promulgates Oberons as a unique foundation to teach kids from age
11 all the way up through the university-level compiler
construction and software architecture courses:</p>

<a class="self" href="http://www.inr.ac.ru/~info21/ADen/"></a>

<p><span class="note">where the most recently corrected version may be
available. Please send typos and bugs to:</span>
<a title="Fyodor Tkachov is no longer with us">info21@inr.ac.ru</a>
</p>

<p class="note">Thanks are
due to Wojtek Skulski, Nicholas J. Schwartz, Doug Danforth, David
E. Evans and — the longest list of typos by far — Helmut Zinn.
</p>

<p class="back-side note">
  —Fyodor Tkachov, Moscow, 2012-02-18<br/>
  Last update 2014-10-05
</p>

<p class="newpage"></p>

<h3>Table of Contents</h3>
<div>
<ol id="toc">
  <li class="no-num"><a href="#preface">Preface</a></li>
  <li class="no-num"><a href="#preface-85">Preface To The 1985 Edition</a></li>
  <li class="no-num"><a href="#notation">Notation</a></li>
  <li data-list-text="1"><a href="#1"><strong>Fundamental Data Structures</strong></a>
    <ol id="l2">
      <li data-list-text="1.1"><a href="#1.1">Introduction</a></li>
      <li data-list-text="1.2"><a href="#1.2">The Concept of Data Type</a></li>
      <li data-list-text="1.3"><a href="#1.3">Standard Primitive Types</a>
        <ol id="l3">
          <li data-list-text="1.3.1"><a href="#1.3.1">The type <code>INTEGER</code></a></li>
          <li data-list-text="1.3.2"><a href="#1.3.2">The type <code>REAL</code></a></li>
          <li data-list-text="1.3.3"><a href="#1.3.3">The type <code>BOOLEAN</code></a></li>
          <li data-list-text="1.3.4"><a href="#1.3.4">The type <code>CHAR</code></a></li>
          <li data-list-text="1.3.5"><a href="#1.3.5">The type <code>SET</code></a></li>
        </ol>
      </li>
      <li data-list-text="1.4"><a href="#1.4">The Array Structure</a></li>
      <li data-list-text="1.5"><a href="#1.5">The Record Structure</a></li>
      <li data-list-text="1.6"><a href="#1.6">Representation of Arrays, Records, and Sets</a>
        <ol id="l4">
          <li data-list-text="1.6.1"><a href="#1.6.1">Representation of Arrays</a></li>
          <li data-list-text="1.6.2"><a href="#1.6.2">Representation of Records</a></li>
          <li data-list-text="1.6.3"><a href="#1.6.3">Representation of Sets</a></li>
        </ol>
      </li>
      <li data-list-text="1.7"><a href="#1.7">The File (Sequence)</a>
        <ol id="l5">
          <li data-list-text="1.7.1"><a href="#1.7.1">Elementary File Operators</a></li>
          <li data-list-text="1.7.2"><a href="#1.7.2">Buffering Sequences</a></li>
          <li data-list-text="1.7.3"><a href="#1.7.3">Buffering between Concurrent Processes</a></li>
          <li data-list-text="1.7.4"><a href="#1.7.4">Textual Input and Output</a></li>
        </ol>
      </li>
      <li data-list-text="1.8"><a href="#1.8">Searching</a>
        <ol id="l6">
          <li data-list-text="1.8.1"><a href="#1.8.1">Linear Search</a></li>
          <li data-list-text="1.8.2"><a href="#1.8.2">Binary Search</a></li>
          <li data-list-text="1.8.3"><a href="#1.8.3">Table Search</a></li>
        </ol>
      </li>
      <li data-list-text="1.9"><a href="#1.9">String Search</a>
        <ol id="l7">
          <li data-list-text="1.9.1"><a href="#1.9.1">Straight String Search</a></li>
          <li data-list-text="1.9.2"><a href="#1.9.2">The Knuth-Morris-Pratt String Search</a></li>
          <li data-list-text="1.9.3"><a href="#1.9.3">The Boyer-Moore String Search</a></li>
        </ol>
      </li>
      <li class="no-num"><a href="#1.exe">Exercises</a></li>
      <li class="no-num"><a href="#1.ref">References</a></li>
    </ol>
  </li>
  <li data-list-text="2"><a href="#2"><strong>Sorting</strong></a>
    <ol id="l8">
      <li data-list-text="2.1"><a href="#2.1">Introduction</a></li>
      <li data-list-text="2.2"><a href="#2.2">Sorting Arrays</a>
        <ol id="l9">
          <li data-list-text="2.2.1"><a href="#2.2.1">Sorting by Straight Insertion</a></li>
          <li data-list-text="2.2.2"><a href="#2.2.2">Sorting by Straight Selection</a></li>
          <li data-list-text="2.2.3"><a href="#2.2.3">Sorting by Straight Exchange</a></li>
        </ol>
      </li>
      <li data-list-text="2.3"><a href="#2.3">Advanced Sorting Methods</a>
        <ol id="l10">
          <li data-list-text="2.3.1"><a href="#2.3.1">Insertion Sort by Diminishing Increment</a></li>
          <li data-list-text="2.3.2"><a href="#2.3.2">Tree Sort</a></li>
          <li data-list-text="2.3.3"><a href="#2.3.3">Partition Sort</a></li>
          <li data-list-text="2.3.4"><a href="#2.3.4">Finding the Median</a></li>
          <li data-list-text="2.3.5"><a href="#2.3.5">A Comparison of Array Sorting Methods</a></li>
        </ol>
      </li>
      <li data-list-text="2.4"><a href="#2.4">Sorting Sequences</a>
        <ol id="l11">
          <li data-list-text="2.4.1"><a href="#2.4.1">Straight Merging</a></li>
          <li data-list-text="2.4.2"><a href="#2.4.2">Natural Merging</a></li>
          <li data-list-text="2.4.3"><a href="#2.4.3">Balanced Multiway Merging</a></li>
          <li data-list-text="2.4.4"><a href="#2.4.4">Polyphase Sort</a></li>
          <li data-list-text="2.4.5"><a href="#2.4.5">Distribution of Initial Runs</a></li>
        </ol>
      </li>
      <li class="no-num"><a href="#2.exe">Exercises</a></li>
      <li class="no-num"><a href="#2.ref">References</a></li>
    </ol>
  </li>
  <li data-list-text="3"><a href="#3"><strong>Recursive Algorithms</strong></a>
    <ol id="l12">
      <li data-list-text="3.1"><a href="#3.1">Introduction</a></li>
      <li data-list-text="3.2"><a href="#3.2">When Not to Use Recursion</a></li>
      <li data-list-text="3.3"><a href="#3.3">Two Examples of Recursive Programs</a></li>
      <li data-list-text="3.4"><a href="#3.4">Backtracking Algorithms</a></li>
      <li data-list-text="3.5"><a href="#3.5">The Eight Queens Problem</a></li>
      <li data-list-text="3.6"><a href="#3.6">The Stable Marriage Problem</a></li>
      <li data-list-text="3.7"><a href="#3.7">The Optimal Selection Problem</a></li>
      <li class="no-num"><a href="#3.exe">Exercises</a></li>
      <li class="no-num"><a href="#3.ref">References</a></li>
    </ol>
  </li>
  <li data-list-text="4"><a href="#4"><strong>Dynamic Information Structures</strong></a>
    <ol id="l13">
      <li data-list-text="4.1"><a href="#4.1">Recursive Data Types</a></li>
      <li data-list-text="4.2"><a href="#4.2">Pointers</a></li>
      <li data-list-text="4.3"><a href="#4.3">Linear Lists</a>
        <ol id="l14">
          <li data-list-text="4.3.1"><a href="#4.3.1">Basic Operations</a></li>
          <li data-list-text="4.3.2"><a href="#4.3.2">Ordered Lists and Reorganizing Lists</a></li>
          <li data-list-text="4.3.3"><a href="#4.3.3">An Application: Topological Sorting</a></li>
        </ol>
      </li>
      <li data-list-text="4.4"><a href="#4.4">Tree Structures</a>
        <ol id="l15">
          <li data-list-text="4.4.1"><a href="#4.4.1">Basic Concepts and Definitions</a></li>
          <li data-list-text="4.4.2"><a href="#4.4.2">Basic Operations on Binary Trees</a></li>
          <li data-list-text="4.4.3"><a href="#4.4.3">Tree Search and Insertion</a></li>
          <li data-list-text="4.4.4"><a href="#4.4.4">Tree Deletion</a></li>
          <li data-list-text="4.4.5"><a href="#4.4.5">Analysis of Tree Search and Insertion</a></li>
        </ol>
      </li>
      <li data-list-text="4.5"><a href="#4.5">Balanced Trees</a>
        <ol id="l16">
          <li data-list-text="4.5.1"><a href="#4.5.1">Balanced Tree Insertion</a></li>
          <li data-list-text="4.5.2"><a href="#4.5.2">Balanced Tree Deletion</a></li>
        </ol>
      </li>
      <li data-list-text="4.6"><a href="#4.6">Optimal Search Trees</a></li>
      <li data-list-text="4.7"><a href="#4.7">B-Trees</a>
        <ol id="l17">
          <li data-list-text="4.7.1"><a href="#4.7.1">Multiway B-Trees</a></li>
          <li data-list-text="4.7.2"><a href="#4.7.2">Binary B-Trees</a></li>
        </ol>
      </li>
      <li data-list-text="4.8"><a href="#4.8">Priority Search Trees</a></li>
      <li class="no-num"><a href="#4.exe">Exercises</a></li>
      <li class="no-num"><a href="#4.ref">References</a></li>
    </ol>
  </li>
  <li data-list-text="5"><a href="#5"><strong>Key Transformations (Hashing)</strong></a>
    <ol id="l18">
      <li data-list-text="5.1"><a href="#5.1">Introduction</a></li>
      <li data-list-text="5.2"><a href="#5.2">Choice of a Hash Function</a></li>
      <li data-list-text="5.3"><a href="#5.3">Collision handling</a></li>
      <li data-list-text="5.4"><a href="#5.4">Analysis of Key Transformation</a></li>
      <li class="no-num"><a href="#5.exe">Exercises</a></li>
      <li class="no-num"><a href="#5.ref">References</a></li>
    </ol>
  </li>
  <li class="no-num"><strong>Appendices</strong>
    <ol>
      <li class="no-num"><a href="#Appendix-A">A. The ASCII Character Set</a></li>
      <li class="no-num"><a href="#Appendix-B">B. The Syntax of Oberon</a></li>
      <li class="no-num"><a href="#Appendix-C">C. The Dijkstra loop</a></li>
    </ol>
  </li>
  <li class="no-num"><strong>Index</strong></li>
</ol>
</div>

<p class="newpage"></p>

<h2 id="preface"><a href='#preface'>Preface</a></h2>

<p>In recent years the subject of computer programming has been
recognized as a discipline whose mastery is fundamental and crucial
to the success of many engineering projects and which is amenable
to scientific treatement and presentation. It has advanced from a
craft to an academic discipline. The initial outstanding
contributions toward this development were made by E.W. Dijkstra
and C.A.R. Hoare. Dijkstra's
<i>Notes on Structured Programming</i> <a href="#[1]">[1]</a>
opened a new view of programming as a scientific subject and
intellectual challenge, and it coined the title for a "revolution"
in programming. Hoare's
<i>Axiomatic Basis of Computer Programming</i> <a href="#[2]">[2]</a>
showed in a lucid manner that programs are
amenable to an exacting analysis based on mathematical reasoning.
Both these papers argue convincingly that many programming errors
can be prevented by making programmers aware of the methods and
techniques which they hitherto applied intuitively and often
unconsciously. These papers focused their attention on the aspects
of composition and analysis of programs, or more explicitly, on the
structure of algorithms represented by program texts. Yet, it is
abundantly clear that a systematic and scientific approach to
program construction primarily has a bearing in the case of large,
complex programs which involve complicated sets of data. Hence, a
methodology of programming is also bound to include all aspects of
data structuring. Programs, after all, are concrete formulations of
abstract algorithms based on particular representations and
structures of data. An outstanding contribution to bring order into
the bewildering variety of terminology and concepts on data
structures was made by Hoare through his
<i>Notes on Data Structuring</i> <a href="#[3]">[3]</a>.
It made clear that decisions about structuring
data cannot be made without knowledge of the algorithms applied to
the data and that, vice versa, the structure and choice of
algorithms often depend strongly on the structure of the underlying
data. In short, the subjects of program composition and data
structures are inseparably interwined.
</p>
<p>
Yet, this book starts with a chapter on data structure for two
reasons. First, one has an intuitive feeling that data precede
algorithms: you must have some objects before you can perform
operations on them. Second, and this is the more immediate reason,
this book assumes that the reader is familiar with the basic
notions of computer programming. Traditionally and sensibly,
however, introductory programming courses concentrate on algorithms
operating on relatively simple structures of data. Hence, an
introductory chapter on data structures seems appropriate.
</p>
<p>
Throughout the book, and particularly in Chap. 1, we follow the
theory and terminology expounded by Hoare and realized in the
programming language <i>Pascal</i> <a href="#[4]">[4]</a>.
The essence of this theory
is that data in the first instance represent abstractions of real
phenomena and are preferably formulated as abstract structures not
necessarily realized in common programming languages. In the
process of program construction the data representation is
gradually refined in step with the refinement of the algorithm to
comply more and more with the constraints imposed by an available
programming system <a href="[5]">[5]</a>.
We therefore postulate a number of basic
building principles of data structures, called the fundamental
structures. It is most important that they are constructs that are
known to be quite easily implementable on actual computers, for
only in this case can they be considered the true elements of an
actual data representation, as the molecules emerging from the
final step of refinements of the data description. They are the
record, the array (with fixed size), and the set. Not surprisingly,
these basic building principles correspond to mathematical notions
that are fundamental as well.
</p>
<p>
A cornerstone of this theory of data structures is the distinction
between fundamental and "advanced" structures. The former are the
molecules themselves built out of atoms that are the components of
the latter. Variables of a fundamental structure change only their
value, but never their structure and never the set of values they
can assume. As a consequence, the size of the store they occupy
remains constant. "Advanced"
structures, however, are characterized by their change of value and
structure during the execution of a program. More sophisticated
techniques are therefore needed for their implementation. The
sequence appears as a hybrid in this classification. It certainly
varies its length; but that change in structure is of a trivial
nature. Since the sequence plays a truly fundamental role in
practically all computer systems, its treatment is included in
Chap. 1.
</p>
<p>
The second chapter treats sorting algorithms. It displays a variety
of different methods, all serving the same purpose. Mathematical
analysis of some of these algorithms shows the advantages and
disadvantages of the methods, and it makes the programmer aware of
the importance of analysis in the choice of good solutions for a
given problem. The partitioning into methods for sorting arrays and
methods for sorting files (often called internal and external
sorting) exhibits the crucial influence of data representation on
the choice of applicable algorithms and on their complexity. The
space allocated to sorting would not be so large were it not for
the fact that sorting constitutes an ideal vehicle for illustrating
so many principles of programming and situations occurring in most
other applications. It often seems that one could compose an entire
programming course by choosing examples from sorting only.
</p>
<p>
Another topic that is usually omitted in introductory programming
courses but one that plays an important role in the conception of
many algorithmic solutions is recursion. Therefore, the third
chapter is devoted to recursive algorithms. Recursion is shown to
be a generalization of repetition (iteration), and as such it is an
important and powerful concept in programming. In many programming
tutorials, it is unfortunately exemplified by cases in which simple
iteration would suffice. Instead, Chap. 3 concentrates on several
examples of problems in which recursion allows for a most natural
formulation of a solution, whereas use of iteration would lead to
obscure and cumbersome programs. The class of backtracking
algorithms emerges as an ideal application of recursion, but the
most obvious candidates for the use of recursion are algorithms
operating on data whose structure is defined recursively. These
cases are treated in the last two chapters, for which the third
chapter provides a welcome background.
</p>
<p>
Chapter 4 deals with dynamic data structures, i.e., with data that
change their structure during the execution of the program. It is
shown that the recursive data structures are an important subclass
of the dynamic structures commonly used. Although a recursive
definition is both natural and possible in these cases, it is
usually not used in practice. Instead, the mechanism used in its
implementation is made evident to the programmer by forcing him to
use explicit reference or pointer variables. This book follows this
technique and reflects the present state of the art: Chapter 4 is
devoted to programming with pointers, to lists, trees and to
examples involving even more complicated meshes of data. It
presents what is often (and somewhat inappropriately) called list
processing. A fair amount of space is devoted to tree
organizations, and in particular to search trees. The chapter ends
with a presentation of scatter tables, also called "hash" codes,
which are often preferred to search trees. This provides the
possibility of comparing two fundamentally different techniques for
a frequently encountered application.
</p>
<p>
Programming is a constructive activity. How can a constructive,
inventive activity be taught? One method is to crystallize
elementary composition principles out of many cases and exhibit
them in a systematic manner. But programming is a field of vast
variety often involving complex intellectual activities. The belief
that it could ever be condensed into a sort of pure recipe teaching
is mistaken. What remains in our arsenal of teaching methods is the
careful selection and presentation of master examples. Naturally,
we should not believe that every person is capable of gaining
equally much from the study of examples. It is the characteristic
of this approach that much is left to the student, to his diligence
and intuition. This is particularly true of the relatively involved
and long example programs. Their inclusion in this book is not
accidental. Longer programs are the prevalent case in practice, and
they are much more suitable for exhibiting that elusive but
essential ingredient called style and orderly structure. They are
also meant to serve as exercises in the art of program reading,
which too often is neglected in favor of program writing. This is a
primary motivation behind the inclusion of larger programs as
examples in their entirety.
The reader is led through a gradual development of the program; he is
given various snapshots in the evolution of a program, whereby this
development becomes manifest as a stepwise refinement of the
details. I consider it essential that programs are shown in final
form with sufficient attention to details, for in programming, the
devil hides in the details. Although the mere presentation of an
algorithm's principle and its mathematical analysis may be
stimulating and challenging to the academic mind, it seems
dishonest to the engineering practitioner. I have therefore
strictly adhered to the rule of presenting the final programs in a
language in which they can actually be run on a computer.
</p>
<p>
Of course, this raises the problem of finding a form which at the
same time is both machine executable and sufficiently machine
independent to be included in such a text. In this respect, neither
widely used languages nor abstract notations proved to be adequate.
The language Pascal provides an appropriate compromise; it had been
developed with exactly this aim in mind, and it is therefore used
throughout this book. The programs can easily be understood by
programmers who are familiar with some other high-level language,
such as ALGOL 60 or PL/1, because it is easy to understand the
Pascal notation while proceeding through the text. However, this
not to say that some proparation would not be beneficial. The book
<i>Systematic Programming</i> <a href="#[6]">[6]</a>
provides an ideal background
because it is also based on the Pascal notation. The present book
was, however, not intended as a manual on the language Pascal;
there exist more appropriate texts for this purpose
<a href="#[7]">[7]</a>.
</p>
<p>
This book is a condensation and at the same time an elaboration of
several courses on programming taught at the Federal Institute of
Technology (ETH) at Zürich. I owe many
ideas and views expressed in this book to discussions with my
collaborators at ETH. In particular, I wish to thank Mr. H.
Sandmayr for his careful reading of the manuscript, and Miss Heidi
Theiler and my wife for their care and patience in typing the text.
I should also like to mention the stimulating influence provided by
meetings of the Working Groups 2.1 and 2.3 of IFIP, and
particularly the many memorable arguments I had on these occasions
with E. W. Dijkstra and C.A.R. Hoare. Last but not least, ETH generously
provided the environment and the computing facilities without which
the preparation of this text would have been impossible.</p>
<p>Zürich, Aug. 1975<span class="back-side"> N. Wirth</span></p>

<div>
<ol id="l19" class="noindent id">
  <li id="[1]">
    E.W. Dijkstra, in: O.-J. Dahl, E.W. Dijkstra, C.A.R. Hoare.
    Structured Programming. F. Genuys, Ed., New York, Academic Press,
    1972, pp. 1-82.
  </li>
  <li id="[2]">
    C.A.R. Hoare. <i>Comm. ACM</i>, 12, No. 10 (1969), 576-83.
  </li>
  <li id="[3]">
    C.A.R. Hoare, in Structured Programming [1], cc. 83-174.
  </li>
  <li id="[4]">
    N. Wirth. The Programming Language Pascal. <i>Acta Informatica</i>,
    1, No. 1 (1971), 35-63.
  </li>
  <li id="[5]">
    N. Wirth. Program Development by Stepwise Refinement. <i>Comm.
      ACM</i>, 14, No. 4 (1971), 221-27.
  </li>
  <li id="[6]">
    N. Wirth. Systematic Programming. Englewood Cliffs, N.J.
    Prentice-Hall, Inc., 1973.
  </li>
  <li id="[7]">
    K. Jensen and N. Wirth. PASCAL-User Manual and Report. Berlin,
    Heidelberg, New York; Springer-Verlag, 1974.
  </li>
</ol>
</div>

<h2 id="preface-85"><a href='#preface-85'>Preface To The 1985 Edition</a></h2>

<p>This new Edition incorporates many revisions of details and several
changes of more significant nature. They were all motivated by
experiences made in the ten years since the first Edition appeared.
Most of the contents and the style of the text, however, have been
retained. We briefly summarize the major alterations. The major
change which pervades the entire text concerns the programming
language used to express the algorithms. Pascal has been replaced
by Modula-2. Although this change is of no fundamental influence to
the presentation of the algorithms, the choice is justified by the
simpler and more elegant syntactic structures of Modula-2, which
often lead to a more lucid representation of an algorithm's
structure. Apart from this, it appeared advisable to use a notation
that is rapidly gaining acceptance by a wide community, because it
is well-suited for the development of large programming systems.
Nevertheless, the fact that Pascal is Modula's ancestor is very
evident and eases the task of a transition. The syntax of Modula is
summarized in the Appendix for easy reference.</p>

<p>As a direct consequence of this change of programming language,
Sect. 1.11 on the sequential file structure has been rewritten.
Modula-2 does not offer a built-in file type. The revised Sect.
1.11 presents the concept of a sequence as a data structure in a
more general manner, and it introduces a set of program modules
that incorporate the sequence concept in Modula-2 specifically.</p>

<p>The last part of Chapter 1 is new. It is dedicated to the subject
of searching and, starting out with linear and binary search, leads
to some recently invented fast string searching algorithms. In this
section in particular we use assertions and loop invariants to
demonstrate the correctness of the presented algorithms.</p>

<p>A new section on priority search trees rounds off the chapter on
dynamic data structures. Also this species of trees was unknown
when the first Edition appeared. They allow an economical
representation and a fast search of point sets in a plane.</p>

<p>The entire fifth chapter of the first Edition has been omitted. It
was felt that the subject of compiler construction was somewhat
isolated from the preceding chapters and would rather merit a more
extensive treatment in its own volume.</p>

<p>Finally, the appearance of the new Edition reflects a development
that has profoundly influenced publications in the last ten years:
the use of computers and sophisticated algorithms to prepare and
automatically typeset documents. This book was edited and laid out
by the author with the aid of a Lilith computer and its document
editor Lara. Without these tools, not only would the book become
more costly, but it would certainly not be finished yet.</p>

<p>Palo Alto, March 1985 <span class="back-side">N. Wirth</span></p>

<h2 id="notation"><a href='#notation'>Notation</a></h2>

<p>The following notations, adopted from publications of E.W.
Dijkstra, are used in this book.</p>

<p>In logical expressions, the character <code>&amp;</code>
denotes conjunction and is pronounced as and. The character
<code>~</code> denotes negation and is pronounced as
not. Boldface <code>A</code> and <code>E</code> are used to
denote the universal and existential
quantifiers. In the following formulas, the left part is the
notation used and defined here in terms of the right part. Note
that the left parts avoid the use of the symbol "...", which
appeals to the readers intuition.
</p>

<code class='large'><strong>A</strong>i: m ≤ i &lt; n : P<sub>i</sub>    P<sub>m</sub> &amp; P<sub>m+1</sub> &amp; ... &amp; P<sub>n-1</sub>
</code>

<p>The <code>P<sub>i</sub></code> are
predicates, and the formula asserts that for all indices
<code>i</code> ranging from a given value <code>m</code> to,
but excluding a value <code>n P<sub>i</sub></code> holds.
</p>

<code class='large'><strong>E</strong>i: m ≤ i &lt; n : P<sub>i</sub>    P<sub>m</sub> or P<sub>m+1</sub> or ... or P<sub>n-1</sub>
</code>

<p>The <code>P<sub>i</sub></code> are
predicates, and the formula asserts that for some indices
<code>i</code> ranging from a given value <code>m</code> to,
but excluding a value <code>n P<sub>i</sub></code> holds.
</p>

<code class='large'><strong>S</strong>i: m ≤ i &lt; n : x<sub>i</sub> = x<sub>m</sub> + x<sub>m+1</sub> + ... + x<sub>n-1</sub>
</code>

<code class='large'>MIN i: m ≤ i &lt; n : x<sub>i</sub> = <span class="p">minimum</span>(x<sub>m</sub> , ... , x<sub>n-1</sub>)</code>

<code class='large'>
MAX i: m ≤ i &lt; n : x<sub>i</sub> = <span class="p">maximum</span>(x<sub>m</sub> , ... , x<sub>n-1</sub>)</code>

<p class="newpage"></p>

<ol class="page" id="l20">
<li data-list-text="1" id="1">
<h2><a href='#1'>Fundamental Data Structures</a></h2>
<ol class="page" id="l21">
<li data-list-text="1.1" id="1.1">
<h3><a href='#1.1'>Introduction</a></h3>

<p>The modern digital computer was invented and intended as a device
that should facilitate and speed up complicated and time-consuming
computations. In the majority of applications its capability to
store and access large amounts of information plays the dominant
part and is considered to be its primary characteristic, and its
ability to compute, i.e., to calculate, to perform arithmetic, has
in many cases become almost irrelevant.</p>

<p>In all these cases, the large amount of information that is to be
processed in some sense represents an abstraction of a part of
reality. The information that is available to the computer consists
of a selected set of data about the actual problem, namely that set
that is considered relevant to the problem at hand, that set from
which it is believed that the desired results can be derived. The
data represent an abstraction of reality in the sense that certain
properties and characteristics of the real objects are ignored
because they are peripheral and irrelevant to the particular
problem. An abstraction is thereby also a simplification of
facts.</p>

<p>We may regard a personnel file of an employer as an example. Every
employee is represented (abstracted) on this file by a set of data
relevant either to the employer or to his accounting procedures.
This set may include some identification of the employee, for
example, his or her name and salary. But it will most probably not
include irrelevant data such as the hair color, weight, and
height.</p>

<p>In solving a problem with or without a computer it is necessary to
choose an abstraction of reality, i.e., to define a set of data
that is to represent the real situation. This choice must be guided
by the problem to be solved. Then follows a choice of
representation of this information. This choice is guided by the
tool that is to solve the problem, i.e., by the facilities offered
by the computer. In most cases these two steps are not entirely
separable.</p>

<p>The choice of representation of data is often a fairly difficult
one, and it is not uniquely determined by the facilities available.
It must always be taken in the light of the operations that are to
be performed on the data. A good example is the representation of
numbers, which are themselves abstractions of properties of objects
to be characterized. If addition is the only (or at least the
dominant) operation to be performed, then a good way to represent
the number <code>n</code> is to write <code>n</code> strokes.
The addition rule on this representation is
indeed very obvious and simple. The Roman numerals are based on the
same principle of simplicity, and the adding rules are similarly
straightforward for small numbers. On the other hand, the
representation by Arabic numerals requires rules that are far from
obvious (for small numbers) and they must be memorized. However,
the situation is reversed when we consider either addition of large
numbers or multiplication and division. The decomposition of these
operations into simpler ones is much easier in the case of
representation by Arabic numerals because of their systematic
structuring principle that is based on positional weight of the
digits.</p>

<p>It is generally known that computers use an internal representation
based on binary digits (bits). This representation is unsuitable
for human beings because of the usually large number of digits
involved, but it is most suitable for electronic circuits because
the two values 0 and 1 can be represented conveniently and reliably
by the presence or absence of electric currents, electric charge,
or magnetic fields.</p>

<p>From this example we can also see that the question
of representation often transcends several levels of detail. Given
the problem of representing, say, the position of an object, the
first decision may lead to the choice of a pair of real numbers in,
say, either Cartesian or polar coordinates. The second decision may
lead to a floating-point representation, where every real number x
consists of a pair of integers denoting a fraction <code>f</code>
and an exponent <code>e</code> to a
certain base (such that <code>x = f × 2<sup>e</sup></code>).
The third decision, based on the knowledge that the data are to
be stored in a computer, may lead to
a binary, positional representation of integers, and the final
decision could be to represent binary digits by the electric charge
in a semiconductor storage device. Evidently, the first decision in
this chain is mainly influenced by the problem situation, and the
later ones are progressively dependent on the tool and its
technology. Thus, it can hardly be required that a programmer
decide on the number representation to be employed, or even on the
storage device characteristics. These lower-level decisions can be
left to the designers of computer equipment, who have the most
information available on current technology with which to make a
sensible choice that will be acceptable for all (or almost all)
applications where numbers play a role.</p>

<p>In this context, the significance of programming languages becomes
apparent. A programming language represents an abstract computer
capable of interpreting the terms used in this language, which may
embody a certain level of abstraction from the objects used by the
actual machine. Thus, the programmer who uses such a higher-level
language will be freed (and barred) from questions of number
representation, if the number is an elementary object in the realm
of this language.</p>

<p>The importance of using a language that offers a convenient set of
basic abstractions common to most problems of data processing lies
mainly in the area of reliability of the resulting programs. It is
easier to design a program based on reasoning with familiar notions
of numbers, sets, sequences, and repetitions than on bits, storage
units, and jumps. Of course, an actual computer represents all
data, whether numbers, sets, or sequences, as a large mass of bits.
But this is irrelevant to the programmer as long as he or she does
not have to worry about the details of representation of the chosen
abstractions, and as long as he or she can rest assured that the
corresponding representation chosen by the computer (or compiler)
is reasonable for the stated purposes.</p>

<p>The closer the abstractions are to a given computer, the easier it
is to make a representation choice for the engineer or implementor
of the language, and the higher is the probability that a single
choice will be suitable for all (or almost all) conceivable
applications. This fact sets definite limits on the degree of
abstraction from a given real computer. For example, it would not
make sense to include geometric objects as basic data items in a
general-purpose language, since their proper repesentation will,
because of its inherent complexity, be largely dependent on the
operations to be applied to these objects. The nature and frequency
of these operations will, however, not be known to the designer of
a general-purpose language and its compiler, and any choice the
designer makes may be inappropriate for some potential
applications.</p>

<p>In this book these deliberations determine the choice of notation
for the description of algorithms and their data. Clearly, we wish
to use familiar notions of mathematics, such as numbers, sets,
sequences, and so on, rather than computer-dependent entities such
as bitstrings. But equally clearly we wish to use a notation for
which efficient compilers are known to exist. It is equally unwise
to use a closely machine-oriented and machine-dependent language,
as it is unhelpful to describe computer programs in an abstract
notation that leaves problems of representation widely open. The
programming language Pascal had been designed in an attempt to find
a compromise between these extremes, and the successor languages
Modula-2 and Oberon are the result of decades of experience [1-3].
Oberon retains Pascal's basic concepts and incorporates some
improvements and some extensions; it is used throughout this book
[1-5]. It has been successfully implemented on several computers,
and it has been shown that the notation is sufficiently close to
real machines that the chosen features and their representations
can be clearly explained. The language is also sufficiently close
to other languages, and hence the lessons taught here may equally
well be applied in their use.</p>
</li>
<li data-list-text="1.2" id="1.2">
<h3><a href='#1.2'>The Concept of Data Type</a></h3>

<p>In mathematics it is customary to classify variables according to
certain important characteristics. Clear distinctions are made
between real, complex, and logical variables or between variables
representing individual values, or sets of values, or sets of sets,
or between functions, functionals, sets of functions, and
so on. This notion of classification is equally if not more
important in data processing. We will adhere to the principle that
every constant, variable, expression, or function is of a certain
<i>type</i>. This type essentially characterizes the set of values
to which a constant belongs, or which can be assumed by a variable
or expression, or which can be generated by a function.</p>

<p>In mathematical texts the type of a variable is usually deducible
from the typeface without consideration of context; this is not
feasible in computer programs. Usually there is one typeface
available on computer equipment (i.e., Latin letters). The rule is
therefore widely accepted that the associated type is made explicit
in a declaration of the constant, variable, or function, and that
this <i>declaration</i> textually precedes the application of that
constant, variable, or function. This rule is particularly sensible
if one considers the fact that a compiler has to make a choice of
representation of the object within the store of a computer.
Evidently, the amount of storage allocated to a variable will have
to be chosen according to the size of the range of values that the
variable may assume. If this information is known to a compiler,
so-called dynamic storage allocation can be avoided. This is very
often the key to an efficient realization of an algorithm.</p>

<p>The primary characteristics of the concept of type that is used
throughout this text, and that is embodied in the programming
language Oberon, are the following [1-2]:</p>
<ol class="noindent" id="l22">
<li data-list-text="1.">
<p>A data type determines the set of values to which a constant
belongs, or which may be assumed by a variable or an expression, or
which may be generated by an operator or a function.</p>
</li>
<li data-list-text="2.">
<p>The type of a value denoted by a constant, variable, or expression
may be derived from its form or its declaration without the
necessity of executing the computational process.</p>
</li>
<li data-list-text="3.">
<p>Each operator or function expects arguments of a fixed type and
yields a result of a fixed type. If an operator admits arguments of
several types (e.g., + is used for addition of both integers and
real numbers), then the type of the result can be determined from
specific language rules.</p>
</li>
</ol>

<p>As a consequence, a compiler may use this information on types to
check the legality of various constructs. For example, the mistaken
assignment of a Boolean (logical) value to an arithmetic variable
may be detected without executing the program. This kind of
redundancy in the program text is extremely useful as an aid in the
development of programs, and it must be considered as the primary
advantage of good high-level languages over machine code (or
symbolic assembly code). Evidently, the data will ultimately be
represented by a large number of binary digits, irrespective of
whether or not the program had initially been conceived in a
high-level language using the concept of type or in a typeless
assembly code. To the computer, the store is a homogeneous mass of
bits without apparent structure. But it is exactly this abstract
structure which alone is enabling human programmers to recognize
meaning in the monotonous landscape of a computer store.</p>

<p>The theory presented in this book and the programming language
Oberon specify certain methods of defining data types. In most
cases new data types are defined in terms of previously defined
data types. Values of such a type are usually conglomerates of
component values of the previously defined constituent types, and
they are said to be <i>structured</i>. If there is only one
constituent type, that is, if all components are of the same
constituent type, then it is known as the base type. The number of
distinct values belonging to a type <code>T</code> is
called its <i>cardinality</i>. The cardinality provides a measure
for the amount of storage needed to represent a variable
<code>x</code> of the type <code>T</code>,
denoted by <code>x: T</code>.</p>

<p>Since constituent types may again be structured, entire hierarchies
of structures may be built up, but, obviously, the ultimate
components of a structure are atomic. Therefore, it is necessary
that a notation is provided to introduce such primitive,
unstructured types as well. A straightforward method is that of
<i>enumerating</i> the values that are to constitute the type. For
example in a program concerned with plane geometric figures, we may
introduce a primitive type called shape, whose values may be
denoted by the identifiers <i>rectangle, square, ellipse,
circle</i>. But apart from such programmer-defined types, there
will have to be some standard, predefined types. They usually include
numbers and logical values. If an ordering exists among the
individual values, then the type is said to be ordered or scalar.
In Oberon, all unstructured types are ordered; in the case of
explicit enumeration, the values are assumed to be ordered by their
enumeration sequence.</p>

<p>With this tool in hand, it is possible to define primitive types
and to build conglomerates, structured types up to an arbitrary
degree of nesting. In practice, it is not sufficient to have only
one general method of combining constituent types into a structure.
With due regard to practical problems of representation and use, a
general-purpose programming language must offer several methods of
structuring. In a mathematical sense, they are equivalent; they
differ in the operators available to select components of these
structures. The basic structuring methods presented here are the
<i>array</i>, the <i>record</i>, the <i>set</i>, and the
<i>sequence</i>. More complicated structures are not usually
defined as static types, but are instead dynamically generated
during the execution of the program, when they may vary in size and
shape. Such structures are the subject of Chap. 4 and include
lists, rings, trees, and general, finite graphs.</p>

<p>Variables and data types are introduced in a program in order to be
used for computation. To this end, a set of operators must be
available. For each standard data type a programming languages
offers a certain set of primitive, standard operators, and likewise
with each structuring method a distinct operation and notation for
selecting a component. The task of composition of operations is
often considered the heart of the art of programming. However, it
will become evident that the appropriate composition of data is
equally fundamental and essential.</p>

<p>The most important basic operators are comparison and assignment,
i.e., the test for equality (and for order in the case of ordered
types), and the command to enforce equality. The fundamental
difference between these two operations is emphasized by the clear
distinction in their denotation throughout this text.</p>

<p> &nbsp; Test for equality: <code>x = y</code> (an expression
with value <code>TRUE</code> or <code>FALSE</code>)</p>

<p> &nbsp; Assignment to <code>x</code>:
<code>x := y</code> (a statement making <code>x</code>
equal to <code>y</code>)</p>

<p>These fundamental operators are defined for most data types, but it
should be noted that their execution may involve a substantial
amount of computational effort, if the data are large and highly
structured.</p>
<p>
For the standard primitive data types, we postulate not only the
availability of assignment and comparison, but also a set of
operators to create (compute) new values. Thus we introduce the
standard operations of arithmetic for numeric types and the
elementary operators of propositional logic for logical values.</p>
</li>
<li data-list-text="1.3" id="1.3">
<h3><a href='#1.3'>Standard Primitive Types</a></h3>

<p>Standard primitive types are those types that are available on most
computers as built-in features. They include the whole numbers, the
logical truth values, and a set of printable characters. On many
computers fractional numbers are also incorporated, together with
the standard arithmetic operations. We denote these types by the
identifiers</p>
<code>INTEGER, REAL, BOOLEAN, CHAR, SET</code>

<ol class="page" id="l23">
<li data-list-text="1.3.1" id="1.3.1">
<h4><a href='#1.3.1'>The type <code>INTEGER</code></a></h4>

<p>The type <code>INTEGER</code> comprises a subset of the
whole numbers whose size may vary among individual computer
systems. If a computer uses <code>n</code> bits to
represent an integer in two's complement notation, then the
admissible values x must satisfy <code>-2<sup>n-1</sup></code> ≤ <code>x &lt; 2<sup>n-1</sup></code>. It is assumed that all operations on data of this
type are exact and correspond to the ordinary laws of arithmetic,
and that the computation will be interrupted in the case of a
result lying outside the representable subset. This event is called
<i>overflow</i>. The standard operators are the four basic
arithmetic operations of addition (<code>+</code>),
subtraction (<code>-</code>), multiplication
(<code>*</code>) and division (<code>/</code>, <code>DIV</code>).</p>

<p>Whereas the slash denotes ordinary division resulting in a value of
type <code>REAL</code>, the operator <code>DIV</code>
denotes integer division resulting in a value of
type <code>INTEGER</code>. If we define the quotient
<code>q = m DIV n</code> and the remainder <code>r = m MOD n</code>,
the following relations hold, assuming <code>n &gt; 0</code>:</p>

<code>q*n + r = m</code> &nbsp;&nbsp; and &nbsp;&nbsp; <code>0 ≤ r &lt; n</code>
<p class="s5">Examples</p>
<pre><code class='large'> 31 DIV 10 =  3      31 MOD 10 = 1
-31 DIV 10 = -4     -31 MOD 10 = 9</code></pre>

<p>We know that dividing by <code>10<sup>n</sup></code>
can be achieved by merely shifting the decimal
digits <code>n</code> places to the right and thereby
ignoring the lost digits. The same method applies, if numbers are
represented in binary instead of decimal form. If two's complement
representation is used (as in practically all modern computers),
then the shifts implement a division as defined by the above
<code>DIV</code> operaton. Moderately sophisticated
compilers will therefore represent an operation of the form
<code>m DIV 2<sup>n</sup></code> or
<code>m MOD 2<sup>n</sup></code> by a fast
shift (or mask) operation.</p>

</li>
<li data-list-text="1.3.2" id="1.3.2">
<h4><a href='#1.3.2'>The type <code>REAL</code></a></h4>

<p>The type <code>REAL</code> denotes a subset of the real
numbers. Whereas arithmetic with operands of the types
<code>INTEGER</code> is assumed to yield exact results, arithmetic
on values of type <code>REAL</code> is permitted to be
inaccurate within the limits of round-off errors caused by
computation on a finite number of digits. This is the principal
reason for the explicit distinction between the types
<code>INTEGER</code> and <code>REAL</code>, as it is made
in most programming languages.</p>

<p>The standard operators are the four basic arithmetic operations of
addition (+), subtraction (-), multiplication (*), and division
(/). It is an essence of data typing that different types are
incompatible under assignment. An exception to this rule is made
for assignment of integer values to real variables, because here
the semanitcs are unambiguous. After all, integers form a subset of
real numbers. However, the inverse direction is not permissible:
Assignment of a real value to an integer variable requires an
operation such as truncation or rounding. The standard transfer
function <code>ENTIER(x)</code> yields the integral part
of <code>x</code>. Rounding of <code>x</code>
is obtained by <code>ENTIER(x + 0.5)</code>.</p>

<p>Many programming languages do not include an exponentiation
operator. The following is an algorithm for the fast computation of
<code>y = x<sup>n</sup></code>, where
<code>n</code> is a non-negative integer.</p>
<code class='large'>y := 1.0; i := n; <span >(* ADenS13 *)</span>
WHILE i &gt; 0 DO (* x<sub>0</sub><sup>n</sup> = x<sup>i</sup> * y *)
  IF ODD(i) THEN y := y*x END;
  x := x*x; i := i DIV 2
END</code>
</li>

<li data-list-text="1.3.3" id="1.3.3">
<h4><a href='#1.3.3'>The type <code>BOOLEAN</code></a></h4>

<p>The two values of the standard type <code>BOOLEAN</code>
are denoted by the identifiers <code>TRUE</code> and
<code>FALSE</code>. The Boolean operators are the
logical conjunction, disjunction, and negation whose values are
defined in Table 1.1. The logical conjunction is denoted by the symbol
<code>&amp;</code>, the logical disjunction by <code>OR</code>,
and negation by "~". Note that comparisons are
operations yielding a result of type <code>BOOLEAN</code>.
Thus, the result of a comparison may be
assigned to a variable, or it may be used as an operand of a
logical operator in a Boolean expression. For instance, given
Boolean variables <code>p</code> and <code>q</code>
and integer variables <code>x = 5</code>,
<code>y = 8</code>, <code>z = 10</code>, the two assignments
</p>
<code class='large'>p := x = y
q := (x ≤ y) &amp; (y &lt; z)</code>

<p> yield <code>p = FALSE</code> and <code>q = TRUE</code>.
</p>

<div class='table'><table>
<caption>Table 1.1. Boolean Operators.</caption>
<tr><th><code>p</code>     </th><th><code>q</code>      </th><th><code>p OR q</code> </th><th><code>p &amp; q</code></th><th><code>~p</code>   </th></tr>
<tr><td><code>TRUE</code>  </td><td><code>TRUE</code>   </td><td><code>TRUE</code>   </td><td><code>TRUE</code>     </td><td><code>FALSE</code></td></tr>
<tr><td><code>TRUE</code>  </td><td><code>FALSE</code>  </td><td><code>TRUE</code>   </td><td><code>FALSE</code>    </td><td><code>FALSE</code></td></tr>
<tr><td><code>FALSE</code> </td><td><code>TRUE</code>   </td><td><code>TRUE</code>   </td><td><code>FALSE</code>    </td><td><code>TRUE</code> </td></tr>
<tr><td><code>FALSE</code> </td><td><code>FALSE</code>  </td><td><code>FALSE</code>  </td><td><code>FALSE</code>    </td><td><code>TRUE</code> </td></tr>
</table></div>

<p>The Boolean operators <code>&amp;</code>
(<code>AND</code>) and <code>OR</code> have an additional
property in most programming languages, which distinguishes them
from other dyadic operators. Whereas, for example, the sum
<code>x+y</code> is not defined, if either
<code>x</code> or <code>y</code> is undefined, the
conjunction <code>p&amp;q</code> is defined even if
<code>q</code> is undefined, provided that
<code>p</code> is <code>FALSE</code>. This conditionality
is an important and useful property. The exact definition of
<code>&amp;</code> and <code>OR</code> is
therefore given by the following equations:</p>

<div class='table'><table>
<tr>
  <td><code>p &amp; q</code></td><td>= if <code>p</code> then <code>q</code> else <code>FALSE</code></td>
</tr>
<tr>
  <td><code>p OR q</code></td><td>= if <code>p</code> then <code>TRUE</code> else <code>q</code></td>
</tr>
</table></div>

</li>

<li data-list-text="1.3.4" id="1.3.4">
<h4><a href='#1.3.4'>The type <code>CHAR</code></a></h4>

<p>The standard type <code>CHAR</code> comprises a set of
printable characters. Unfortunately, there is no generally accepted
standard character set used on all computer systems. Therefore, the
use of the predicate "standard" may in this case be almost
misleading; it is to be understood in the sense of "standard on the
computer system on which a certain program is to be executed."</p>

<p>The character set defined by the International Standards
Organization (ISO), and particularly its American version ASCII
(American Standard Code for Information Interchange) is the most
widely accepted set. The ASCII set is therefore tabulated in
Appendix A. It consists of 95 printable (graphic) characters and 33
control characters, the latter mainly being used in data
transmission and for the control of printing equipment.</p>

<p>In order to be able to design algorithms involving characters
(i.e., values of type <code>CHAR</code>), that are
system independent, we should like to be able to assume certain
minimal properties of character sets, namely:</p>

<ol class="noindent" id="l24">
<li data-list-text="1.">

<p>The type <code>CHAR</code> contains the 26 capital Latin
letters, the 26 lower-case letters, the 10 decimal digits, and a
number of other graphic characters, such as punctuation marks.</p>
</li>
<li data-list-text="2.">
<p>The subsets of letters and digits are ordered and contiguous,
i.e.,</p>

<p><code>("A" ≤ x) &amp; (x ≤ "Z")</code> implies that <code>x</code>
is a capital letter </p>

<p><code>("a" ≤ x) &amp; (x ≤ "z")</code>
implies that <code>x</code> is a lower-case letter</p>

<p><code>("0" ≤ x) &amp; (x ≤ "9")</code> implies that
<code>x</code> is a decimal digit</p>

</li>
<li data-list-text="3.">

<p>The type <code>CHAR</code> contains a non-printing,
blank character and a line-end character that may be used as
separators.</p>
</li>
</ol>

<img src="fig/1.1.png" alt="THIS IS A TEXT"/>

<p>Fig. 1.1. Representations of a text</p>

<p>The availability of two standard type transfer functions between
the types <code>CHAR</code> and <code>INTEGER</code>
is particularly important in the quest to write
programs in a machine independent form. We will call them
<code>ORD(ch)</code>, denoting the ordinal number of
<code>ch</code> in the character set, and <code>CHR(i)</code>,
denoting the character with ordinal number
<code>i</code>. Thus, <code>CHR</code> is the
inverse function of <code>ORD,</code> and vice versa,
that is,</p>

<p><code> ORD(CHR(i)) = i       </code> (if <code>CHR(i)</code> is defined)</p>
<p><code> CHR(ORD(c)) = c</code></p>

<p>Furthermore, we postulate a standard function
<code>CAP(ch)</code>. Its value is defined as the capital letter
corresponding to <code>ch</code>, provided <code>ch</code> is a letter.</p>

<p><code>ch</code> is a lower-case letter implies that
<code>CAP(ch) = </code>corresponding capital letter</p>
<p><code>ch</code> is a capital letter implies that
<code>CAP(ch) = ch</code></p>

</li>
<li data-list-text="1.3.5" id="1.3.5">
<h4><a href='#1.3.5'>The type <code>SET</code></a></h4>

<p>The type <code>SET</code> denotes sets whose elements
are integers in the range 0 to a small number, typically
31 or 63. Given, for example, variables</p>
<code>VAR r, s, t: SET</code>
<p>possible assignments are</p>
<code>r := {5}; s := {x, y .. z}; t := {}</code>
<p>Here, the value assigned to <code>r</code> is the
singleton set consisting of the single element 5; to
<code>t</code> is assigned the empty set, and to <code>s</code>
the elements <code>x</code>, <code>y</code>, <code>y+1</code>,
 … , <code>z-1</code>, <code>z</code>.
 </p>

<p>The following elementary operators are defined on variables of type
<code>SET</code>:</p>
<div class='table'><table>
  <tr><td><code>*  </code></td><td>set intersection</td></tr>
  <tr><td><code>+  </code></td><td>set union</td></tr>
  <tr><td><code>-  </code></td><td>set difference</td></tr>
  <tr><td><code>/  </code></td><td>symmetric set difference</td></tr>
  <tr><td><code>IN  </code></td><td>set membership</td></tr>
</table></div>

<p>Constructing the intersection or the union of two sets is often
called set multiplication or set addition, respectively; the
priorities of the set operators are defined accordingly, with the
intersection operator having priority over the union and difference
operators, which in turn have priority over the membership
operator, which is classified as a relational operator. Following
are examples of set expressions and their fully parenthesized
equivalents:</p>

<div class='table'><table>
  <tr><td>r * s + t</td><td>= (r*s) + t</td></tr>
  <tr><td>r - s * t</td><td>= r - (s*t)</td></tr>
  <tr><td>r - s + t</td><td>= (r-s) + t</td></tr>
  <tr><td>r + s / t</td><td>= r + (s/t)</td></tr>
  <tr><td>x IN s + t</td><td>= x IN (s+t)</td></tr>
</table></div>

</li>
</ol>
</li>

<li data-list-text="1.4" id="1.4">
<h3><a href='#1.4'>The Array Structure</a></h3>

<p>The array is probably the most widely used data structure; in some
languages it is even the only one available. An array consists of
components which are all of the same type, called its base type; it
is therefore called a <i>homogeneous</i> structure. The array is a
<i>random-access</i> structure, because all components can be
selected at random and are equally quickly accessible. In order to
denote an individual component, the name of the entire structure is
augmented by the <i>index</i> selecting the component. This index
is to be an integer between 0 and <code>n-1</code>,
where <code>n</code> is the number of elements, the
<i>size</i>, of the array.</p>
<code>TYPE T = ARRAY n OF T0</code>

<p class="s5">Examples</p>
<code class='large'>TYPE Row = ARRAY 4 OF REAL
TYPE Card = ARRAY 80 OF CHAR
TYPE Name = ARRAY 32 OF CHAR</code>

<p>A particular value of a variable</p>
<code>VAR x: Row</code>

<p>with all components satisfying the equation
<code>x<sub>i</sub> = 2<sup>-i</sup></code>,
may be visualized as shown in Fig.1.2.
</p>

<div class='table'>
<table id="Fig1_2">
  <caption>Fig. 1.2. Array of type <code>Row</code> with <code>x<sub>i</sub> = 2<sup>-i</sup></code>.</caption>
<tr><th>x<sub>0</sub></th><td>1.0</td></tr>
<tr><th>x<sub>1</sub></th><td>0.5</td></tr>
<tr><th>x<sub>2</sub></th><td>0.25</td></tr>
<tr><th>x<sub>3</sub></th><td>0.125</td></tr>
</table></div>

<p>An individual component of an array can be selected by an
<i>index</i>. Given an array variable <code>x</code>, we
denote an array selector by the array name followed by the
respective component's index <code>i</code>, and we
write <code>x<sub>i</sub></code> or
<code>x[i]</code>. Because of the first, conventional
notation, a component of an array component is therefore also
called a <i>subscripted</i> variable.</p>

<p>The common way of operating with arrays, particularly with large
arrays, is to selectively update single components rather than to
construct entirely new structured values. This is expressed by
considering an array variable as an array of component variables
and by permitting assignments to selected components, such as for
example <code>x[i] := 0.125</code>. Although selective
updating causes only a single component value to change, from a
conceptual point of view we must regard the entire composite value
as having changed too.</p>

<p>The fact that array indices, i.e., names of array components, are
integers, has a most important consequence: indices may be
computed. A general index expression may be substituted in place of
an index constant; this expression is to be evaluated, and the
result identifies the selected component. This generality
not only provides a most significant and powerful
programming facility, but at the same time it also gives rise to
one of the most frequently encountered programming mistakes: The
resulting value may be outside the interval specified as the range
of indices of the array. We will assume that decent computing
systems provide a warning in the case of such a mistaken access to
a non-existent array component.</p>

<p>The cardinality of a structured type, i. e. the number of values
belonging to this type, is the product of the cardinality of its
components. Since all components of an array type <code>T</code>
are of the same base type <code>T0</code>,
we obtain</p>
<code>card(T) = card(T0)<sup>n</sup></code>
<p>Constituents of array types may themselves be structured. An array
variable whose components are again arrays is called a
<i>matrix</i>. For example,</p>
<code>M: ARRAY 10 OF Row</code>
<p>is an array consisting of ten components (rows), each constisting
of four components of type <code>REAL</code>. and is
called a 10 <code>x</code> 4 matrix with real
components. Selectors may be concatenated accordingly, such that
<code>M<sub>ij</sub></code> and
<code>M[i][j]</code> denote the <code>j</code>-th component
of row <code>M<sub>i</sub></code>, which is the <code>i</code>-th
component of <code>M</code>. This is
usually abbreviated as <code>M[i,j]</code>, and in the
same spirit the declaration
</p>

<code class='large'>M: ARRAY 10 OF ARRAY 4 OF REAL</code>

<p>can be written more concisely as</p>
<code class='large'>M: ARRAY 10, 4 OF REAL</code>

<p>If a certain operation has to be performed on all components of an
array or on adjacent components of a section of the array, then
this fact may conveniently be emphasized by using the
<code>FOR</code> satement, as shown in the following examples for
computing the sum and for finding the maximal element of an array
declared as</p>
<code class='large'>VAR a: ARRAY N OF INTEGER; <span>(* ADenS14 *)</span>

sum := 0;
FOR i := 0 TO N-1 DO sum := a[i] + sum END

k := 0; max := a[0];
FOR i := 1 TO N-1 DO
  IF max &lt; a[i] THEN k := i; max := a[k] END
END
</code>

<p>In a further example, assume that a fraction <code>f</code>
is represented in its decimal form with <code>k-1</code>
digits, i.e., by an array <code>d</code>
such that</p>
<code class='large'>f = <strong>S</strong>i: 0 ≤ i &lt; k: d<sub>i</sub> * 10<sup>-i</sup>
f = d<sub>0</sub></code> + 10*d<sub>1</sub> + 100*d<sub>2</sub> + … + 10<sup>k-1</sup>*d<sub>k-1</sub>
</code>

<p>Now assume that we wish to divide <code>f</code> by
<code>2</code>. This is done by repeating the familiar
division operation for all <code>k-1</code> digits
<code>d<sub>i</sub></code>, starting with
<code>i=1</code>. It consists of dividing each digit by
2 taking into account a possible carry from the previous position,
and of retaining a possible remainder <code>r</code> for
the next position:</p>
<code class='large'>r := 10*r +d[i]; d[i] := r DIV 2; r := r MOD 2</code>

<p>This algorithm is used to compute a table of
negative powers of 2. The repetition of halving to compute
<code>2<sup>-1</sup>, 2<sup>-2</sup>, ... , 2<sup>-N</sup></code>
is again appropriately expressed by a <code>FOR</code>
statement, thus leading to a nesting of two <code>FOR</code> statements.
</p>

<code class='large'>PROCEDURE Power (VAR W: Texts.Writer; N: INTEGER); <span>(* ADenS14 *)</span>
  (*compute decimal representation of negative powers of 2*)
  VAR i, k, r: INTEGER;
    d: ARRAY N OF INTEGER;
  BEGIN
    FOR k := 0 TO N-1 DO
      Texts.Write(W, "."); r := 0;
      FOR i := 0 TO k-1 DO
        r := 10*r + d[i]; d[i] := r DIV 2; r := r MOD 2;
        Texts.Write(W, CHR(d[i] + ORD("0")))
      END;
      d[k] := 5; Texts.Write(W, "5"); Texts.WriteLn(W)
    END
  END Power</code>

<p>The resulting output text for <code>N = 10</code> is</p>
<code class='large'>.5
.25
.125
.0625
.03125
.015625
.0078125
.00390625
.001953125
.0009765625
</code>

</li>

<li data-list-text="1.5" id="1.5">
<h3><a href='#1.5'>The Record Structure</a></h3>

<p>The most general method to obtain structured types is to join
elements of arbitrary types, that are possibly themselves
structured types, into a compound. Examples from mathematics are
complex numbers, composed of two real numbers, and coordinates of
points, composed of two or more numbers according to the
dimensionality of the space spanned by the coordinate system. An
example from data processing is describing people by a few relevant
characteristics, such as their first and last names, their date of
birth, sex, and marital status.</p>

<p>In mathematics such a compound type is the Cartesian product of its
constituent types. This stems from the fact that the set of values
defined by this compound type consists of all possible combinations
of values, taken one from each set defined by each constituent
type. Thus, the number of such combinations, also called
<code>n</code>-<i>tuples</i>,
is the product of the number of elements in each constituent set,
that is, the cardinality of the compound type is the product of the
cardinalities of the constituent types.</p>

<p>In data processing, composite types, such as descriptions of
persons or objects, usually occur in files or data banks and record
the relevant characteristics of a person or object. The word record
has therefore become widely accepted to describe a compound of data
of this nature, and we adopt this nomenclature in preference to the
term Cartesian product. In general, a record type <code>T</code>
with components of the types <code>T<sub>1</sub></code>,
<code>T<sub>2</sub></code>, ... , <code>T<sub>n</sub></code> is
defined as follows:</p>

<code class='large'>TYPE T = RECORD s<sub>1</sub>: T<sub>1</sub>; s<sub>2</sub>: T<sub>2</sub>; ... s<sub>n</sub>: T<sub>n</sub> END
card(T) = card(T<sub>1</sub>) * card(T<sub>2</sub>) * ... * card(T<sub>n</sub>)
</code>

<em>Examples</em>

<div class='table'><table>
  <tr><td><code>TYPE Complex = </code></td><td><code>RECORD</code></td><td><code>re, im: REAL END</code></td></tr>
  <tr><td><code>TYPE Date = </code></td><td><code>RECORD</code></td><td><code>day, month, year: INTEGER END</code></td></tr>
  <tr><td><code>TYPE Person = </code></td><td><code>RECORD</code></td><td><code>name, firstname: Name;
birthdate: Date;
male: BOOLEAN</code></td></tr>
  <tr><td></td><td><code>END</code></td></tr>
</table></div>

<p>We may visualize particular, record-structured values of, for example,the variables</p>
<code class='large'>z: Complex
d: Date
p: Person</code>
<p>as shown in Fig. 1.3.</p>

<div class='table'><table>
  <caption>Fig. 1.3. Records of type <code>Complex</code>, <code>Date</code> and <code>Person.</code></caption>

  <tr><td>Complex z</td><td>Date d</td><td>Person p</td></tr>
  <tr>
    <td><div class='table'><table>
      <tr><td>1.0</td></tr>
      <tr><td>-1.0</td></tr>
    </table></div></td>

    <td><div class='table'><table>
      <tr><td>1</td></tr>
      <tr><td>4</td></tr>
      <tr><td>1973</td></tr>
    </table></div></td>

    <td><div class='table'><table>
      <tr><td colspan="3">SMITH</td></tr>
      <tr><td colspan="3">JOHN</td></tr>
      <tr><td>18</td><td>1</td><td>1986</td></tr>
      <tr><td colspan="3">TRUE</td></tr>
    </table></div></td>
  </tr>
</table></div>

<p>The identifiers <code>s<sub>1</sub></code>,
<code>s<sub>2</sub></code>, ... , <code>s<sub>n</sub></code>
introduced by a record type definition are the names
given to the individual components of variables of that type. As
components of records are called <i>fields</i>, the names are
<i>field identifiers</i>. They are used in record selectors applied
to record structured variables. Given a variable <code>x: T</code>,
its <code>i</code>-th field is denoted
by <code>x.s<sub>i</sub></code>. Selective
updating of <code>x</code> is achieved by using the same
selector denotation on the left side in an assignment
statement:</p>
<code>x.s<sub>i</sub> := e</code>
<p>where <code>e</code> is a value (expression) of type
<code>T<sub>i</sub></code>. Given, for
example, the record variables <code>z</code>,
<code>d</code>, and <code>p</code> declared
above, the following are selectors of components:</p>

<div class='table'><table>
  <tr><td><code>z.im</code></td><td>(of type <code>REAL</code>)</td></tr>
  <tr><td><code>d.month</code></td><td>(of type <code>INTEGER</code>)</td></tr>
  <tr><td><code>p.name</code></td><td>(of type <code>Name</code>)</td></tr>
  <tr><td><code>p.birthdate</code></td><td>(of type <code>Date</code>)</td></tr>
  <tr><td><code>p.birthdate.day</code></td><td>(of type <code>INTEGER</code>)</td></tr>
  <tr><td><code>p.mail</code></td><td>(of type <code>BOOLEAN</code>)</td></tr>
</table></div>

<p>The example of the type <code>Person</code> shows that a
constituent of a record type may itself be structured. Thus,
selectors may be concatenated. Naturally, different structuring
types may also be used in a nested fashion. For example, the
<code>i</code>-th component of an array <code>a</code> being a component of a record variable <code>r</code> is denoted by <code>r.a[i]</code>, and the
component with the selector name <code>s</code> of the
<code>i</code>-th record structured component of the
array <code>a</code> is denoted by <code>a[i].s</code>.
</p>

<p>It is a characteristic of the Cartesian product that it contains
all combinations of elements of the constituent types. But it must
be noted that in practical applications not all of them may be
meaningful. For instance, the type <code>Date</code> as
defined above includes the 31st April as well as the 29th February
1985, which are both dates that never occurred. Thus, the
definition of this type does not mirror the actual situation
entirely correctly; but it is close enough for practical purposes,
and it is the responsibility of the programmer to ensure that
meaningless values never occur during the execution of a
program.
</p>

<p>The following short excerpt from a program shows the use of record
variables. Its purpose is to count the number of persons
represented by the array variable family that are both female and
born after the year 2000:
</p>
<code class='large'>  VAR count: INTEGER;
    family: ARRAY N OF Person;

  count := 0;
  FOR i := 0 TO N-1 DO
    IF ~family[i].male &amp; (family[i].birthdate.year &gt; 2000) THEN INC(count) END
  END</code>

<p>The record structure and the array structure have the common
property that both are <i>random-access</i> structures. The record
is more general in the sense that there is no requirement that all
constituent types must be identical. In turn, the array offers
greater flexibility by allowing its component selectors to be
computable values (expressions), whereas the selectors of record
components are field identifiers declared in the record type
definition.</p>

</li>

<li data-list-text="1.6" id="1.6">
<h3><a href='#1.6'>Representation Of Arrays, Records, And Sets</a></h3>

<p>The essence of the use of abstractions in programming is that a
program may be conceived, understood, and verified on the basis of
the laws governing the abstractions, and that it is not necessary
to have further insight and knowledge about the ways in which the
abstractions are implemented and represented in a particular
computer. Nevertheless, it is essential for a professional
programmer to have an understanding of widely used techniques for
representing the basic concepts of programming abstractions, such
as the fundamental data structures. It is helpful insofar as it
might enable the programmer to make sensible decisions about
program and data design in the light not only of the abstract
properties of structures, but also of their realizations on actual
computers, taking into account a computer's particular capabilities
and limitations.</p>

<p>The problem of data representation is that of mapping the abstract
structure onto a computer store. Computer stores are — in a first
approximation — arrays of individual storage cells called
<i>bytes</i>. They are understood to be groups of 8 bits. The
indices of the bytes are called <i>addresses</i>.</p>
<code>VAR store: ARRAY StoreSize OF BYTE</code>

<p>The basic types are represented by a small number of bytes,
typically 2, 4, or 8. Computers are designed to transfer internally
such small numbers (possibly 1) of contiguous bytes concurrently,
"in parallel". The unit transferable concurrently is called a
<i>word</i>.</p>

<ol class="page" id="l25">
<li data-list-text="1.6.1" id="1.6.1">
<h4><a href='#1.6.1'>Representation of Arrays</a></h4>
<p>A representation of an array structure is a mapping of the
(abstract) array with components of type <code>T</code>
onto the store which is an array with components of type
<code>BYTE</code>. The array should be mapped in such a
way that the computation of addresses of array components is as
simple (and therefore as efficient) as possible. The address
<code>i</code> of the <code>j</code>-th array
component is computed by the linear mapping function</p>
<code>i = i<sub>0</sub> + j*s</code>,
<p>where <code>i<sub>0</sub></code>
is the address of the first component, and <code>s</code>
is the number of words that a component occupies.
Assuming that the word is the smallest individually transferable
unit of store, it is evidently highly desirable that <code>s</code>
be a whole number, the simplest case being <code>s= 1</code>.
If <code>s</code> is not a whole
number (and this is the normal case), then
<code>s</code> is usually rounded up to the
next larger integer <code>S</code>. Each array component
then occupies <code>S</code> words, whereby <code>S-s</code>
words are left unused (see Figs. 1.4 and 1.5).
Rounding up of the number of words needed to the next whole number
is called <i>padding</i>. The storage utilization factor
<code>u</code> is the quotient of the minimal amounts of
storage needed to represent a structure and of the amount actually
used:</p>
<code>u = s / </code> (<code>s</code> rounded up to nearest integer)

<br/><br/>

<img src="fig/1.4.png" width="350"/>
<p>Fig. 1.4. Mapping an array onto a store</p>

<p></p>
<img alt="s=2.3 S=3 unused" src="fig/1.5.png" width="350"/>

<p>Fig. 1.5. Padded representation of a record</p>

<p>Since an implementor has to aim for a storage utilization as close
to 1 as possible, and since accessing parts of words is a
cumbersome and relatively inefficient process, he or she must
compromise. The following considerations are relevant:</p>

<ol id="l26">
<li data-list-text="1.">Padding decreases storage utilization.</li>
<li data-list-text="2.">Omission of padding may necessitate inefficient partial word access.</li>
<li data-list-text="3.">
Partial word access may cause the code (compiled program) to expand
and therefore to counteract the gain obtained by omission of
padding.
</li>
</ol>

<p>In fact, considerations 2 and 3 are usually so dominant that
compilers always use padding automatically. We notice that the
utilization factor is always <code>u &gt; 0.5</code>, if
<code>s &gt; 0.5</code>. However, if <code>s ≤ 0.5</code>,
the utilization factor may be significantly
increased by putting more than one array component into each word.
This technique is called <i>packing</i>. If <code>n</code>
components are packed into a word, the utilization
factor is (see Fig. 1.6)</p>

<p><code>u = n*s / </code>(<code>n*s</code> rounded up to nearest integer)</p>


<img alt="padded" src="fig/1.6.png" width="500"/>

<p>Fig.1.6. Packing 6 components into one word</p>

<p>Access to the <code>i</code>-th component of a packed
array involves the computation of the word address
<code>j</code> in which the desired component is located, and it
involves the computation of the respective component position
<code>k</code> within the word.
</p>
<code>j = i DIV n   k = i MOD n</code>

<p>In most programming languages the programmer is given no control
over the representation of the abstract data structures.
However, it should be possible to indicate the
desirability of packing at least in those cases in which more than
one component would fit into a single word, i.e., when a gain of
storage economy by a factor of 2 and more could be achieved. We
propose the convention to indicate the desirability of packing by
prefixing the symbol <code>ARRAY</code> (or <code>RECORD</code>)
in the declaration by the symbol <code>PACKED</code>.
</p>

</li>

<li data-list-text="1.6.2" id="1.6.2">
<h4><a href='#1.6.2'>Representation of Records</a></h4>

<p>Records are mapped onto a computer store by simply juxtaposing
their components. The address of a component (field)
<code>r<sub>i</sub></code> relative to the origin
address of the record <code>r</code> is called the
field's <i>offset</i> <code>k<sub>i</sub></code>. It is computed as</p>
<code>k<sub>i</sub> = s<sub>1</sub> + s<sub>2</sub> + ... + s<sub>i-1</sub>   k<sub>0</sub> = 0</code>
<p>where <code>s<sub>j</sub></code>
is the size (in words) of the <code>j</code>-th
component. We now realize that the fact that all components
of an array are of equal type has the welcome consequence
that <code>k<sub>i</sub> = i × s</code>. The generality of the record
structure does unfortunately not allow such a simple, linear
function for offset address computation, and it is therefore the
very reason for the requirement that record components be
selectable only by fixed identifiers. This restriction has the
desirable benefit that the respective offsets are known at compile
time. The resulting greater efficiency of record field access is
well-known.
</p>

<p>The technique of packing may be beneficial, if several record
components can be fitted into a single storage word (see Fig. 1.7).
Since offsets are computable by the compiler, the offset of a field
packed within a word may also be determined by the compiler. This
means that on many computers packing of records causes a
deterioration in access efficiency considerably smaller than that
caused by the packing of arrays.
</p>

<img alt="padded" src="fig/1.7.png"/>
<p>Fig. 1.7. Representation of a packed record</p>

</li>

<li data-list-text="1.6.3" id="1.6.3">
<h4><a href='#1.6.3'>Representation of Sets</a></h4>

<p>A set <code>s</code> is conveniently represented in a
computer store by its characteristic function <code>C(s)</code>.
This is an array of logical values whose ith
component has the meaning "<code>i</code> is present in
<code>s</code>". As an example, the set of small
integers <code>s = {2, 3, 5, 7, 11, 13}</code> is
represented by the sequence of bits, by a bitstring:</p>
<code>C(s) = (… 0010100010101100)</code>

<p>The representation of sets by their characteristic function has the
advantage that the operations of computing the union, intersection,
and difference of two sets may be implemented as elementary logical
operations. The following equivalences, which hold for all elements
<code>i</code> of the base type of the sets <code>x</code> and <code>y</code>, relate logical
operations with operations on sets:</p>
<code class='large'>i IN (x+y) = (i IN x) OR (i IN y)
i IN (x*y) = (i IN x) &amp; (i IN y)
i IN (x-y) = (i IN x) &amp; ~(i IN y)</code>

<p>These logical operations are available on all
digital computers, and moreover they operate concurrently on all
corresponding elements (bits) of a word. It therefore appears that
in order to be able to implement the basic set operations in an
efficient manner, sets must be represented in a small, fixed number
of words upon which not only the basic logical operations, but also
those of shifting are available. Testing for membership is then
implemented by a single shift and a subsequent (sign) bit test
operation. As a consequence, a test of the form
<code>x IN {c<sub>1</sub>, c<sub>2</sub>, ... , c<sub>n</sub>}</code>
can be implemented considerably more efficiently than the equivalent
Boolean expression</p>
<code>(x = c<sub>1</sub>) OR (x = c<sub>2</sub>) OR ... OR (x = c<sub>n</sub>)</code>

<p>A corollary is that the set structure should be used only for small
integers as elements, the largest one being the wordlength of the
underlying computer (minus 1).</p>

</li>
</ol>
</li>

<li data-list-text="1.7" id="1.7">
<h3><a href='#1.7'>The File (Sequence)</a></h3>

<p>Another elementary structuring method is the sequence. A sequence
is typically a homogeneous structure like the array. That is, all
its elements are of the same type, the <i>base type</i> of the
sequence. We shall denote a sequence <code>s</code> with
<code>n</code> elements by</p>
<code>s = &lt;s<sub>0</sub>, s<sub>1</sub>, s<sub>2</sub>, ... , s<sub>n-1</sub>&gt;</code>
<p><code>n</code> is called the <i>length</i> of the
sequence. This structure looks exactly like the array. The
essential difference is that in the case of the array the number of
elements is fixed by the array's declaration, whereas for the
sequence it is left open. This implies that it may vary during
execution of the program. Although every sequence has at any time a
specific, finite length, we must consider the cardinality of a
sequence type as infinite, because there is no fixed limit to the
potential length of sequence variables.
</p>

<p>A direct consequence of the variable length of sequences is the
impossibility to allocate a fixed amount of storage to sequence
variables. Instead, storage has to be allocated during program
execution, namely whenever the sequence grows. Perhaps storage can
be reclaimed when the sequence shrinks. In any case, a dynamic
storage allocation scheme must be employed. All structures with
variable size share this property, which is so essential that we
classify them as advanced structures in contrast to the fundamental
structures discussed so far.
</p>

<p>What, then, causes us to place the discussion of sequences in this
chapter on fundamental structures? The primary reason is that the
storage management strategy is sufficiently simple for sequences
(in contrast to other advanced structures), if we enforce a certain
discipline in the use of sequences. In fact, under this proviso the
handling of storage can safely be delegated to a machanism that can
be guaranteed to be reasonably effective. The secondary reason is
that sequences are indeed ubiquitous in all computer applications.
This structure is prevalent in all cases where different kinds of
storage media are involved, i.e. where data are to be moved from
one medium to another, such as from disk or tape to primary store
or vice-versa.
</p>

<p>The discipline mentioned is the restraint to use sequential access
only. By this we mean that a sequence is inspected by strictly
proceeding from one element to its immediate successor, and that it
is generated by repeatedly appending an element at its end. The
immediate consequence is that elements are <i>not directly
accessible</i>, with the exception of the one element which
currently is up for inspection. It is this accessing discipline
which fundamentally distinguishes sequences from arrays. As we
shall see in Chapter 2, the influence of an access discipline on
programs is profound.
</p>

<p>The advantage of adhering to sequential access which, after all, is
a serious restriction, is the relative simplicity of needed storage
management. But even more important is the possibility to use
effective buffering techniques when moving data to or from
secondary storage devices. Sequential access allows us to feed
streams of data through pipes between the different media.
Buffering implies the collection of sections of a stream in a
buffer, and the subsequent shipment of the whole buffer content
once the buffer is filled. This results in very significantly more effective use of
secondary storage. Given sequential access only, the buffering
mechanism is reasonably straightforward for all sequences and all
media. It can therefore safely be built into a system for general
use, and the programmer need not be burdened by incorporating it in
the program. Such a system is usually called a <i>file system</i>,
because the high-volume, sequential access devices are used for
permanent storage of (persistent) data, and they retain them even
when the computer is switched off. The unit of data on these media
is commonly called (<i>sequential</i>) <i>file</i>. Here we will
use the term <i>file</i> as synonym to <i>sequence</i>.
</p>

<p>There exist certain storage media in which the sequential access is
indeed the only possible one. Among them are evidently all kinds of
tapes. But even on magnetic disks each recording track constitutes
a storage facility allowing only sequential access. Strictly
sequential access is the primary characteristic of every
mechanically moving device and of some other ones as well.
</p>

<p>It follows that it is appropriate to distinguish between the
<i>data structure</i>, the sequence, on one hand, and the
<i>mechanism to access elements</i> on the other hand. The former
is declared as a data structure, the latter typically by the
introduction of a record with associated operators, or, according
to more modern terminology, by a rider object. The distinction
between data and mechanism declarations is also useful in view of
the fact that several access points may exist concurrently on one
and the same sequence, each one representing a sequential access at
a (possibly) different location.
</p>

<p>We summarize the essence of the foregoing as follows:</p>

<ol class="noindent" id="l27">
<li data-list-text="1.">
<p>Arrays and records are random access structures. They are used when
located in primary, random-access store.</p>
</li>
<li data-list-text="2.">
<p>Sequences are used to access data on secondary, sequential-access
stores, such as disks and tapes.</p>
</li>
<li data-list-text="3.">
<p>We distinguish between the declaration of a sequence variable, and
that of an access mechanism located at a certain position within
the seqence.</p>
</li>
</ol>

<ol class="page" id="l28">
  
<li data-list-text="1.7.1" id="1.7.1">
<h4><a href='#1.7.1'>Elementary File Operators</a></h4>

<p>The discipline of sequential access can be enforced by providing a
set of seqencing operators through which files can be accessed
exclusively. Hence, although we may here refer to the
<code>i</code>-th element of a sequence <code>s</code> by
writing <code>s<sub>i</sub></code>, this
shall not be possible in a program.</p>

<p>Sequences, files, are typically large, dynamic data structures
stored on a secondary storage device. Such a device retains the
data even if a program is terminated, or a computer is switched
off. Therefore the introduction of a file variable is a complex
operation connecting the data on the external device with the file
variable in the program. We therefore define the type <i>File</i>
in a separate module, whose definition specifies the type together
with its operators. We call this module <i>Files</i> and postulate
that a sequence or file variable must be explicitly initialized
(opened) by calling an appropriate operator or function:</p>
<code class='large'>VAR f: File
f := Open(name)</code>
<p>where <code>name</code> identifies the file as recorded
on the persistent data carrier. Some systems distinguish between
opening an existing file and opening a new file:</p>
<code>f := Old(name)    f := New(name)</code>
<p>The disconnection between secondary storage and the file variable
then must also be explicitly requested by, for example, a call of
<code>Close(f)</code>.
</p>

<p>Evidently, the set of operators must contain an operator for
generating (writing) and one for inspecting (reading) a sequence.
We postulate that these operations apply not to a file directly,
but to an object called a <i>rider</i>, which itself is connected
with a file (sequence), and which implements a certain access
mechanism. The sequential access discipline is guaranteed by a
restrictive set of access operators (procedures).
</p>

<p>A sequence is generated by appending elements at its end after
having placed a rider on the file.
</p>
<p>Assuming the declaration</p>
<code>VAR r: Rider</code>
<p>we position the rider <code>r</code> on the file
<code>f</code> by the statement</p>
<code>Set(r, f, pos)</code>

<p>where <code>pos = 0</code> designates the beginning of
the file (sequence). A typical pattern for generating the sequence
is:</p>
<code class='large'>WHILE <i>more</i> DO <i>compute next element</i> x; Write(r, x) END</code>

<p>A sequence is inspected by first positioning a rider as shown
above, and then proceeding from element to element. A typical
pattern for reading a sequence is:</p>
<code class='large'>Read(r, x);
WHILE ~r.eof DO <i>process element</i> x; Read(r, x) END</code>

<p>Evidently, a certain position is always associated with every
rider. It is denoted by <code>r.pos</code>. Furthermore,
we postulate that a rider contain a predicate (flag)
<code>r.eof</code> indicating whether a preceding read operation had
reached the sequence's end. We can now postulate and describe
informally the following set of primitive operators:
</p>
<div class='table'><table>
  <tr><td>1a.</td><td><code>New(f, name)</code></td><td>defines <code>f</code> to be the empty sequence</td></tr>
  <tr><td>1b.</td><td><code>Old(f, name)</code></td><td>defines <code>f</code> to be the sequence persistently stored with given name.</td></tr>
  <tr><td>2.</td><td><code>Set(r, f, pos)</code></td><td>associate rider <code>r</code> with sequence <code>f</code>, and place it at position <code>pos</code>.</td></tr>
  <tr><td>3.</td><td><code>Write(r, x)</code></td><td>place element with value <code>x</code> in the sequence designated by rider <code>r</code>, and advance.</td></tr>
  <tr><td>4.</td><td><code>Read(r, x)</code></td><td>assign to <code>x</code> the value of the element designated by rider <code>r</code>, and advance.</td></tr>
  <tr><td>5.</td><td><code>Close(f)</code></td><td>registers the written file <code>f</code>in the persistent store (flush buffers).</td></tr>
</table></div>

<p><span class="note">Note</span>. Writing an element in a sequence is often a
complex operation. However, mostly, files are created by appending
elements at the end.
</p>

<p><span class="note">Translator's note</span>. The program examples in the book
use two more commands:
</p>

<div class='table'><table>
  <tr><td>6.</td><td><code>WriteInt(r, n)</code></td><td>place the integer <code>n</code> in the sequence designated by rider <code>r</code>, and advance.</td></tr>
  <tr><td>7.</td><td><code>ReadInt(r, n)</code></td><td>assign to <code>n</code> the integer value designated by rider <code>r</code>, and advance.</td></tr>
</table></div>

<p>In order to convey a more precise understanding of the sequencing
operators, the following example of an implementation is provided.
It shows how they might be expressed if sequences were represented
by arrays. This example of an implementation intentionally builds
upon concepts introduced and discussed earlier, and it does not
involve either buffering or sequential stores which, as mentioned
above, make the sequence concept truly necessary and attractive.
Nevertheless, this example exhibits all the essential
characteristics of the primitive sequence operators, independently
of how the sequences are represented in store.</p>

<p>The operators are presented in terms of conventional procedures.
This collection of definitions of types, variables, and procedure
headings (signatures) is called a <i>definition</i>. We assume that
we are to deal with sequences of characters, i.e. text files whose
elements are of type <code>CHAR</code>. The declarations
of <code>File</code> and <code>Rider</code>
are good examples of an application of record structures because,
in addition to the field denoting the array which represents the
data, further fields are required to denote the current length and
position, i.e. the state of the rider.</p>

<code class='large'>DEFINITION Files; <span >(* ADenS171_Files *)</span>
  TYPE File; (*sequence of characters*)
    Rider = RECORD eof: BOOLEAN END;

  PROCEDURE New(VAR name: ARRAY OF CHAR): File;
  PROCEDURE Old(VAR name: ARRAY OF CHAR): File;
  PROCEDURE Close(VAR f: File);

  PROCEDURE Set(VAR r: Rider; VAR f: File; pos: INTEGER);
  PROCEDURE Write(VAR r: Rider; ch: CHAR);
  PROCEDURE Read(VAR r: Rider; VAR ch: CHAR);

  PROCEDURE WriteInt(VAR r: Rider; n: INTEGER);
  PROCEDURE ReadInt(VAR r: Rider; VAR n: INTEGER);
END Files.</code>

<p>A <i>definition</i> represents an abstraction. Here we are given
the two data types, <code>File</code> and <code>Rider</code>,
together with their operations, but without
further details revealing their actual representation in store. Of
the operators, declared as procedures, we see their headings only.
This hiding of the details of implementation is intentional. The
concept is called <i>information hiding</i>. About riders we only
learn that there is a property called <code>eof</code>.
This flag is set, if a read operation reaches the end of the file.
The rider's position is invisible, and hence the rider's invariant
cannot be falsified by direct access. The invariant expresses the
fact that the position always lies within the limits given by the
associated sequence. The invariant is established by procedure
<code>Set</code>, and required and maintained by
procedures <code>Read</code> and <code>Write</code> (also <code>ReadInt</code> and
<code>WriteInt</code>).</p>

<p>The statements that implement the procedures and further, internal
details of the data types, are sepecified in a construct called
<i>module</i>. Many representations of data and implementations of
procedures are possible. We chose the following as a simple example
(with fixed maximal file length):</p>

<code class='large'>
MODULE Files; <span >(* ADenS171_Files *)</span>
  CONST MaxLength = 4096;

  TYPE <strong>File</strong> = POINTER TO RECORD
      len: INTEGER;
      a: ARRAY MaxLength OF CHAR
    END;

    <strong>Rider</strong> = RECORD (* 0 &lt;= pos &lt;= f.len &lt;= Max Length *)
      f: File; pos: INTEGER; eof: BOOLEAN
    END;

  PROCEDURE <strong>New</strong> (name: ARRAY OF CHAR): File;
    VAR f: File;
  BEGIN NEW(f); f.len := 0; f.eof := FALSE; (*directory operation omitted*)
    RETURN f
  END New;

  PROCEDURE <strong>Old</strong> (name: ARRAY OF CHAR): File;
  VAR f: File;
  BEGIN NEW(f); f.eof := FALSE; (*directory lookup omitted*)
    RETURN f
  END Old;

  PROCEDURE <strong>Close</strong> (VAR f: File);
  BEGIN
  END Close;

  PROCEDURE <strong>Set</strong> (VAR r: Rider; f: File; pos: INTEGER);
  BEGIN (*assume f # NIL*) r.f := f; r.eof := FALSE;
    IF pos &gt;= 0 THEN
      IF pos &lt;= f.len THEN r.pos := pos ELSE r.pos := f.len END
    ELSE
      r.pos := 0
    END
  END Set;

  PROCEDURE <strong>Write</strong> (VAR r: Rider; ch: CHAR);
  BEGIN
    IF (r.pos &lt;= r.s.len) &amp; (r.pos &lt; MaxLength) THEN
      r.f.a[r.pos] := ch; INC(r.pos);
      IF r.pos &gt; r.f.len THEN INC(r.f.len) END
    ELSE
      r.eof := TRUE
    END
  END Write;

  PROCEDURE <strong>Read</strong> (VAR r: Rider; VAR ch: CHAR);
  BEGIN
    IF r.pos &lt; r.f.len THEN
      ch := r.f.a[r.pos]; INC(r.pos)
    ELSE
      r.eof := TRUE
    END
  END Read;

  PROCEDURE <strong>WriteInt</strong> (VAR r: Rider; n: INTEGER);
  BEGIN (*implementation is platform dependent*)
  END WriteInt;

  PROCEDURE <strong>ReadInt</strong> (VAR r: Rider; VAR n: INTEGER);
  BEGIN (*implementation is platform dependent*)
  END ReadInt;

END Files.</code>

<p>Note that in this example the maximum length that sequences may
reach is an arbitrary constant. Should a program cause a sequence
to become longer, then this would not be a mistake of the program,
but an inadequacy of this implementation. On the other hand, a read
operation proceeding beyond the current end of the sequence would
indeed be the program's mistake. Here, the flag <code>r.eof</code>
is also used by the write operation to indicate
that it was not possible to perform it. Hence,
<code>~r.eof</code> is a precondition for both
<code>Read</code> and <code>Write</code>.</p>
</li>

<li data-list-text="1.7.2" id="1.7.2">
<h4><a href='#1.7.2'>Buffering Sequences</a></h4>

<p>When data are transferred to or from a secondary storage device,
the individual bits are transferred as a stream. Usually, a device
imposes strict timing constraints upon the transmission. For
example, if data are written on a tape, the tape moves at a fixed
speed and requires the data to be fed at a fixed rate. When the
source ceases, the tape movement is switched off and speed
decreases quickly, but not instantaneously. Thus a gap is left
between the data transmitted and the data to follow at a later
time. In order to achieve a high density of data, the number of
gaps ought to be kept small, and therefore data are transmitted
in relatively large blocks once the tape is moving. Similar conditions
hold for magnetic disks, where the data are allocated on tracks
with a fixed number of blocks of fixed size, the so-called block
size. In fact, a disk should be regarded as an array of blocks,
each block being read or written as a whole, containing typically
<code>2<sup>k</sup></code> bytes with
<code>k = 8, 9, … 12</code>.</p>
<p>Our programs, however, do not observe any such timing constraints.
In order to allow them to ignore the constraints, the data to be
transferred are buffered. They are collected in a buffer variable
(in main store) and transferred when a sufficient amount of data is
accumulated to form a block of the required size. The buffer's
client has access only via the two procedures
<code>deposit</code> and <code>fetch</code>:</p>
<code class='large'>DEFINITION Buffer;
  PROCEDURE deposit (x: CHAR);
  PROCEDURE fetch (VAR x: CHAR);
END Buffer.</code>

<p>Buffering has an additional advantage in allowing the process which
generates (receives) data to proceed concurrently with the device
that writes (reads) the data from (to) the buffer. In fact, it is
convenient to regard the device as a process itself which merely
copies data streams. The buffer's purpose is to provide a certain
degree of decoupling between the two processes, which we shall call
the <i>producer</i> and the <i>consumer</i>. If, for example, the
consumer is slow at a certain moment, it may catch up with the
producer later on. This decoupling is often essential for a good
utilization of peripheral devices, but it has only an effect, if
the rates of producer and consumer are about the same on the
average, but fluctuate at times. The degree of decoupling grows
with increasing buffer size.</p>

<p>We now turn to the question of how to represent a buffer, and shall
for the time being assume that data elements are deposited and
fetched individually instead of in blocks. A buffer essentially
constitutes a first-in-first-out queue (fifo). If it is declared as
an array, two index variables, say <code>in</code> and
<code>out</code>, mark the positions of the next
location to be written into and to be read from. Ideally, such an
array should have no index bounds. A finite array is quite
adequate, however, considering the fact that elements once fetched
are no longer relevant. Their location may well be re-used. This
leads to the idea of the <i>circular buffer</i>.</p>

<img alt="in out" src="fig/1.8.png" width="300"/>

<p>Fig. 1.8. Circular buffer with indices <code>in</code>
and <code>out</code>.</p>

<p>The operations of depositing and fetching an
element are expressed in the following module, which exports these
operations as procedures, but hides the buffer and its index
variables — and thereby effectively the buffering mechanism — from
the client processes. This mechanism also involves a
variable <code>n</code> counting the number of elements
currently in the buffer. If <code>N</code> denotes the
size of the buffer, the condition <code>0 ≤ n ≤ N</code>.
Therefore, the operation <code>fetch</code> must be
guarded by the condition <code>n &lt; 0</code>
(buffer non-empty), and the operation
<code>deposit</code> by the condition <code>n &lt; N</code>
(buffer non-full). Not meeting the
former condition must be regarded as a programming error, a
violation of the latter as a failure of the suggested
implementation (buffer too small).</p>

<code class='large'>MODULE Buffer; (*implements circular buffers*)
  CONST N = 1024; (*buffer size*)
  VAR n, in, out: INTEGER;
    buf: ARRAY N OF CHAR;

  PROCEDURE <strong>deposit</strong> (x: CHAR);
  BEGIN
    IF n = N THEN HALT END;
    INC(n); buf[in] := x; in := (in + 1) MOD N
  END deposit;

  PROCEDURE <strong>fetch</strong> (VAR x: CHAR);
  BEGIN
    IF n = 0 THEN HALT END;
    DEC(n); x := buf[out]; out := (out + 1) MOD N
  END fetch;

BEGIN n := 0; in := 0; out := 0
END Buffer.</code>

<p>This simple implementation of a buffer is acceptable only, if the
procedures <code>deposit</code> and <code>fetch</code>
are activated by a single agent (once acting as a
producer, once as a consumer). If, however, they are activated by
individual, concurrent processes, this scheme is too simplistic.
The reason is that the attempt to deposit into a full buffer, or
the attempt to fetch from an empty buffer, are quite legitimate.
The execution of these actions will merely have to be delayed until
the guarding conditions are established. Such delays essentially
constitute the necessary synchronization among concurrent
processes. We may represent these delays respectively by the
statements</p>

<code class='large'>REPEAT UNTIL n &lt; N
REPEAT UNTIL n &gt; 0</code>

<p>which must be substituted for the two conditioned <code>HALT</code> statements.</p>
</li>

<li data-list-text="1.7.3" id="1.7.3">
<h4><a href='#1.7.3'>Buffering between Concurrent Processes</a></h4>

<p>The presented solution is, however, not recommended, even if it is
known that the two processes are driven by two individual engines.
The reason is that the two processors necessarily access the same
variable n, and therefore the same store. The idling process, by
constantly polling the value <code>n</code>, and
therefore the same store. The idling process, by constantly polling
the value <code>n</code>, hinders its partner, because
at no time can the store be accessed by more than one process. This
kind of busy waiting must indeed be avoided, and we therefore
postulate a facility that makes the details of synchronization less
explicit, in fact hides them. We shall call this facility a
<i>signal</i>, and assume that it is available from a utility
module <code>Signals</code> together with a set of
primitive operators on signals.</p>

<p>Every signal <code>s</code> is associated with a guard
(condition) <code>P<sub>s</sub></code>. If
a process needs to be delayed until <code>P<sub>s</sub></code>
is established (by some other process), it must, before proceeding,
wait for the signal <code>s</code>. This is to be expressed by the statement
<code>Wait(s)</code>. If, on the other hand, a process
establishes <code>P<sub>s</sub></code>, it
thereupon signals this fact by the statement <code>Send(s)</code>.
If <code>P<sub>s</sub></code> is the established precondition to
every statement <code>Send(s)</code>, then <code>P<sub>s</sub></code>
can be regarded as a postcondition of <code>Wait(s)</code>.</p>

<code class='large'>DEFINITION Signals;
  TYPE Signal;
  PROCEDURE Wait (VAR s: Signal);
  PROCEDURE Send (VAR s: Signal);
  PROCEDURE Init (VAR s: Signal);
END Signals.</code>

<p>We are now able to express the buffer module in a form that
functions properly when used by individual, concurrent
processes:</p>

<code class='large'>MODULE Buffer;
  IMPORT Signals;
  CONST N = 1024; (*buffer size*)
  VAR n, in, out: INTEGER;
    nonfull: Signals.Signal; (*n &lt; N*)
    nonempty: Signals.Signal; (*n &gt; 0*)
    buf: ARRAY N OF CHAR;

  PROCEDURE <strong>deposit</strong> (x: CHAR);
  BEGIN
    IF n = N THEN Signals.Wait(nonfull) END;
    INC(n); buf[in] := x; in := (in + 1) MOD N;
    IF n = 1 THEN Signals.Send(nonempty) END
  END deposit;

  PROCEDURE <strong>fetch</strong> (VAR x: CHAR);
  BEGIN
    IF n = 0 THEN Signals.Wait(nonempty) END;
    DEC(n); x := buf[out]; out := (out + 1) MOD N;
    IF n = N-1 THEN Signals.Send(nonfull) END
  END fetch;

BEGIN n := 0; in := 0; out := 0; Signals.Init(nonfull); Signals.Init(nonempty)
END Buffer.</code>

<p>An additional caveat must be made, however. The scheme fails
miserably, if by coincidence both consumer and producer (or two
producers or two consumers) fetch the counter value
<code>n</code> simultaneously for updating. Unpredictably, its
resulting value will be either <code>n+1</code>, or
<code>n-1</code>, but not <code>n</code>. It
is indeed necessary to protect the processes from dangerous
interference. In general, all operations that alter the values of
shared variables constitute potential pitfalls.</p>

<p>A sufficient (but not always necessary) condition is that all
shared variables be declared local to a module whose procedures are
guaranteed to be executed under <i>mutual exclusion</i>. Such a
module is called a <i>monitor</i> [1-7]. The mutual exclusion
provision guarantees that at any time at most one process is
actively engaged in executing a procedure of the monitor. Should
another process be calling a procedure of the (same) monitor, it
will automatically be delayed until the first process has
terminated its procedure.</p>

<p><em>Note</em>. By actively engaged is meant that a process
execute a statement other than a wait statement.</p>

<p>At last we return now to the problem where the producer or the
consumer (or both) require the data to be available in a certain
block size. The following module is a variant of the one previously
shown, assuming a block size of <code>N<sub>p</sub></code> data elements for the
producer, and of <code>N<sub>c</sub></code> elements for the consumer. In these cases, the
buffer size <code>N</code> is usually chosen as a common
multiple of <code>N<sub>p</sub></code> and
<code>N<sub>c</sub></code>. In order to
emphasise that symmetry between the operations of fetching and
depositing data, the single counter <code>n</code> is
now represented by two counters, namely <code>ne</code>
and <code>nf</code>. They specify the numbers of empty
and filled buffer slots respectively. When the consumer is idle,
<code>nf</code> indicates the number of elements needed
for the consumer to proceed; and when the producer is waiting,
<code>ne</code> specifies the number of elements needed
for the producer to resume. (Therefore <code>ne + nf = N</code>
 does not always hold.)</p>

<code class='large'>MODULE Buffer;
  IMPORT Signals;
  CONST Np = 16; (*size of producer block*)
    Nc = 128; (*size of consumer block*)
    N = 1024; (*buffer size, common multiple of Np and Nc*)
  VAR ne, nf: INTEGER;
    in, out: INTEGER;
    nonfull: Signals.Signal; (*ne >= 0*)
    nonempty: Signals.Signal; (*nf >= 0*)
    buf: ARRAY N OF CHAR;

  PROCEDURE <strong>deposit</strong> (VAR x: ARRAY OF CHAR);
  BEGIN
    ne := ne - Np;
    IF ne &lt; 0 THEN Signals.Wait(nonfull) END;
    FOR i := 0 TO Np-1 DO buf[in] := x[i]; INC(in) END;
    IF in = N THEN in := 0 END;
    nf := nf + Np;
    IF nf >= 0 THEN Signals.Send(nonempty) END
  END deposit;

  PROCEDURE <strong>fetch</strong> (VAR x: ARRAY OF CHAR);
  BEGIN
    nf := nf - Nc;
    IF nf &lt; 0 THEN Signals.Wait(nonempty) END;
    FOR i := 0 TO Nc-1 DO x[i] := buf[out]; INC(out) END;
    IF out = N THEN out := 0 END;
    ne := ne + Nc;
    IF ne >= 0 THEN Signals.Send(nonfull) END
  END fetch;

BEGIN
  ne := N; nf := 0; in := 0; out := 0;
  Signals.Init(nonfull); Signals.Init(nonempty)
END Buffer.</code>

</li>

<li data-list-text="1.7.4" id="1.7.4">
<h4><a href='#1.7.4'>Textual Input and Output</a></h4>

<p>By standard input and output we understand the transfer of data to
(from) a computer system from (to) genuinely external agents, in
particular its human operator. Input may typically originate at a
keyboard and output may sink into a display screen. In any case,
its characteristic is that it is readable, and it typically
consists of a sequence of characters. It is a text. This
readability condition is responsible for yet another complication
incurred in most genuine input and output operations. Apart from
the actual data transfer, they also involve a transformation of
representation. For example, numbers, usually considered as atomic
units and represented in binary form, need be transformed into
readable, decimal notation. Structures need to be represented in a
suitable layout, whose generation is called formatting.</p>

<p>Whatever the transformation may be, the concept of the sequence is
once again instrumental for a considerable simplification of the
task. The key is the observation that, if the data set can be
considered as a sequence of characters, the transformation of the
sequence can be implemented as a sequence of (identical)
transformations of elements.</p>
<code class='large'>T(&lt;s<sub>0</sub>, s<sub>1</sub>, ..., s<sub>n-1</sub>&gt;) = &lt;T(s<sub>0</sub>), T(s<sub>1</sub>), ... , T(s<sub>n-1</sub>)&gt;</code>

<p>We shall briefly investigate the necessary operations for
transforming representations of natural numbers
for input and output. The basis is that a
number <code>x</code> represented by the sequence of
decimal digits
<code>d = &lt;d<sub>n-1</sub>, ... , d1, d0&gt;</code>
has the value</p>
<code class='large'>x = <b>S</b>i: i = 0 .. n-1: d<sub>i</sub> * 10<sup>i</sup>
x = d<sub>n-1</sub> × 10<sup>n-1</sup> + d<sub>n-2</sub> × 10<sup>n-2</sup> + … + d<sub>1</sub> × 10 + d<sub>0</sub>
x = ( … (d<sub>n-1</sub> × 10 + d<sub>n-2</sub>) × 10 + … + d<sub>1</sub>) × 10 + d<sub>0</sub>
</code>

<p>Assume now that the sequence <code>d</code> is to be
read and transformed, and the resulting numeric value to be
assigned to <code>x</code>. The simple algorithm
terminates with the reading of the first character that is not a
digit. (Arithmetic overflow is not considered).</p>

<code class='large'>x := 0; <span>(* ADenS174.CharsToNumber *)</span>
Read(ch);
WHILE ("0" &lt;= ch) &amp; (ch &lt;= "9") DO
  x := 10*x + (ORD(ch) - ORD("0")); Read(ch)
END</code>

<p>In the case of output the transformation is complexified by the
fact that the decomposition of <code>x</code> into
decimal digits yields them in the reverse order. The least digit is
generated first by computing <code>x MOD 10</code>. This
requires an intermediate buffer in the form of a first-in-last-out
queue (stack). We represent it as an array <code>d</code> with index <code>i</code> and obtain the
following program:</p>
<code class='large'>i := 0; <span>(* ADenS174.NumberToChars *)</span>
REPEAT d[i] := x MOD 10; x := x DIV 10; INC(i)
UNTIL x = 0;
REPEAT DEC(i); Write(CHR(d[i] + ORD("0")))
UNTIL i = 0</code>

<p><i>Note</i>. A consistent substitution of the constant 10 in these
algorithms by a positive integer <code>B</code> will
yield number conversion routines to and from representations with
base <code>B</code>. A frequently used case is
<code>B = 16</code> (hexadecimal), because the involved
multiplications and divisions can be implemented by simple shifts
of the binary numbers.</p>

<p>Obviously, it should not be necessary to specify these ubiquitous
operations in every program in full detail. We therefore postulate
a utility module that provides the most common, standard input and
output operations on numbers and strings. This module is referenced
in most programs throughout this book, and we call it
<code>Texts</code>. It defines a type <code>Text</code>,
<code>Reader</code>s and <code>Writer</code>s
for <code>Text</code>s, and procedures for reading and
writing a character, an integer, a cardinal number, or a
string.</p>

<p>Before we present the definition of module <code>Texts</code>,
we point out an essential asymmetry between
input and output of texts. Whereas a text is generated by a
sequence of calls of writing procedures, writing integers, real
numbers, strings etc., reading a text by a sequence of calls of
reading procedures is questionable practice. This is because we
rather wish to read the next element without having to know its
type. We rather wish to determine its type <i>after</i> reading the
item. This leads us to the concept of a <i>scanner</i> which, after
each scan allows to inspect type and value of the item read. A
scanner acts like a rider in the case of files. However, it imposes
a certain syntax on the text to be read. We postulate a scanner for
texts consisting of a sequence of integers, real numbers, strings,
names, and special characters given by the following syntax
specified in EBNF (Extended Backus Naur Form):</p>

<code class='large'>
item =        integer | RealNumber | identifier | string | SpecialChar.
integer =     [“-”] digit {digit}.
RealNumber =  [“-”] digit {digit} “.” digit {digit} [(“E” | “D”)[“+” |
              “-” digit {digit}].

identifier =  letter {letter | digit}.
string =      ‘”’ {any character except quote} ‘”’.
SpecialChar = “!” | “?” | “@” | “#” | “$” | “%” | “^” | “&amp;” | “+” | “-” |
              “*” | “/” | “\” | “|” | “(” | “)” | “[” | “]” | “{” | “}” |
              “&lt;” | “&gt;” | “.” | “,” | “:” | “;” | “~”.</code>

<p>Items are separated by blanks and/or line breaks.</p>

<code class='large'>DEFINITION Texts; <span >(* ADenS174_Texts *)</span>
  CONST Int = 1; Real = 2; Name = 3; Char = 4;
  TYPE Text, Writer;
    Reader = RECORD eot: BOOLEAN END;
    Scanner = RECORD class: INTEGER;
      i: INTEGER;
      x: REAL;</p>
      s: ARRAY 32 OF CHAR; ch: CHAR;
      nextCh: CHAR
    END;

  PROCEDURE OpenReader (VAR r: Reader; t: Text; pos: INTEGER);
  PROCEDURE OpenWriter (VAR w: Writer; t: Text; pos: INTEGER);
  PROCEDURE OpenScanner (VAR s: Scanner; t: Text; pos: INTEGER);
  PROCEDURE Read (VAR r: Reader; VAR ch: CHAR);

  PROCEDURE ReadInt (VAR r: Reader; VAR n: INTEGER);
  PROCEDURE Scan (VAR s: Scanner);
  PROCEDURE Write (VAR w: Writer; ch: CHAR);
  PROCEDURE WriteLn (VAR w: Writer); (*terminate line*)
  PROCEDURE WriteString (VAR w: Writer; s: ARRAY OF CHAR);
  PROCEDURE WriteInt (VAR w: Writer; x, n: INTEGER);
    (*write integer x with (at least) n characters.
      If n is greater than the number of digits needed,
      blanks are added preceding the number*)

  PROCEDURE WriteReal (VAR w: Writer; x: REAL);
  PROCEDURE Close (VAR w: Writer);
END Texts.</code>

<p>Hence we postulate that after a call of <code>Scan(S)</code></p>

<div class='table'><table>
<tr><td><code>S.class = Int </code></td> <td>implies</td> <td><code> S.i</code> is the integer read</td></tr>
<tr><td><code>S.class = Real </code></td> <td>implies</td> <td><code> S.x</code> is the real number read</td></tr>
<tr><td><code>S.class = Name </code></td> <td>implies</td> <td><code> S.s</code> is the identifier of string read</td></tr>
<tr><td><code>S.class = Char </code></td> <td>implies</td> <td><code> S.ch</code> is the special character read</td></tr>
</table></div>

<p><code>S.nextCh</code> is the character immediately following the
read item, possibly a blank.</p>

</li>
</ol>
</li>

<li data-list-text="1.8" id="1.8">
<h3><a href='#1.8'>Searching</a></h3>

<p>The task of searching is one of most frequent operations in
computer programming. It also provides an ideal ground for
application of the data structures so far encountered. There exist
several basic variations of the theme of searching, and many
different algorithms have been developed on this subject. The basic
assumption in the following presentations is that the collection of
data, among which a given element is to be searched, is fixed. We
shall assume that this set of <code>N</code> elements is
represented as an array, say as</p>

<code>  a: ARRAY N OF Item</code>

<p>Typically, the type item has a record structure with a field that
acts as a key. The task then consists of finding an element of a
whose key field is equal to a given <i>search argument</i>
<code>x</code>. The resulting index <code>i</code>,
satisfying <code>a[i].key = x</code>,
then permits access to the other fields of the located element.
Since we are here interested in the task of searching only, and do
not care about the data for which the element was searched in the
first place, we shall assume that the type <code>Item</code>
consists of the key only, i.e <i>is</i> the
key.</p>

<ol class="page" id="l30">
<li data-list-text="1.8.1" id="1.8.1">
<h4><a href='#1.8.1'>Linear Search</a></h4>
<p>When no further information is given about the searched data, the
obvious approach is to proceed sequentially through the array in
order to increase step by step the size of the section, where the
desired element is known not to exist. This approach is called
<i>linear search</i>. There are two conditions which terminate the
search:</p>

<ol id="l31">
<li data-list-text="1.">
<p>The element is found, i.e. <code>a<sub>i</sub> = x</code>.</p>
</li>
<li data-list-text="2.">
<p>The entire array has been scanned, and no match was found.</p>
</li>
</ol>

<p>This results in the following algorithm:</p>

<code class='large'>i := 0; <span>(* ADenS18_Search *)</span>
WHILE (i &lt; N) &amp; (a[i] # x) DO INC(i) END</code>

<p>Note that the order of the terms in the Boolean expression is
relevant.</p>

<p>The invariant, i.e the condition satisfied before and after each
loop step, is</p>

<code>(0 ≤ i &lt; N) &amp; (<b>A</b>k: 0 ≤ k &lt; i : a<sub>k</sub> ≠ x)</code>

<p>expressing that for all values of <code>k</code> less
than <code>i</code> no match exists. Note that the
values of <code>i</code> before and after each loop step
are different. The invariant is preserved nevertheless due to the
while-clause.</p>

<p>From this and the fact that the search terminates only if the
condition in the while-clause is false, the resulting condition is
derived as:</p>

<code class='large'>((i = N) OR (a<sub>i</sub> = x)) &amp; (<b>A</b>k: 0 ≤ k &lt; i : a<sub>k</sub> ≠ x)</code>

<p>This condition not only is our desired result, but also implies
that when the algorithm did find a match, it found the one with the
least index, i.e. the first one. <code>i = N</code>
implies that no match exists.</p>

<p>Termination of the repetition is evidently guaranteed, because in
each step <code>i</code> is increased and therefore
certainly will reach the limit <code>N</code> after a
finite number of steps; in fact, after <code>N</code>
steps, if no match exists.</p>

<p>Each step evidently requires the incrementing of the index and the
evaluation of a Boolean expression. Could this task be simplifed,
and could the search thereby be accelerated? The only possibility
lies in finding a simplification of the Boolean expression which
notably consists of two factors. Hence, the only chance for finding
a simpler solution lies in establishing a condition consisting of a
single factor that implies both factors. This is possible only by
guaranteeing that a match will be found, and is achieved by posting
an additional element with value <code>x</code> at the
end of the array. We call this auxiliary element a <i>sentinel</i>,
because it prevents the search from passing beyond the index limit.
The array <code>a</code> is now declared as</p>
<code>a: ARRAY N+1 OF INTEGER</code>,
<p>and the linear search algorithm with sentinel is expressed by</p>
<code class='large'>a[N] := x; i := 0; <span>(* ADenS18_Search *)</span>
WHILE a[i] # x DO INC(i) END</code>

<p>The resulting condition, derived from the same invariant as before,
is</p>
<code>(a<sub>i</sub> = x) &amp; (<b>A</b>k: 0 ≤ k &lt; i : a<sub>k</sub> ≠ x)</code>

<p>Evidently, <code>i = N</code> implies that no match
(except that for the sentinel) was encountered.</p>
</li>

<li data-list-text="1.8.2" id="1.8.2">
<h4><a href='#1.8.2'>Binary Search</a></h4>

<p>There is quite obviously no way to speed up a search, unless more
information is available about the searched data. It is well known
that a search can be made much more effective, if the data are
ordered. Imagine, for example, a telephone directory in which the
names were not alphabetically listed. It would be utterly useless.
We shall therefore present an algorithm which makes use of the
knowledge that <code>a</code> is ordered, i.e., of the
condition</p>
<code><b>A</b>k: 1 ≤ k &lt; N : a<sub>k-1</sub> ≤ a<sub>k</sub></code>
<p>The key idea is to inspect an element picked at random, say
<code>a<sub>m</sub></code>, and to compare
it with the search argument <code>x</code>. If it is
equal to <code>x</code>, the search terminates; if it is
less than <code>x</code>, we infer that all elements
with indices less or equal to <code>m</code> can be
eliminated from further searches; and if it is greater than
<code>x</code>, all with index greater or equal to
<code>m</code> can be eliminated. This results in the
following algorithm called <i>binary search</i>; it uses two index
variables <code>L</code> and <code>R</code>
marking the left and at the right end of the section of
<code>a</code> in which an element may still be
found.</p>

<code class='large'>L := 0; R := N-1; <span >(* ADenS18_Search *)</span>
m := <code class='pseudo'>any value between L and R</code>;
WHILE (L &lt;= R) &amp; (a[m] # x) DO
  IF a[m] &lt; x THEN
    L := m+1
  ELSE
    R := m-1
  END;
  m := <code class='pseudo'>any value between L and R</code>
END</code>

<p>Note a fundamental structural similarity of this algorithm and the
linear search in the preceding section: the role of
<code>i</code> is now played by the triplet <code>L, m, R</code>.
To explicate the similarity and, thereby, to better
ensure the loop correctness, we resisted the tempation of a minor
optimization that would eliminate one of the two identical
assignments to <code>m</code>.</p>

<p>The loop invariant, i.e. the condition satisfied before and after
each step, is</p>

<code class='large'>(<b>A</b>k: 0 ≤ k &lt; L : a<sub>k</sub> &lt; x) &amp; (<b>A</b>k: R &lt; k &lt; N : a<sub>k</sub> &gt; x)</code>

<p>from which the result is derived as</p>
<code class='large'>((L &gt; R) OR (a<sub>m</sub> = x)) &amp; (<b>A</b>k: 0 ≤ k &lt; L : a<sub>k</sub> &lt; x ) &amp; (<b>A</b>k: R &lt; k &lt; N : a<sub>k</sub> &gt; x)</code>

<p>which implies</p>
<code class='large'>((L &gt; R) &amp; (<b>A</b>k: 0 ≤ k &lt; N : a<sub>k</sub> <span class="s25">≠</span> x)) OR (a<sub>m</sub> = x)</code>

<p>The choice of <code>m</code> is apparently arbitrary in
the sense that correctness does not depend on it. But it does
influence the algorithm's effectiveness. Clearly our goal must be
to eliminate in each step as many elements
as possible from further searches, no matter what
the outcome of the comparison is. The optimal solution is to choose
the middle element, because this eliminates half of the array in
any case. As a result, the maximum number of steps is
<code>log<sub>2</sub>N</code>, rounded up to the
nearest integer. Hence, this algorithm offers a drastic improvement
over linear search, where the expected number of comparisons
is <code>N/2</code>.</p>

<p>The efficiency can be somewhat improved by interchanging the two
if-clauses. Equality should be tested second, because it occurs
only once and causes termination. But more relevant is the
question, whether — as in the case of linear search — a solution
could be found that allows a simpler condition for termination. We
indeed find such a faster algorithm, if we abandon the naive wish
to terminate the search as soon as a match is established. This
seems unwise at first glance, but on closer inspection we realize
that the gain in efficiency at every step is greater than the loss
incurred in comparing a few extra elements. Remember that the
number of steps is at most <code>log N</code>.</p>

<p>The faster solution is based on the following invariant:</p>

<code class='large'>(<b>A</b>k: 0 ≤ k &lt; L : a<sub>k</sub> &lt; x) &amp; (<b>A</b>k: R ≤ k &lt; N : a<sub>k</sub> ≥ x)</code>
<p>and the search is continued until the two sections span the entire
array.</p>

<code class='large'>L := 0; R := N; <span>(* ADenS18_Search *)</span>
WHILE L &lt; R DO
  m := (L+R) DIV 2;
  IF a[m] &lt; x THEN L := m+1 ELSE R := m END
END</code>

<p>The terminating condition is <code>L ≥ R</code>.
Is it guaranteed to be reached? In
order to establish this guarantee, we must show that under all
circumstances the difference <code>R-L</code> is
diminished in each step. <code>L &lt; R </code> holds at
the beginning of each step. The arithmetic mean <code>m</code>
then satisfies <code>L ≤ m &lt; R</code>.
Hence, the difference is indeed diminished
by either assigning <code>m+1</code> to <code>L</code>
(increasing <code>L</code>) or <code>m</code>
to <code>R</code> (decreasing <code>R</code>),
and the repetition terminates with <code>L = R</code>.</p>

<p>However, the invariant and <code>L = R</code> do not yet
establish a match. Certainly, if <code>R = N</code>, no
match exists. Otherwise we must take into consideration that the
element <code>a[R]</code> had never been compared.
Hence, an additional test for equality <code>a[R] = x</code> is necessary.
In contrast to the first solution, this
algorithm — like linear search — finds the matching element with
the least index.</p>
</li>

<li data-list-text="1.8.3" id="1.8.3">
<h4><a href='#1.8.3'>Table Search</a></h4>

<p>A search through an array is sometimes also called a <i>table
search</i>, particularly if the keys are themselves structured
objects, such as arrays of numbers or characters. The latter is a
frequently encountered case; the character arrays are called
strings or words. Let us define a type <code>String</code> as</p>
<code>String = ARRAY M OF CHAR</code>

<p>and let order on strings <code>x</code>
and <code>y</code> be defined as follows:</p>

<code class='large'>(x = y) ≡ (<b>A</b>j: 0 ≤ j &lt; M : x<sub>j</sub> = y<sub>j</sub>)
(x &lt; y) ≡ <b>E</b>i: 0 ≤ i &lt; N : ((<b>A</b>j: 0 ≤ j &lt; i: x<sub>j</sub> = y<sub>j</sub>) &amp; (x<sub>i</sub> &lt; y<sub>i</sub>))</code>

<p>In order to establish a match, we evidently must find all
characters of the comparands to be equal. Such a comparison of
structured operands therefore turns out to be a search for an
unequal pair of comparands,</p>

<p>i.e. a search for inequality. If no unequal pair exists, equality
is established. Assuming that the length of the words be quite
small, say less than 30, we shall use a linear search in the
following solution.</p>

<p>In most practical applications, one wishes to consider strings as
having a variable length. This is accomplished by associating a
length indication with each individual string value. Using the type
declared above, this length must not exceed the maximum length
<code>M</code>. This scheme allows for sufficient
flexibility for many cases, yet avoids the complexities of dynamic
storage allocation. Two representations of string lengths are most commonly used:</p>

<ol class="noindent" id="l32">
<li data-list-text="1.">
<p>The length is implicitly specified by appending a terminating
character which does not otherwise occur. Usually, the non-printing
value <code>0X</code>. (It is important for the
subsequent applications that it be the <i>least</i> character in
the character set.)</p>
</li>
<li data-list-text="2.">
<p>The length is explicitly stored as the first element of the array,
i.e. the string s has the form</p>
</li>
</ol>

<p><code>s = s<sub>0</sub>, s<sub>1</sub>, s<sub>2</sub>, ... , s<sub>N-1</sub></code>
where <code>s<sub>1</sub> ... s<sub>N-1</sub></code>
are the actual characters of the string and
<code>s<sub>0</sub> = CHR(N)</code>.
This solution has the advantage that the
length is directly available, and the disadvantage that the maximum
length is limited to the size of the character set, that is, to 256
in the case of the ASCII set.</p>

<p>For the subsequent search algorithm, we shall adhere to the first
scheme. A string comparison then takes the form</p>
<code class='large'>i := 0;
WHILE (x[i] # 0X) &amp; (x[i] = y[i]) DO i := i+1 END</code>

<p>The terminating character now functions as a sentinel, the loop
invariant is</p>
<code><b>A</b>j: 0 ≤ j &lt; i : x<sub>j</sub> = y<sub>j</sub> ≠ 0X</code>,
and the resulting condition is therefore</p>
<code class='large'>((x<sub>i</sub> = 0X) OR (x<sub>i</sub> ≠ y<sub>i</sub>)) &amp; (<b>A</b>j: 0 ≤ j &lt; i : x<sub>j</sub> = y<sub>j</sub> ≠ 0X).</code>

<p>It establishes a match between <code>x</code>
and <code>y</code>, provided that
<code>x<sub>i</sub> = y<sub>i</sub></code>;
and it establishes
<code>x &lt; y</code>, if <code>x<sub>i</sub> &lt; y<sub>i</sub></code>.</p>

<p>We are now prepared to return to the task of table searching. It
calls for a nested search, namely a search through the entries of
the table, and for each entry a sequence of comparisons between
components. For example, let the table <code>T</code>
and the search argument <code>x</code> be defined as</p>

<code class='large'>T: ARRAY N OF String;
x: String</code>

<p>Assuming that <code>N</code> may be fairly large and
that the table is alphabetically ordered, we shall use a binary
search. Using the algorithms for binary search and string
comparison developed above, we obtain the following program
segment.</p>

<code class='large'>i := -1; <span>(* ADenS183 *)</span>
L := 0; R := N;
WHILE L &lt; R DO
  m := (L+R) DIV 2; i := 0;
  WHILE (x[i] # 0X) &amp; (T[m,i] = x[i]) DO i := i+1 END;
  IF T[m,i] &lt; x[i] THEN L := m+1 ELSE R := m END
END;
IF R &lt; N THEN
  i := 0;
  WHILE (x[i] # 0X) &amp; (T[R,i] = x[i]) DO i := i+1 END
END
(* (R &lt; N) &amp; (T[R,i] = x[i]) establish a match*)</code>
</li>
</ol>
</li>

<li data-list-text="1.9" id="1.9">
<h3><a href='#1.9'>String search</a></h3>

<p>A frequently encountered kind of search is the so-called <i>string
search</i>. It is characterized as follows.</p>
<p>Given an array <code>s</code> of <code>N</code>
elements and an array <code>p</code> of
<code>M</code> elements, where <code>0 &lt; M &lt; N</code>, declared as</p>
<code class='large'>s: ARRAY N OF Item
p: ARRAY M OF Item</code>
<p>string search is the task of finding the first occurrence of
<code>p</code> in <code>s</code>. Typically,
the items are characters; then <code>s</code> may be
regarded as a text and <code>p</code> as a pattern or
word, and we wish to find the first occurrence of the word in the
text. This operation is basic to every text processing system, and
there is obvious interest in finding an efficient algorithm for
this task.</p>

<p>A specific feature of this problem is the presence of two arrays
and a necessity to scan them simultaneously in such a way that the
coordination of the two indices used to scan the arrays is
determined by the data. A correct implementation of such "braided"
loops is simplified by expressing them using the so-called
<i>Dijkstra's loop</i>, i.e. a multibranch version of the
<code>WHILE</code> loop. This fundamental and powerful
control structure is described in Appendix C.</p>

<p>We consider three string search algorithms: straight string search;
an optimization of the straight search due to Knuth, Morris and
Pratt,; and, finally, the algorithm of Boyer and Moor based on a
revision of the basic idea of the straight search, which proves to
be the most efficient of the three.</p>

<ol class="page" id="l33">
<li data-list-text="1.9.1" id="1.9.1">
<h4><a href='#1.9.1'>Straight String Search</a></h4>

<p>Before paying particular attention to efficiency, however, let us
first present a straightforward searching algorithm. We shall call
it <i>straight string search</i>. It is convenient to have in view
fig. 1.9 that schematically pictures the pattern <code>p</code>
of length <code>M</code> being matched
against the text <code>s</code> of length <code>N</code>
in position <code>i</code>. The index
<code>j</code> numbers the elements of the pattern, and
the pattern element <code>p[j]</code> is matched against
the text element <code>s[i+j]</code>.</p>

<img alt="0 i N-1  string pattern  0 j M-1" src="fig/1.9.png" width="380"/>

<p>Fig. 1.9. A pattern of length <code>M</code> is being
matched against a text of length <code>N</code> in
position <code>i</code>.</p>

<p>The predicate <code>R(i)</code> that describes a
complete match of the pattern against text characters in position
<code>i</code> is formulated as follows:</p>
<code>R(i) = <b>A</b>j: 0 ≤ j &lt; M : p<sub>j</sub> = s<sub>i+j</sub></code>
<p>The allowed values of <code>i</code> where a match can
occur range from <code>0</code> to <code>N-M</code> inclusive.
<code>R</code> is evaluated
by repeatedly comparing the corresponding pairs of characters.
This, evidently, amounts to a linear search of a non-matching
pair:</p>
<code class='large'>R(i) = (<b>A</b>j: 0 ≤ j &lt; M : p<sub>j</sub> = s<sub>i+j</sub>) = ~(<b>E</b>j: 0 ≤ j &lt; M : p<sub>j</sub> ≠ s<sub>i+j</sub>)</code>

<p>Therefore <code>R(i)</code> is easily formulated as follows:</p>
<code class='large'>PROCEDURE R (i: INTEGER): BOOLEAN;
  VAR j: INTEGER;
BEGIN
  (* 0 &lt;= i &lt; N *)
  j := 0;
  WHILE (j &lt; M) &amp; (p[j] = s[i+j]) DO INC(j) END;
  RETURN ~(j &lt; M)
END R</code>

<p>Let the result be the index <code>i</code>, which points
to the first occurrence of a match of the pattern within the
string. Then <code>R(i)</code> should hold. In addition,
<code>R(k)</code> must be false for all <code>k &lt; i</code>.
Denote the latter condition as <code>Q(i)</code>:</p>
<code>Q(i) = <b>A</b>k: 0 ≤ k &lt; i : ~R(k)</code>

<p>With the problem thus formulated, a linear search suggests itself
(see sec.1.8.1):</p>
<code class='large'>i := 0; <span>(* ADenS191_Straight *)</span>
WHILE (i &lt;= N-M) &amp; ~R(i) DO INC(i) END</code>

<p>The invariant of this loop is <code>Q(i)</code>, which
holds both before the instruction <code>INC(i)</code>
and — thanks to the second operand of the guard — after it.</p>

<p>An advantage of this algorithm is the transparency of its logic:
the two loops are completely decoupled and one is hidden inside the
function-procedure <code>R</code>. However, this same
property may also be a disadvantage: firstly, the additional
procedure call at each step of a potentially long loop may be too
costly in such a basic operation as the string search. Secondly,
the more sophisticated algorithms considered in subsequent sections
make use of the information obtained in the inner loop in order to
increase i in the external loop by a value larger than 1, so that
the two loops are no longer independent. One could eliminate the
procedure <code>R</code> by introducing a logical
variable to store its result and by embedding the loop from
<code>R</code> in the body of the main loop over
<code>i</code>. However, the interaction of two loops
via a logical variable destroys the original transparency, which
may cause errors in the program evolution.</p>

<p>Formulation of such loops is facilitated by the so-called Dijkstra
loop, which is a multibranch version of the
<code>WHILE</code> loop with each branch having its own guard (see
<a href='#Appendix-C'>Appendix C</a>).
In the present case the two branches correspond to the
steps in <code>i</code> and <code>j</code>,
respectively. Recall Fig. 1.9 and introduce the predicate
<code>P(i, j)</code> that expresses the match of the
first <code>j</code> characters of the pattern with the
characters of the text starting from position <code>i</code>:</p>
<code>P(i, j) = <b>A</b>k: 0 ≤ k &lt; j : s<sub>i+k</sub> = p<sub>k</sub></code>

<p>Then <code>R(i) = P(i, M)</code>.</p>
<p>Fig. 1.9 shows that the current search state is characterized by
<code>i</code> and <code>j</code>. The
invariant (i.e. the condition that holds after each increase of
<code>i</code> or <code>j</code>) can be
chosen as follows: in the positions below <code>i</code>
there is no match, and in the position <code>i</code>
there is a match of the first <code>j</code> characters
of the pattern. This is formally expressed as follows:</p>
<code>Q(i) &amp; P(i, j)</code>
<p>Evidently, <code>j = M</code> would mean there is a
required math of the entire pattern in the position
<code>i</code>, whereas <code>i &gt; N - M</code> would
mean that the text contains no match at all.</p>

<p>It is then sufficient to try to increment <code>j</code>
by 1 in order to increase the matching segment, and if that is
impossible, to move the pattern into a new position by incrementing
<code>i</code> by 1 and setting <code>j</code> to 0, in
order to restart verifying the match from
the beginning of the pattern:</p>
<code class='large'>i := 0; j := 0;
WHILE <code class='pseudo'>the matching segment can be increased</code> DO
  INC( j )
ELSIF <code class='pseudo'>the pattern can be moved</code> DO
  INC( i ); j := 0
END</code>

<p>It remains to consider each step separately and to accurately
formulate the conditions for which each step makes sense,
i.e. preserves the invariant. For the
first branch it is the condition
<code>(i ≤ N-M) &amp; (j &lt; M) &amp; (s<sub>i+j</sub> = p<sub>j</sub>)</code>
which guarantees <code>P(i, j)</code> after <code>j</code>
is incremented. For the second branch, the last
operand of this conjunction must have inequality instead of
equality, which would imply <code>~R(i)</code> and
guarantee <code>Q(i)</code> after <code>i</code>
is incremented. Taking into account that the two guards are
evaluated in their textual order, the last operand of the
conjunction can be dropped in the second branch, and one arrives at
the following program:</p>
<code class='large'>i := 0; j := 0; <span>(* ADenS191_Straight *)</span>
WHILE (i &lt;= N-M) &amp; (j &lt; M) &amp; (s[i+j] = p[j]) DO
  INC( j )
ELSIF (i &lt;= N-M) &amp; (j &lt; M) DO
  INC( i ); j := 0
END</code>

<p>After the loop terminates, the condition is
guaranteed to hold, which is equal to conjunction of negations of
all quards, i.e. (<code>i &lt; N-M) OR (j &gt;= M)</code>.
Moreover, from the structure of the loop
it follows that the two operands cannot hold simultanelously,
and <code>j</code> cannot exceed <code>M</code>.
Then <code>i &lt; N-M</code> means that there
is no match anywhere in the text,
whereas <code>j = M</code>,
that <code>Q(i) &amp; P(i, M)</code>
is true, i.e. a complete match is found in
position <code>i</code>.</p>

<p><i><b>Analysis of straight string search.</b></i> This algorithm
operates quite effectively, if we can assume that a mismatch
between character pairs occurs after at most a few comparisons in
the inner loop. This is likely to be the case, if the cardinality
of the item type is large. For text searches with a character set
size of 128 we may well assume that a mismatch occurs after
inspecting 1 or 2 characters only. Nevertheless, the worst case
performance is rather alarming. Consider, for example, that the
string consist of <code>N-1 A</code>'s followed by a
single <code>B</code>, and that the pattern consist of
<code>M-1 A</code>'s followed by a <code>B</code>.
Then in the order of <code>N*M</code>
comparisons are necessary to find the match at the end of the
string. As we shall subsequently see, there fortunately exist
methods that drastically improve this worst case behaviour.</p>
</li>

<li data-list-text="1.9.2" id="1.9.2">
<h4><a href='#1.9.2'>The Knuth-Morris-Pratt String Search</a></h4>

<p>Around 1970, D.E. Knuth, J.H. Morris, and V.R. Pratt invented an
algorithm that requires essentially in the order of N character
comparisons only, even in the worst case [1-8]. The new algorithm
is based on the observation that by starting the next pattern
comparison at its beginning each time, we may be discarding
valuable information gathered during previous comparisons. After a
partial match of the beginning of the pattern with corresponding
characters in the string, we indeed know the last part of the
string, and perhaps could have precompiled some data (from the
pattern) which could be used for a more rapid advance in the text
string. The following example of a search for the word Hooligan
illustrates the principle of the algorithm. Underlined characters
are those which were compared. Note that each time two compared
characters do not match, the pattern is shifted all the way,
because a smaller shift could not possibly lead to a full
match.</p>

<code class='large'>Hoola-Hoola girls like Hooligans.
<u>Hooli</u>gan
    <u>H</u>ooligan
     <u>H</u>ooligan
      <u>Hooli</u>gan
          <u>H</u>ooligan
           <u>H</u>ooligan
           ......
                      <u>Hooligan</u></code>

<p>In contrast with the simple algorithm, here the comparison point
(the position of the text element being compared with some element
of the pattern) is never moved backwards. This suggests that we
must abandon the notion that i always marks the current position of
the first pattern character in the text. Rather,
<code>i</code> will now store the comparison point; the
variable <code>j</code> will as before point to the
corresponding element of the pattern. See fig. 1.10.</p>


<img alt="0 i N-1    A B C D    A B C E     string pattern    0 j M-1" src="fig/1.10.png" width="380"/>

<p>Fig. 1.10. In the notations of the KMP algorithm, the alignment
position of the pattern is now <code>i-j</code> (and not
<code>i</code>, as was the case with the simple
algorithm).</p>

<p>The central pont of the algorithm is the comparison of
<code>s[i]</code> and <code>p[j]</code>, if they are
equal then <code>i</code> and <code>j</code>
are both increased by 1, otherwise the pattern must be shifted by
assigning to <code>j</code> of some smaller value
<code>D</code>. The boundary case <code>j = 0</code> shows
that one should provide for a shift of the pattern
entirely beyond the current comparison point (so that
<code>p[0]</code> becomes aligned with <code>s[i+1]</code>).
For this, it is convenient to choose
<code>D = -1</code>. The main loop of the algorithm
takes the following form:</p>
<code class='large'>i := 0; j := 0;
WHILE (i &lt; N) &amp; (j &lt; M) &amp; ((j &lt; 0) OR (s[i] = p[j])) DO
  INC( i ); INC( j )
ELSIF (i &lt; N) &amp; (j &lt; M) DO (* (j &gt;= 0) &amp; (s[i] # p[j]) *)
  j := D
END</code>

<p>This formulation is admittedly not quite complete, because it
contains an unspecified shift value <code>D</code>. We
shall return to it shortly, but first point out that the invariant
here is chosen the same as in the simple algorithm; in the new
notation it is <code>Q(i-j) &amp; P(i-j, j)</code>.</p>

<p>The post condition of the loop — evaluated as a conjuction of
negations of all guards — is given by the expression
<code>(j &gt;= M) OR (i &gt;= N)</code>, but in reality only
equalities can occur. If the algorithm terminates due to
<code>j = M</code>, the term <code>P(i-j, j)</code>
of the invariant implies <code>P(i-M, M) = R(i)</code>,
that is, a match at position <code>i-M</code>.
Otherwise it terminates with <code>i = N</code>,
and since <code>j &lt; M</code>, the first
term of the invariant, <code>Q(i-j)</code>, implies that
no match exists at all.</p>

<p>We must now demonstrate that the algorithm never falsifies the
invariant. It is easy to show that it is established at the
beginning with the values <code>i = j = 0</code>. Let us
first investigate the effect of the two statements incrementing
<code>i</code> and <code>j</code> by 1 in the
first branch. They apparently do not falsify <code>Q(i-j)</code>,
since the difference <code>i-j</code> remains unchanged.
Nor do they falsify <code>P(i-j, j)</code>
thanks to the equality in the guard (see the
definition of <code>P</code>). As to the second branch,
we shall simply postuate that the value <code>D</code>
always be such that replacing <code>j</code> by
<code>D</code> will maintain the invariant.</p>

<p>Provided that <code>D &lt; j</code> the assignment
<code>j := D</code> represents a shift of the pattern to
the right by <code>j-D</code> positions. Naturally, we
wish this shift to be as large as possible, i.e.,
<code>D</code> to be as small as possible. This is illustrated by
Fig. 1.11.</p>

<img src="fig/1.11.png" width="800"/>
<p>Fig. 1.11. Assignment <code>j := D</code> shifts pattern
by <code>j-D</code> positions</p>

<p>Evidently the condition <code>P(i-D, D) &amp; Q(i-D)</code>
must hold before assigning <code>j := D</code>,
if the invariant <code>P(i-j, j) &amp; Q(i-j)</code>
is to hold thereafter. This precondition is therefore
our guideline for finding an appropriate expression for
<code>D</code> along with the condition
<code>P(i-j, j) &amp; Q(i-j)</code>, which is assumed to hold prior
to the assignment (all subsequent reasoning concerns this point of
the program).</p>

<p>The key observation is that thanks to <code>P(i-j, j)</code> we know that</p>

<code>p<sub>0</sub> ... p<sub>j-1</sub> = s<sub>i-j</sub> ... s<sub>i-1</sub></code>

<p>(we had just scanned the first <code>j</code> characters
of the pattern and found them to match). Therefore the
condition <code>P(i-D, D)</code> with <code>D &lt; j</code>, i.e.,</p>

<code>p<sub>0</sub> ... p<sub>D-1</sub> = s<sub>i-D</sub> ... s<sub>i-1</sub></code>

<p>translates into an equation for <code>D</code>:</p>
<code>p<sub>0</sub> ... p<sub>D-1</sub> = p<sub>j-D</sub> ... p<sub>j-1</sub></code>

<p>As to <code>Q(i-D)</code>, this condition follows from
<code>Q(i-j)</code> provided <code>~R(i-k)</code>
for <code>k = D+1 ... j</code>. The validity of</p>

<p><code>~R(i-k)</code> for <code>j = k</code> is
guaranteed by the inequality <code>s[i] # p[j]</code>.
Although the conditions <code>~R(i-k) ≡ ~P(i-k, M)</code> for
<code>k = D+1 ... j-1</code> cannot be evaluated
from the scanned text fragment only, one
can evaluate the sufficient conditions <code>~P(i-k,k)</code>.
Expanding them and taking into account the already found
matches between the elements of <code>s</code> and
<code>p</code>, we obtain the following condition:</p>

<code>p<sub>0</sub> ... p<sub>k-1</sub> ≠ p<sub>j-k</sub> ... p<sub>j-1</sub>  </code>
for all <code> k = D+1 ... j-1</code>

<p>that is, <code>D</code> must be the <i>maximal</i>
solution of the above equation. Fig. 1.12 illustrates the function
of <code>D</code>.</p>

<img src="fig/1.12.png" width="700"/>
<p>Fig. 1.12. Partial pattern matches and computation of <code>D</code>.</p>

<p>If there is no solution for <code>D</code>, then there
is no match in positions below <code>i+1</code>. Then we
set <code>D := -1</code>. Such a situation is shown in
the upper part in Fig. 1.13.</p>

<p>The last example in Fig. 1.12 suggests that we can do even slightly
better; had the character <code>p<sub>j</sub></code> been an
<code>A</code> instead of an
<code>F</code>, we would know that the corresponding
string character could not possibly be an <code>A</code>,
and the shift of the pattern with <code>D = -1</code>
had to be performed in the next loop iteration
(see Fig. 1.13, the lower part).
Therefore we may impose the condition
<code>p<sub>D</sub> ≠ p<sub>j</sub></code> when solving
for <code>D</code>. This allows us to fully utilize the
information from the inequality in the guard of this loop
branch.</p>

<img src="fig/1.13.png" width="500"/>
<p>Fig.1.13. Shifting pattern past position of last character</p>

<p>The essential result is that the value <code>D</code>
apparently is determined by the pattern alone and does not depend
on the text string. We shall denote <code>D</code> for a
given <code>j</code> as <code>d<sub>j</sub></code>. The auxiliary table
<code>d</code> may be computed before starting the
actual search; this computation amounts to a precompilation of the
pattern. This effort is evidently only worthwhile if the text is
considerably longer than the pattern (<code>M &lt;&lt; N</code>).
If multiple occurrences of the same pattern are to be
found, the same values of <code>d</code> can be
reused.</p>

<p>So, the computation of <code>d<sub>j</sub> &lt; j</code>
is the search for the longest matching sequence</p>

<code>p<sub>0</sub> ... p<sub>d[j]-1</sub> = p<sub>j-d[j]</sub> ... p<sub>j-1</sub></code>

<p>with the additional constraint of
<code>p<sub>d[j]</sub> ≠ p<sub>j</sub></code>.
Evidently, the computation of <code>d<sub>j</sub></code>
presents us with the first application of string
search, and we may as well use the fast KMP version itself.</p>

<code class='large'>PROCEDURE Search (VAR p, s: ARRAY OF CHAR; M, N: INTEGER; VAR r: INTEGER);
<span>(* ADenS192_KMP *)</span>
  (*search for pattern p of length M in text s of length N; M &lt;= Mmax*)
  (*if p is found, then r indicates the position in s, otherwise r = -1*)
  VAR i, j, k: INTEGER;
    d: ARRAY Mmax OF INTEGER;
BEGIN
  (*compute d from p*)
  d[0] := -1;
  IF p[0] # p[1] THEN d[1] := 0 ELSE d[1] := -1 END;
  j := 1; k := 0;
  WHILE (j &lt; M-1) &amp; (k &gt;= 0) &amp; (p[j] # p[k]) DO
    k := d[k]
  ELSIF j &lt; M-1 DO (* (k &lt; 0) OR (p[j] = p[k]) *)
    INC( j ); INC( k );
    IF p[j] # p[k] THEN d[j] := k ELSE d[j] := d[k] END; ASSERT( d[j] = D(j) );
  END;

  (*search proper*)
  i := 0; j := 0;
  WHILE (j &lt; M) &amp; (i &lt; N) &amp; (j &gt;= 0) &amp; (s[i] # p[j]) DO
    j := d[j];
  ELSIF (j &lt; M) &amp; (i &lt; N) DO
    INC(i); INC(j);
  END;

  IF j = M THEN r := i-M ELSE r := -1 END
END Search</code>

<p><i><b>Analysis of KMP search.</b></i> The exact analysis of the
performance of KMP-search is, like the algorithm itself, very
intricate. In [1-8] its inventors prove that the number of
character comparisons is in the order of <code>M+N</code>,
which suggests a substantial improvement over
<code>M*N</code> for the straight search. They also
point out the welcome property that the scanning pointer
<code>i</code> never backs up, whereas in straight
string search the scan always begins at the first pattern character
after a mismatch, and therefore may involve characters that had
actually been scanned already. This may cause awkward problems when
the string is read from secondary storage where backing up is
costly. Even when the input is buffered, the pattern may be such
that the backing up extends beyond the buffer contents.</p>
</li>

<li data-list-text="1.9.3" id="1.9.3">
<h4><a href='#1.9.3'>The Boyer-Moore String Search</a></h4>

<p>The clever scheme of the KMP-search yields genuine benefits only if
a mismatch was preceded by a partial match of some length. Only in
this case is the pattern shift increased to more than 1.
Unfortunately, this is the exception rather than the rule; matches
occur much more seldom than mismatches. Therefore the gain in using
the KMP strategy is marginal in most cases of normal text
searching. The method to be discussed here does indeed not only
improve performance in the worst case, but also in the average
case. It was invented by R.S. Boyer and J.S. Moore around 1975, and
we shall call it BM search. We shall here present a simplified
version of BM-search before proceeding to the one given by Boyer
and Moore.</p>

<p>BM-search is based on the unconventional idea to start comparing
characters at the end of the pattern rather than at the beginning.
Like in the case of KMP-search, the pattern is precompiled into a
table <code>d</code> before the actual search starts.
Let, for every character <code>x</code> in the character
set, <code>d<sub>x</sub></code> be the
distance of the rightmost occurrence of <code>x</code>
in the pattern from its end. Now assume that a mismatch between
string and pattern was discovered. Then the pattern can immediately
be shifted to the right by <code>d<sub>p[M-1]</sub></code>
positions, an amount that is quite likely to be
greater than 1. If <code>p<sub>M-1</sub></code>
does not occur in the pattern at all, the shift is
even greater, namely equal to the entire pattern's length. The
following example illustrates this process.</p>

<code class='large'>Hoola-Hoola girls like Hooligans.
Hooliga<u>n</u>
     Hooliga<u>n</u>
       Hooliga<u>n</u>
               Hooliga<u>n</u>
                       <u>Hooligan</u></code>

<p>Since individual character comparisons now proceed from right to
left, the following, slightly modified versions of of the
predicates <code>P</code>, <code>R</code> and
<code>Q</code> are more convenient.</p>

<code class='large'>P(i, j)   = <b>A</b>k: j ≤ k &lt; M : s<sub>i-M+k</sub> = p<sub>k</sub>
R(i)      = P(i, 0)
Q(i)      = <b>A</b>k: M ≤ k &lt; i : ~R(k)</code>

<p>The loop invariant has the form <code>Q(i) &amp; P(i, j)</code>.
It is convenient to define <code>k = i-M+j</code>.
Then the BM-algorithm can be formulated as follows.</p>

<code class='large'>i := M; j := M; k := i;
WHILE (j &gt; 0) &amp; (i &lt;= N) &amp; (s[k-1] = p[j-1]) DO
  DEC(k); DEC(j)
ELSIF (j &gt; 0) &amp; (i &lt;= N) DO
  i := i + d[ORD(s[i-1])]; j := M; k := i;
END</code>

<p>The indices satisfy <code>0 ≤ j ≤ M, M ≤ i, and 0 &lt; k ≤ i</code>.
Therefore, termination with <code>j = 0</code>
implies <code>P(i, 0) = R(i)</code>,
i.e., a match at position <code>k = i-M</code>.
Termination with <code>j &gt; 0</code> demands
that <code>i &gt; N</code>; hence <code>Q(i)</code>
implies <code>Q(N)</code>, signalling
that no match exists. Of course we still have to convince ourselves
that <code>Q(i)</code> and <code>P(i, j)</code>
are indeed invariants of the two repetitions. They are
trivially satisfied when repetition starts, since <code>Q(M)</code>
and <code>P(x, M)</code> are always true.</p>

<p>Consider the first branch. Simultaneously
decrementing <code>k</code> and <code>j</code>
does not affect <code>Q(i)</code>, and, since
<code>s<sub>k-1</sub> = p<sub>j-1</sub></code>
had been established, and <code>P(i, j)</code>
holds prior to decrementing <code>j</code>,
then <code>P(i, j)</code> holds after it as well.</p>

<p>In the second branch, it is sufficient to show that
the statement <code>i := i + d<sub>s[i-1]</sub></code>
never falsifies the invariant <code>Q(i)</code>
because <code>P(i, j)</code> is satisfied
automatically after the remaining assignments.
<code>Q(i)</code> is satisfied after incrementing i provided that
before the assignment <code>Q(i+d<sub>s[i-1]</sub>)</code>
is guaranteed. Since we know that <code>Q(i)</code>
holds, it suffices to establish <code>~R(i+h)</code>
for <code>h = 1 .. d<sub>s[i-1]</sub>-1</code>.
We now recall that <code>d<sub>x</sub></code> is defined as the
distance of the rightmost occurrence of <code>x</code> in
the pattern from the end. This is formally expressed as</p>
<code><b>A</b>k: M-d<sub>x</sub> ≤ k &lt; M-1 : p<sub>k</sub> ≠ x</code>

<p>Substituting <code>s<sub>i-1</sub></code>
for <code>x</code>, we obtain</p>
<code class='large'><b>A</b>k: M-d<sub>s[i-1]</sub> ≤ k &lt; M-1 : s<sub>i-1</sub> ≠ p<sub>k</sub>
= Ah: 1 ≤ h ≤ d<sub>s[i-1]</sub>-1 : s<sub>i-1</sub> ≠ p<sub>M-1-h</sub>
⇒ Ah: 1 ≤ h ≤ d<sub>s[i-1]</sub>-1 : ~R(i+h)</code>

<p>The following program includes the presented, simplified
Boyer-Moore strategy in a setting similar to that of the preceding
KMP-search program.</p>

<code class='large'>PROCEDURE Search (VAR s, p: ARRAY OF CHAR; M, N: INTEGER; VAR r: INTEGER);
<span>(* ADenS193_BM *)</span>
  (*search for pattern p of length M in text s of length N*)
  (*if p is found, then r indicates the position in s, otherwise r = -1*)
  VAR i, j, k: INTEGER;
    d: ARRAY 128 OF INTEGER;
BEGIN
  FOR i := 0 TO 127 DO d[i] := M END;
  FOR j := 0 TO M-2 DO d[ORD(p[j])] := M-j-1 END;
  i := M; j := M; k := i;
  WHILE (j &gt; 0) &amp; (i &lt;= N) &amp; (s[k-1] = p[j-1]) DO
    DEC(k); DEC(j)
  ELSIF (j &gt; 0) &amp; (i &lt;= N) DO
    i := i + d[ORD(s[i-1])]; j := M; k := i;
  END;
  IF j &lt;= 0 THEN r := k ELSE r := -1 END
END Search</code>

<p><i><b>Analysis of Boyer-Moore Search.</b></i> The original
publication of this algorithm [1-9] contains a detailed analysis of
its performance. The remarkable property is that in all except
especially construed cases it requires substantially less than
<code>N</code> comparisons. In the luckiest case, where
the last character of the pattern always hits an unequal character
of the text, the number of comparisons is <code>N/M</code>.</p>

<p>The authors provide several ideas on possible further improvements.
One is to combine the strategy explained above, which provides
greater shifting steps when a mismatch is present, with the
Knuth-Morris-Pratt strategy, which allows larger shifts after
detection of a (partial) match. This method requires two
precomputed tables; <code>d1</code> is the table used
above, and <code>d2</code> is the table corresponding to
the one of the KMP-algorithm. The step taken is then the larger of
the two, both indicating that no smaller step could possibly lead
to a match. We refrain from further elaborating the subject,
because the additional complexity of the table generation and the
search itself does not seem to yield any appreciable efficiency
gain. In fact, the additional overhead is larger, and casts some
uncertainty whether the sophisticated extension is an improvement
or a deterioration.</p>

<h3 id="1.exe"><a href='#1.exe'>Exercises</a></h3>
<div>
<ol class="ident" id="l35">
<li data-list-text="1.1.">
Assume that the cardinalities of the standard types <code>INTEGER</code>,
<code>REAL</code> and <code>CHAR</code> are denoted by
<code>c<sub>int</sub></code>,
<code>c<sub>real</sub></code> and <code>c<sub>char</sub></code>.
What are the
cardinalities of the following data types defined as exemples in
this chapter: <code class='large'>Complex, Date, Person, Row, Card, Name</code>?
</li>

<li data-list-text="1.2.">
Which are the instruction sequences (on your computer) for the
following:

<ol class="ident" id="l36">
<li data-list-text="(a)">
Fetch and store operations for an element of packed records and
arrays?
</li>
<li data-list-text="(b)">
Set operations, including the test for membership?
</li>
</ol>
</li>

<li data-list-text="1.3.">
What are the reasons for defining certain sets of data as sequences
instead of arrays?
</li>
<li data-list-text="1.4.">
Given is a railway timetable listing the daily services on several
lines of a railway system. Find a representation of these data in
terms of arrays, records, or sequences, which is suitable for
lookup of arrival and departure times, given a certain station and
desired direction of the train.
</li>
<li data-list-text="1.5.">
Given a text <code>T</code> in the form of a sequence
and lists of a small number of words in the form of two arrays
<code>A</code> and <code>B</code>. Assume
that words are short arrays of characters of a small and fixed
maximum length. Write a program that transforms the text
<code>T</code> into a text <code>S</code> by
replacing each occurrence of a word <code>A<sub>i</sub></code>
by its corresponding word <code>B<sub>i</sub></code>.
</li>
<li data-list-text="1.6.">
<p>Compare the following three versions of the binary search with the
one presented in the text. Which of the three programs are correct?
Determine the relevant invariants. Which versions are more
efficient? We assume the following variables, and the constant
<code>N &gt; 0</code></p>

<code class='large'>VAR i, j, k, x: INTEGER;
  a: ARRAY N OF INTEGER;</code>

<p>Program A:</p>

<code class='large'>i := 0; j := N-1;
REPEAT
  k := (i+j) DIV 2;
  IF a[k] &lt; x THEN i := k ELSE j := k END
UNTIL (a[k] = x) OR (i &gt; j)</code>

<p>Program B:</p>

<code class='large'>i := 0; j := N-1;
REPEAT
  k := (i+j) DIV 2;
  IF x &lt; a[k] THEN j := k-1 END;
  IF a[k] &lt; x THEN i := k+1 END
UNTIL i &gt; j</code>

<p>Program C:</p>

<code class='large'>i := 0; j := N-1;
REPEAT
  k := (i+j) DIV 2;
  IF x &lt; a[k] THEN j := k ELSE i := k+1 END
UNTIL i &gt; j</code>

<p><i>Hint</i>: All programs must
terminate with <code>a<sub>k</sub> = x</code>,
if such an element exists, or <code>a<sub>k</sub> ≠ x</code>, if
there exists no element with value <code>x</code>.</p>
</li>
<li data-list-text="1.7.">
<p>A company organizes a poll to determine the success of its
products. Its products are records and tapes of hits, and the most
popular hits are to be broadcast in a hit parade. The polled
population is to be divided into four categories according to sex
and age (say, less or equal to 20, and older than 20). Every person
is asked to name five hits. Hits are identified by the numbers 1 to
<code>N</code> (say, <code>N = 30</code>).
The results of the poll are to be appropriately encoded as a
sequence of characters.</p>

<p><i>Hint:</i> use procedures <code>Read</code> and
<code>ReadInt</code> to read the values of the poll.</p>
<code class='large'>TYPE hit = INTEGER;
  reponse = RECORD name, firstname: Name;
    male: BOOLEAN;
    age: INTEGER;
    choice: ARRAY 5 OF hit
  END;

VAR poll: Files.File</code>

<p>This file is the input to a program which computes the following
results:</p>

<ol class="noindent" id="l37">
<li data-list-text="1.">
<p>
A list of hits in the order of their popularity. Each entry
consists of the hit number and the number of times it was mentioned
in the poll. Hits that were never mentioned are omitted from the
list.</p>
</li>
<li data-list-text="2.">
<p>
Four separate lists with the names and first names of all
respondents who had mentioned in first place one of the three hits
most popular in their category.</p>
</li>
</ol>

<p>The five lists are to be preceded by suitable titles.</p>

</li>
</ol>
</div>

<h3 id="1.ref"><a href='#1.ref'>References</a></h3>
<p id="[1.1]">
[1.1] O-.J. Dahl, E.W. Dijkstra, C.A.R. Hoare. Structured
Programming. F. Genuys, Ed., New York, Academic Press, 1972.
</p>
<p id="[1.2]">
[1.2] C.A.R. Hoare, in Structured Programming [1.1], pp.
83-174.
</p>
<p id="[1.3]">
[1.3] K. Jensen and N. Wirth. PASCAL — User Manual and Report.
Springer-Verlag, 1974.
</p>
<p id="[1.4]">
[1.4] N. Wirth. Program development by stepwise refinement.
<i>Comm. ACM</i>, 14, No. 4 (1971), 221-27.
</P>
<p id="[1.5]">
[1.5] N. Wirth.
Programming in Modula-2. Springer-Verlag, 1982.</p>
<p id="[1.6]">
[1.6] N. Wirth. On the composition of well-structured programs.
<i>Computing Surveys</i>, 6, No. 4, (1974) 247-59.
</p>
<p id="[1.7]">
[1.7] C.A.R. Hoare. The Monitor: An operating systems structuring
concept. <i>Comm. ACM</i> 17, 10 (Oct. 1974), 549-557.
</p>
<p id="[1.8]">
[1.8] D.E.Knuth, J.H. Morris, and V.R. Pratt. Fast pattern matching
in strings. <i>SIAM J. Comput.</i>, 6, 2, (June 1977), 323-349.
</p>
<p id="[1.9]">
[1.9] R.S. Boyer and J.S. Moore. A fast string searching algorithm.
<i>Comm. ACM</i>, 20, 10 (Oct. 1977), 762-772.
</p>

</li>
</ol>
</li>
</ol>
</li>
<p class="newpage"></p>


<li data-list-text="2" id="2">
<h2><a href='#2'>SORTING</a></h2>
<ol class="page" id="l38">
<li data-list-text="2.1" id="2.1">
<h3><a href='#2.1'>Introduction</a></h3>

<p>The primary purpose of this chapter is to provide an extensive set
of examples illustrating the use of the data structures introduced
in the preceding chapter and to show how the choice of structure
for the underlying data profoundly influences the algorithms that
perform a given task. Sorting is also a good example to show that
such a task may be performed according to many different
algorithms, each one having certain advantages and disadvantages
that have to be weighed against each other in the light of the
particular application.</p>

<p>Sorting is generally understood to be the process of rearranging a
given set of objects in a specific order. The purpose of sorting is
to facilitate the later search for members of the sorted set. As
such it is an almost universally performed, fundamental activity.
Objects are sorted in telephone books, in income tax files, in
tables of contents, in libraries, in dictionaries, in warehouses,
and almost everywhere that stored objects have to be searched and
retrieved. Even small children are taught to put their things "in
order", and they are confronted with some sort of sorting long
before they learn anything about arithmetic.</p>

<p>Hence, sorting is a relevant and essential activity, particularly
in data processing. What else would be easier to sort than data!
Nevertheless, our primary interest in sorting is devoted to the
even more fundamental techniques used in the construction of
algorithms. There are not many techniques that do not occur
somewhere in connection with sorting algorithms. In particular,
sorting is an ideal subject to demonstrate a great diversity of
algorithms, all having the same purpose, many of them being optimal
in some sense, and most of them having advantages over others. It
is therefore an ideal subject to demonstrate the necessity of
performance analysis of algorithms. The example of sorting is
moreover well suited for showing how a very significant gain in
performance may be obtained by the development of sophisticated
algorithms when obvious methods are readily available.</p>

<div class='table'><table>
<tr>
<td><img width="409" height="207" src=
"data:image/jpg;base64,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" /></td>
</tr>
</table></div>

<p>Fig. 2.1. The sorting of an array</p>

<p>The dependence of the choice of an algorithm on the structure of
the data to be processed - an ubiquitous phenomenon - is so
profound in the case of sorting that sorting methods are generally
classified into two categories, namely, sorting of arrays and
sorting of (sequential) files. The two classes are often called
internal and external sorting because arrays are stored in the
fast, high-speed, random-access "internal" store of computers and
files are appropriate on the slower, but more spacious "external"
stores based on mechanically moving devices (disks and tapes). The
importance of this distinction is obvious from the example of
sorting numbered cards. Structuring the cards as an array
corresponds to laying them out in front of the sorter so
that each card is visible and individually
accessible (see Fig. 2.1).</p>

<p>Structuring the cards as a file, however, implies that from each
pile only the card on the top is visible (see Fig. 2.2).</p>

<div class='table'><table>
<tr>
<td><img width="403" height="175" src=
"data:image/jpg;base64,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" /></td>
</tr>
<tr>
<td><img width="403" height="87" src=
"data:image/jpg;base64,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" /></td>
</tr>
<tr>
<td><img width="403" height="87" src=
"data:image/jpg;base64,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" /></td>
</tr>
</table></div>
<p>Fig. 2.2. The sorting of a file</p>

<p>Such a restriction will evidently have serious consequences on the
sorting method to be used, but it is unavoidable if the number of
cards to be laid out is larger than the available table.</p>

<p>Before proceeding, we introduce some terminology and notation to be
used throughout this chapter. If we are given <code>n</code> items</p>

<code>a<sub>0</sub>, a<sub>1</sub>, ... , a<sub>n-1</sub></code>

<p>sorting consists of permuting these items into an array</p>
<code>a<sub>k0</sub>, a<sub>k1</sub>, ... , a<sub>k[n-1]</sub></code>
<p>such that, given an ordering function <code>f</code></p>
<code>f(a<sub>k0</sub>) ≤ f(a<sub>k1</sub>) ≤ ... ≤ f(a<sub>k[n-1]</sub>)</code>

<p>Ordinarily, the ordering function is not evaluated according to a
specified rule of computation but is stored as an explicit
component (field) of each item. Its value is called the <i>key</i>
of the item. As a consequence, the record structure is particularly
well suited to represent items and might for example be declared as
follows:</p>

<code class='large'>TYPE Item = RECORD key: INTEGER;
              (*other components declared here*)
            END</code>

<p>The other components represent relevant data about the items in the
collection; the key merely assumes the purpose of identifying the
items. As far as our sorting algorithms are concerned, however, the
key is the only relevant component, and there is no need to define
any particular remaining components. In the following discussions,
we shall therefore discard any associated information and assume
that the type <code>Item</code> be defined as
<code>INTEGER</code>. This choice of the key type is
somewhat arbitrary. Evidently, any type on which a
total ordering relation is defined could be used just as well.</p>

<p>A sorting method is called <i>stable</i> if the relative order if
items with equal keys remains unchanged by the sorting process.
Stability of sorting is often desirable, if items are already
ordered (sorted) according to some secondary keys, i.e., properties
not reflected by the (primary) key itself.</p>

<p>This chapter is not to be regarded as a comprehensive survey in
sorting techniques. Rather, some selected, specific methods are
exemplified in greater detail. For a thorough treatment of sorting,
the interested reader is referred to the excellent and
comprehensive compendium by D. E. Knuth [2-7] (see also Lorin
[2-10]).</p>
</li>

<li data-list-text="2.2" id="2.2">
<h3><a href='#2.2'>Sorting Arrays</a></h3>

<p>The predominant requirement that has to be made for sorting methods
on arrays is an economical use of the available store. This implies
that the permutation of items which brings the items into order has
to be performed <i>in situ</i>, and that methods which transport
items from an array a to a result array b are intrinsically of
minor interest. Having thus restricted our choice of methods among
the many possible solutions by the criterion of economy of storage,
we proceed to a first classification according to their efficiency,
i.e., their economy of time. A good measure of efficiency is
obtained by counting the numbers <code>C</code> of
needed key comparisons and <code>M</code> of moves
(transpositions) of items. These numbers are functions of the
number <code>n</code> of items to be sorted. Whereas
good sorting algorithms require in the order of
<code>n*log(n)</code> comparisons, we first discuss several simple
and obvious sorting techniques, called <i>straight</i> methods, all
of which require in the order <code>n<sup>2</sup></code>
comparisons of keys. There are three good reasons
for presenting straight methods before proceeding to the faster
algorithms.</p>

<ol class="noindent" id="l39">
<li data-list-text="1.">
<p>Straight methods are particularly well suited for elucidating the
characteristics of the major sorting principles.</p>
</li>
<li data-list-text="2.">
<p>Their programs are easy to understand and are short. Remember that
programs occupy storage as well!</p>
</li>
<li data-list-text="3.">
<p>Although sophisticated methods require fewer operations, these
operations are usually more complex in their details; consequently,
straight methods are faster for sufficiently small <code>n</code>,
although they must not be used for large <code>n</code>.</p>
</li>
</ol>

<p>Sorting methods that sort items <i>in situ</i> can be classified
into three principal categories according to their underlying
method:</p>

<p>Sorting by insertion<br/>
Sorting by selection<br/>
Sorting by exchange</p>

<p>These three pinciples will now be examined and compared. The
procedures operate on a global variable <code>a</code>
whose components are to be sorted <i>in situ</i>, i.e. without
requiring additional, temporary storage. The components are the
keys themselves. We discard other data represented by the record
type <code>Item</code>, thereby simplifying matters. In
all algorithms to be developed in this chapter, we will assume the
presence of an array <code>a</code> and a constant
<code>n</code>, the number of elements of <code>a</code>:</p>

<code class='large'>TYPE Item = INTEGER;
VAR a: ARRAY n OF Item</code>

<ol class="page" id="l40">
<li data-list-text="2.2.1" id="2.2.1">
<h4>Sorting by Straight Insertion</h4>

<p>This method is widely used by card players. The
items (cards) are conceptually divided into a destination
sequence <code>a<sub>0</sub> ... a<sub>i-1</sub></code>
and a source sequence
<code>a<sub>i</sub> ... a<sub>n-1</sub></code>.
In each step, starting
with <code>i = 1</code> and incrementing <code>i</code>
by unity, the <code>i</code>th element of
the source sequence is picked and transferred into the destination
sequence by inserting it at the appropriate place. The process of
sorting by insertion is shown in an example of eight numbers chosen
at random (see Table 2.1).</p>

<div class='table'><table>
<tr>
<td>Initial keys</td><td>44</td><td><b>55</b></td><td>12</td><td>42</td><td>94</td><td>18</td><td>06</td><td>67</td></tr>
<tr>
<td>i=1</td><td>44</td><td><u>55</u></td><td><b>12</b></td><td>42</td><td>94</td><td>18</td><td>06</td><td>67</td></tr>
<tr>
<td>i=2</td><td><u>12</u></td><td>44</td><td>55</td><td><b>42</b></td><td>94</td><td>18</td><td>06</td><td>67</td></tr>
<tr>
<td>i=3</td><td>12</td><td><u>42</u></td><td>44</td><td>55</td><td><b>94</b></td><td>18</td><td>06</td><td>67</td></tr>
<tr>
<td>i=4</td><td>12</td><td>42</td><td>44</td><td>55</td><td><u>94</u></td><td><b>18</b></td><td>06</td><td>67</td></tr>
<tr>
<td>i=5</td><td>12</td><td><u>18</u></td><td>42</td><td>44</td><td>55</td><td>94</td><td><b>06</b></td><td>67</td></tr>
<tr>
<td>i=6</td><td><u>06</u></td><td>12</td><td>18</td><td>42</td><td>44</td><td>55</td><td>94</td><td><b>67</b></td></tr>
<tr>
<td>i=7</td><td>06</td><td>12</td><td>18</td><td>42</td><td>44</td><td>55</td><td><u>67</u></td><td>94</td></tr>
</table></div>
<p>Table 2.1. A Sample Process of Straight Insertion Sorting. The
algorithm of straight insertion is</p>

<code class='large'>FOR i := 1 TO n-1 DO
  x := a[i];
  <code class='pseudo'>insert x at the appropriate place in a<sub>0</sub> ... a<sub>i-1</sub></code>
END</code>

<p>In the process of actually finding the appropriate place, it is
convenient to alternate between comparisons and moves, i.e., to let
<code>x</code> sift down by comparing <code>x</code> with the next item <code>a<sub>j</sub></code>, and either inserting
<code>x</code> or moving <code>a<sub>j</sub></code> to the right and proceeding
to the left. We note that there are two distinct conditions that
may cause the termination of the sifting down process:</p>
<ol class="noindent" id="l41">
<li data-list-text="1.">
<p>An item <code>a<sub>j</sub></code> is
found with a key less than the key of <code>x</code>.</p>
</li>
<li data-list-text="2.">
<p>The left end of the destination sequence is reached.</p>
</li>
</ol>

<code class='large'>PROCEDURE StraightInsertion; <span>(*ADenS2_Sorts *)</span>
  VAR i, j: INTEGER; x: Item;
BEGIN
  FOR i := 1 TO n-1 DO
    x := a[i]; j := i;
    WHILE (j &gt; 0) &amp; (x &lt; a[j-1]) DO
      a[j] := a[j-1]; DEC(j)
    END;
    a[j] := x
  END
END StraightInsertion</code>

<p><i>Analysis of straight insertion.</i>
The number <code>C<sub>i</sub></code>
of key comparisons in the <code>i</code>-th
sift is at most <code>i-1</code>, at least 1, and
— assuming that all permutations of the <code>n</code>
keys are equally probable — <code>i/2</code> in the
average. The number <code>M<sub>i</sub></code>
of moves (assignments of items) is <code>C<sub>i</sub> + 1</code>. ).
Therefore, the total numbers of comparisons and moves are</p>

<div class='table'><table>
<tr><td>C<sub>min</sub> = n - 1</td>
  <td>M<sub>min</sub> = 2*(n - 1)</td></tr>
<tr><td>C<sub>ave</sub> = (n<sup>2</sup> - n)/4</td>
  <td>M<sub>ave</sub> = (n<sup>2</sup> + 3n - 4)/4</td></tr>
<tr><td>C<sub>max</sub> = (n<sup>2</sup> - 3n + 2)/2</td>
  <td>M<sub>max</sub> = (n<sup>2</sup> - n)/2</td></tr>
</table></div>

<p>The minimal numbers occur if the items are initially in order; the
worst case occurs if the items are initially in reverse order. In
this sense, sorting by insertion exhibits a truly natural behavior.
It is plain that the given algorithm also describes a stable
sorting process: it leaves the order of items with equal keys
unchanged.</p>

<p>The algorithm of straight insertion is easily improved by noting
that the destination sequence
<code>a<sub>0</sub></code> <code>... a<sub>i-1</sub></code>,
in which the new item has to be inserted, is
already ordered. Therefore, a faster method of determining the
insertion point can be used. The obvious choice is a binary search
that samples the destination sequence in the middle and continues
bisecting until the insertion point is found. The modified sorting
algorithm is called <i>binary insertion</i>.</p>

<code class='large'>PROCEDURE BinaryInsertion; <span>(* ADenS2_Sorts *)</span>
  VAR i, j, m, L, R: INTEGER; x: Item;
BEGIN
  FOR i := 1 TO n-1 DO
    x := a[i]; L := 0; R := i;
    WHILE L &lt; R DO
      m := (L+R) DIV 2;
      IF a[m] &lt;= x THEN L := m+1 ELSE R := m END
    END;
    FOR j := i TO R+1 BY -1 DO a[j] := a[j-1] END;
    a[R] := x
  END
END BinaryInsertion</code>

<p><i><b>Analysis of binary insertion.</b></i> The insertion position
is found if <code>L = R</code>. Thus, the search
interval must in the end be of length 1; and this involves halving
the interval of length <code>i log(i)</code> times.
Thus,</p>
<code class='large'>C = <b>S</b>i: 0 ≤ i ≤ n-1: ⌈log(i)⌉</code>

<p>We approximate this sum by the integral</p>
<code class='large'>Integral (0:n-1) log(x) dx = n*(log(n) - c) + c</code>
<p>where <code>c = log(e) = 1/ln(2) = 1.44269... </code>.</p>
<p>The number of comparisons is essentially independent of the initial
order of the items. However, because of the truncating character of
the division involved in bisecting the search interval, the true
number of comparisons needed with <code>i</code> items
may be up to 1 higher than expected. The nature of this bias is
such that insertion positions at the low end are on the average
located slightly faster than those at the high end, thereby
favoring those cases in which the items are originally highly out
of order. In fact, the minimum number of comparisons is needed if
the items are initially in reverse order and the maximum if they
are already in order. Hence, this is a case of unnatural behavior
of a sorting algorithm. The number of comparisons is then
approximately</p>

<code class='large'>C ≈ n*(log(n) - log(e) ± 0.5)</code>

<p>Unfortunately, the improvement obtained by using a binary search
method applies only to the number of comparisons but not to the
number of necessary moves. In fact, since moving items, i.e., keys
and associated information, is in general considerably more
time-consuming than comparing two keys, the improvement
is by no means drastic: the important term <code>M</code>
is still of the order <code>n<sup>2</sup></code>. And, in fact, sorting the
already sorted array takes more time than does straight insertion
with sequential search.</p>

<p>This example demonstrates that an "obvious improvement" often has
much less drastic consequences than one is first inclined to
estimate and that in some cases (that do occur) the "improvement"
may actually turn out to be a deterioration. After all, sorting by
insertion does not appear to be a very suitable method for digital
computers: insertion of an item with the subsequent shifting of an
entire row of items by a single position is uneconomical. One
should expect better results from a method in which moves of items
are only performed upon single items and over longer distances.
This idea leads to sorting by selection.</p>
</li>

<li data-list-text="2.2.2" id="2.2.2">
<h4><a href='#2.2.2'>Sorting by Straight Selection</a></h4>

<p>This method is based on the following principle:</p>
<ol id="l42">
<li data-list-text="1.">
  Select the item with the least key.
</li>
<li data-list-text="2.">
  Exchange it with the first item <code>a<sub>0</sub></code>.</p>
</li>
<li data-list-text="3.">
Then repeat these operations with the remaining <code>n-1</code>
items, then with <code>n-2</code> items,
until only one item — the largest — is left.
</li>
</ol>

<p>This method is shown on the same eight keys as in Table 2.1.</p>

<div class='table'><table>
  <caption>Table 2.2. A Sample Process of Straight Selection Sorting.</caption>

<tr>
<td>Initial keys</td>
            <td><u>44</u></td><td>55</td><td>12</td><td>42</td><td>94</td><td>18</td><td><b>06</b></td><td>67</td>
</tr>
<tr>
<td>i=1</td><td>06</td><td><u>55</u></td><td><b>12</b></td><td>42</td><td>94</td><td>18</td><td>44</td><td>67</td>
</tr>
<tr>
<td>i=2</td><td>06</td><td>12</td><td><u>55</u></td><td>42</td><td>94</td><td><b>18</b></td><td>44</td><td>67</td>
</tr>
<tr>
<td>i=3</td><td>06</td><td>12</td><td>18</td><td><u><b>42</b></u></td><td>94</td><td>55</td><td>44</td><td>67</td></tr>
<tr>
<td>i=4</td><td>06</td><td>12</td><td>18</td><td>42</td><td><u>94</u></td><td>55</td><td><b>44</b></td><td>67</td></tr>
<tr>
<td>i=5</td><td>06</td><td>12</td><td>18</td><td>42</td><td>44</td><td><u><b>55</b></u></td><td>94</td><td>67</td></tr>
<tr>
<td>i=6</td><td>06</td><td>12</td><td>18</td><td>42</td><td>44</td><td>55</td><td><u>94</u></td><td><b>67</b></td></tr>
<tr>
<td>i=7</td><td>06</td><td>12</td><td>18</td><td>42</td><td>44</td><td>55</td><td>67</td><td>94</td></tr>
</table></div>

<p>The algorithm is formulated as follows:</p>
<code class='large'>FOR i := 0 TO n-1 DO
  <code class='pseudo'>assign the index of the least item of a<sub>i</sub> ... a<sub>n-1</sub> to k;
  exchange a<sub>i</sub> with a<sub>k</sub></code>
END</code>

<p>This method, called <i>straight selection</i>, is in some sense the
opposite of straight insertion: Straight insertion considers in
each step only the one next item of the source sequence and all
items of the destination array to find the insertion point;
straight selection considers all items of the source array to find
the one with the least key and to be deposited as the one next item
of the destination sequence.</p>

<code class='large'>PROCEDURE StraightSelection; <span>(* ADenS2_Sorts *)</span>
VAR i, j, k: INTEGER; x: Item;
BEGIN
  FOR i := 0 TO n-2 DO
    k := i; x := a[i];
    FOR j := i+1 TO n-1 DO
      IF a[j] &lt; x THEN k := j; x := a[k] END
    END;
    a[k] := a[i]; a[i] := x
  END
END StraightSelection</code>

<p><i><b>Analysis of straight selection.</b></i> Evidently, the number
<code>C</code> of key comparisons is independent of the
initial order of keys. In this sense, this method may be said to
behave less naturally than straight insertion. We obtain</p>
<code>  C = (n<sup>2</sup> - n)/2</code>
<p>The number <code>M</code> of moves is at least</p>
<code>  M<sub>min</sub> = 3*(n - 1)</code>
<p>in the case of initially ordered keys and at most</p>
<code>  M<sub>max</sub> = n<sup>2</sup>/4 + 3*(n - 1),</code>

<p>if initially the keys are in reverse order. In order to determine
<code>M<sub>avg</sub></code> we make the
following deliberations: The algorithm scans the array, comparing
each element with the minimal value so far detected and, if smaller
than that minimum, performs an assignment. The probability that the
second element is less than the first, is 1/2; this is also the
probability for a new assignment to the minimum. The chance for the
third element to be less than the first two is 1/3, and the chance
of the fourth to be the smallest is 1/4, and so on. Therefore the
total expected number of moves is <code>H<sub>n-1</sub></code>,
where <code>H<sub>n</sub></code> is the <code>n</code>-th harmonic number</p>

<p><code>H<sub>n</sub> = 1 + 1/2 + 1/3 + ... + 1/n</code></p>
<p><code>H<sub>n</sub></code> can be expressed as</p>
<code class='large'>H<sub>n</sub> = ln(n) + g + 1/2n - 1/12n<sup>2</sup> + ...</code>

<p>where <code>g = 0.577216...</code> is Euler's constant.
For sufficiently large <code>n</code>, we may ignore the
fractional terms and therefore approximate the average number of
assignments in the <code>i</code>-th pass as</p>
<code>F<sub>i</sub> = ln(i) + g + 1</code>

<p>The average number of moves <code>M<sub>avg</sub></code>
in a selection sort is then the
sum of <code>F<sub>i</sub></code> with <code>i</code>
ranging from 1 to <code>n</code>:</p>
<code class='large'>M<sub>avg</sub> = n*(g+1) + (<b>S</b>i: 1 ≤ i ≤ n: ln(i))</code>
<p>By further approximating the sum of discrete terms by the integral</p>
<code class='large'>Integral (1:n) ln(x) dx = n * ln(n) - n + 1</code>
<p>we obtain an approximate value</p>
<code class='large'>M<sub>avg</sub> = n * (ln(n) + g)</code>

<p>We may conclude that in general the algorithm of straight selection
is to be preferred over straight insertion, although in the cases
in which keys are initially sorted or almost sorted, straight
insertion is still somewhat faster.</p>
</li>

<li data-list-text="2.2.3" id="2.2.3">
<h4><a href='#2.2.3'>Sorting by Straight Exchange</a></h4>

<p>The classification of a sorting method is seldom entirely
clear-cut. Both previously discussed methods can also be viewed as
exchange sorts. In this section, however, we present a method in
which the exchange of two items is the dominant characteristic of
the process. The subsequent algorithm of straight exchanging is
based on the principle of comparing and exchanging pairs of
adjacent items until all items are sorted.</p>

<p>As in the previous methods of straight selection, we make repeated
passes over the array, each time sifting the least item of the
remaining set to the left end of the array. If, for a change, we
view the array to be in a vertical instead of a horizontal
position, and - with the help of some imagination - the items as
bubbles in a water tank with weights according to their keys, then
each pass over the array results in the ascension of a bubble to
its appropriate level of weight (see Table 2.3). This method is
widely known as the <i>Bubblesort</i>.</p>

<div class='table'><table>
<tr>
<td>i =</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr>
<tr><td></td>
<td>44</td><td><u>06</u></td><td>06</td><td>06</td><td>06</td><td>06</td><td>06</td><td>06</td></tr>
<tr><td></td>
<td>55</td><td>44</td><td><u>12</u></td><td>12</td><td>12</td><td>12</td><td>12</td><td>12</td></tr>
<tr><td></td>
<td>12</td><td>55</td><td>44</td><td><u>18</u></td><td>18</td><td>18</td><td>18</td><td>18</td></tr>
<tr><td></td>
<td>42</td><td><b>12</b></td><td>55</td><td>44</td><td><u>42</u></td><td>42</td><td>42</td><td>42</td></tr>
<tr><td></td>
<td>94</td><td>42</td><td><b><u>18</u></b></td><td>55</td><td>44</td><td>44</td><td>44</td><td>44</td></tr>
<tr><td></td>
<td>18</td><td>94</td><td>42</td><td><b>42</b></td><td>55</td><td>55</td><td>55</td><td>55</td></tr>
<tr><td></td>
<td><b>06</b></td><td><b>18</b></td><td>94</td><td><u>67</u></td><td>67</td><td>67</td><td>67</td><td>67</td></tr>
<tr><td></td>
<td>67</td><td>67</td><td><b>67</b></td><td>94</td><td>94</td><td>94</td><td>94</td><td>94</td></tr>
</table></div>

<p>Table 2.3. A Sample of Bubblesorting.</p>

<code class='large'>PROCEDURE BubbleSort; <span >(* ADenS2_Sorts *)</span>
  VAR i, j: INTEGER; x: Item;
BEGIN
  FOR i := 1 TO n-1 DO
    FOR j := n-1 TO i BY -1 DO
      IF a[j-1] &gt; a[j] THEN
        x := a[j-1]; a[j-1] := a[j]; a[j] := x
      END
    END
  END
END BubbleSort</code>

<p>This algorithm easily lends itself to some improvements. The
example in Table 2.3 shows that the last three passes have no
effect on the order of the items because the items are already
sorted. An obvious technique for improving this algorithm is to
remember whether or not any exchange had taken place during a pass.
A last pass without further exchange operations is therefore
necessary to determine that the algorithm may be terminated.
However, this improvement may itself be improved by remembering not
merely the fact that an exchange took place, but rather the
position (index) of the last exchange. For example, it is plain
that all pairs of adjacent items below this index
<code>k</code> are in the desired order. Subsequent scans may
therefore be terminated at this index instead of having to proceed
to the predetermined lower limit <code>i</code>. The
careful programmer notices, however, a peculiar asymmetry: A single
misplaced bubble in the heavy end of an otherwise sorted array will
sift into order in a single pass, but a misplaced item in the light
end will sink towards its correct position only one step in each
pass. For example, the array</p>

<code>12 18 42 44 55 67 94 06</code>
<p>is sorted by the improved Bubblesort in a single pass, but the array</p>
<code>94 06 12 18 42 44 55 67</code>

<p>requires seven passes for sorting. This unnatural asymmetry
suggests a third improvement: alternating the direction of
consecutive passes. We appropriately call the resulting algorithm
<i>Shakersort</i>. Its behavior is illustrated in Table 2.4 by
applying it to the same eight keys that were used in Table 2.3.</p>

<code class='large'>PROCEDURE ShakerSort; <span>(* ADenS2_Sorts *)</span>
  VAR j, k, L, R: INTEGER; x: Item;
BEGIN
  L := 1; R := n-1; k := R;
  REPEAT
    FOR j := R TO L BY -1 DO
      IF a[j-1] &gt; a[j] THEN
        x := a[j-1]; a[j-1] := a[j]; a[j] := x; k := j
      END
    END;
    L := k+1;
    FOR j := L TO R BY +1 DO
      IF a[j-1] &gt; a[j] THEN
        x := a[j-1]; a[j-1] := a[j]; a[j] := x; k := j
      END
    END;
    R := k-1
  UNTIL L &gt; R
END ShakerSort</code>

<div class='table'><table>
<tr>
<td>L = </td><td>2</td><td>3</td><td>3</td><td>4</td><td>4</td></tr>
<tr>
<td>R = </td><td>8</td><td>8</td><td>7</td><td>7</td><td>4</td></tr>
<tr>
<td>dir = </td><td>↑</td><td>↓</td><td>↑</td><td>↓</td><td>↑</td></tr>
<tr>
<td></td><td>44</td><td><u>06</u></td><td>06</td><td>06</td><td>06</td></tr>
<tr>
<td></td><td>55</td><td>44</td><td>44</td><td><u>12</u></td><td>12</td></tr>
<tr>
<td></td><td>12</td><td><b>55</b></td><td><b>12</b></td><td><b>44</b></td><td>18</td></tr>
<tr>
<td></td><td>42</td><td>12</td><td>42</td><td><u>18</u></td><td>42</td></tr>
<tr>
<td></td><td>94</td><td>42</td><td><u>55</u></td><td>42</td><td><u>44</u></td></tr>
<tr>
<td></td><td>18</td><td><b>94</b></td><td><b>18</b></td><td>55</td><td>55</td></tr>
<tr>
<td></td><td><b>06</b></td><td>18</td><td>67</td><td>67</td><td>67</td></tr>
<tr>
<td></td><td>67</td><td>67</td><td><u>94</u></td><td>94</td><td>94</td></tr>
</table></div>
<p>Table 2.4. An Example of Shakersort.</p>

<p><i>Analysis of Bubblesort and Shakersort.</i> The number
of comparisons in the straight exchange algorithm is</p>
<code>C = (n<sup>2</sup> - n)/2</code>,
<p>and the minimum, average, and maximum numbers of moves
(assignments of items) are</p>
<code class='large'>M<sub>min</sub> = 0,    M<sub>avg</sub> = 3*(n<sup>2</sup> - n)/2,    M<sub>max</sub> = 3*(n<sup>2</sup> - n)/4.</code>

<p>The analysis of the improved methods, particularly
that of Shakersort, is intricate. The least number of comparisons
is <code>C<sub>min</sub> = n-1</code>. For
the improved Bubblesort, Knuth arrives at an average number of
passes proportional to <code>n - k<sub>1</sub>*n<sup>1/2</sup></code>, and
an average number of comparisons proportional
<code>(n<sup>2</sup> – n*(k<sub>2</sub> + ln(n)))/2</code>.
But we note that all improvements
mentioned above do in no way affect the number of exchanges; they
only reduce the number of redundant double checks. Unfortunately,
an exchange of two items is generally a more costly operation than
a comparison of keys; our clever improvements therefore have a much
less profound effect than one would intuitively expect.</p>

<p>This analysis shows that the exchange sort and its minor
improvements are inferior to both the insertion and the selection
sorts; and in fact, the Bubblesort has hardly anything to recommend
it except its catchy name. The Shakersort algorithm is used with
advantage in those cases in which it is known that the items are
already almost in order - a rare case in practice.</p>

<p>It can be shown that the average distance that each of the
<code>n</code> items has to travel during a sort is
<code>n/3</code> places. This figure provides a clue in
the search for improved, i.e. more effective sorting methods. All
straight sorting methods essentially move each item by one position
in each elementary step. Therefore, they are bound to require in
the order <code>n<sup>2</sup></code> such
steps. Any improvement must be based on the principle of moving
items over greater distances in single leaps.</p>

<p>Subsequently, three improved methods will be discussed, namely, one
for each basic sorting method: insertion, selection, and
exchange.</p>

</li>
</ol>
</li>

<li data-list-text="2.3" id="2.3">
<h3><a href='#2.3'>Advanced Sorting Methods</a></h3>
<ol class="page" id="l43">
<li data-list-text="2.3.1" id="2.3.1">
<h4><a href='#2.3.1'>Insertion Sort by Diminishing Increment</a></h4>

<p>A refinement of the straight insertion sort was proposed by D. L.
Shell in l959. The method is explained and demonstrated on our
standard example of eight items (see Table 2.5). First, all items
that are four positions apart are grouped and sorted separately.
This process is called a 4-sort. In this example of eight items,
each group contains exactly two items. After this first pass, the
items are regrouped into groups with items two positions apart and
then sorted anew. This process is called a 2-sort. Finally, in a
third pass, all items are sorted in an ordinary sort or 1-sort.</p>

<div class='table'><table>
<tr>
<td></td>
<td>44</td><td>55</td><td>12</td><td>42</td><td>94</td><td>18</td><td>06</td><td>67</td></tr>
<tr>
<td>4-sort yields</td><td>44</td><td>18</td><td>06</td><td>42</td><td>94</td><td>55</td><td>12</td><td>67</td></tr>
<tr>
<td>2-sort yields</td><td>06</td><td>18</td><td>12</td><td>42</td><td>44</td><td>55</td><td>94</td><td>67</td></tr>
<tr>
<td>1-sort yields</td><td>06</td><td>12</td><td>18</td><td>42</td><td>44</td><td>55</td><td>67</td><td>94</td></tr>
</table></div>

<p>Table 2.5. An Insertion Sort with Diminishing Increments.</p>

<p>One may at first wonder if the necessity of several sorting passes,
each of which involves all items, does not introduce more work than
it saves. However, each sorting step over a chain either involves
relatively few items or the items are already quite well ordered
and comparatively few rearrangements are required.</p>

<p>It is obvious that the method results in an ordered array, and it
is fairly obvious that each pass profits from previous passes
(since each i-sort combines two groups sorted in the preceding
<code>2i</code>-sort). It is also obvious that any
sequence of increments is acceptable, as long as the last one is
unity, because in the worst case the last pass does all the work.
It is, however, much less obvious that the method of diminishing
increments yields even better results with increments other than
powers of 2.</p>

<p>The procedure is therefore developed without relying on a specific
sequence of increments. The <code>T</code></p>

<p>increments are denoted by
<code>h<sub>0</sub>, h<sub>1</sub>, ... , h<sub>T-1</sub></code>
with the conditions</p>
<code>h<sub>T-1</sub> = 1, h<sub>i+1</sub> &lt; h<sub>i</sub></code>

<p>The algorithm is described by the procedure
Shellsort <a href="#[2.11]">[2.11]</a> for <code>T = 4</code>:</p>

<code class='large'>PROCEDURE ShellSort; <span>(* ADenS2_Sorts*)</span>
  CONST T = 4;
  VAR i, j, k, m, s: INTEGER;
    x: Item;
    h: ARRAY T OF INTEGER;
BEGIN
  h[0] := 9; h[1] := 5; h[2] := 3; h[3] := 1;
  FOR m := 0 TO T-1 DO
    k := h[m];
    FOR i := k TO n-1 DO
      x := a[i]; j := i-k;
      WHILE (j &gt;= k) &amp; (x &lt; a[j]) DO
        a[j+k] := a[j]; j := j-k
      END;
      IF (j &gt;= k) OR (x &gt;= a[j]) THEN
        a[j+k] := x
      ELSE
        a[j+k] := a[j];
        a[j] := x
      END
    END
  END
END ShellSort</code>

<p><i><b>Analysis of Shellsort.</b></i> The analysis of this algorithm
poses some very difficult mathematical problems, many of which have
not yet been solved. In particular, it is not known which choice of
increments yields the best results. One surprising fact, however,
is that they should not be multiples of each other. This will avoid
the phenomenon evident from the example given above in which each
sorting pass combines two chains that before had no interaction
whatsoever. It is indeed desirable that interaction between various
chains takes place as often as possible, and the following theorem
holds: If a <code>k</code>-sorted sequence is
<code>i</code>-sorted, then it remains <code>k</code>-sorted.
Knuth <a href='#[2.8]'>[2.8]</a> indicates evidence that a
reasonable choice of increments is the sequence
(written in reverse order)</p>
<code>1, 4, 13, 40, 121, ...</code>
<p>where
<code>h<sub>k-1</sub> = 3h<sub>k</sub>+1, h<sub>T</sub> = 1</code>,
and <code>T = k×⌊log<sub>3</sub>(n)⌋ - 1</code>.
He also recommends the sequence</p>
<code>1, 3, 7, 15, 31, ...</code>
<p>where
<code>h<sub>k-1</sub> = 2h<sub>k</sub>+1, h<sub>T</sub> = 1</code>,
and
<code>T = k × ⌊log<sub>2</sub>(n)⌋ - 1</code>.
For the latter choice, mathematical analysis
yields an effort proportional to
<code>n<sup>1.2</sup></code>
required for sorting <code>n</code> items
with the Shellsort algorithm. Although this is a significant
improvement over <code>n<sup>2</sup></code>,
we will not expound further on this
method, since even better algorithms are known.</p>

</li>

<li data-list-text="2.3.2" id="2.3.2">
<h4><a href='#2.3.2'>Tree Sort</a></h4>

<p>The method of sorting by straight selection is
based on the repeated selection of the least key among <code>n</code>
items, then among the remaining <code>n-1</code>
items, etc. Clearly, finding the least key
among <code>n</code> items requires <code>n-1</code>
comparisons, finding it among <code>n-1</code>
items needs <code>n-2</code> comparisons,
etc., and the sum of the first <code>n-1</code> integers
is <code>(n<sup>2</sup>-n)/2</code>. So how
can this selection sort possibly be improved? It can be improved
only by retaining from each scan more information than just the
identification of the single least item. For instance, with
<code>n/2</code> comparisons it is possible to determine the
smaller key of each pair of items, with another <code>n/4</code>
comparisons the smaller of each pair of such
smaller keys can be selected, and so on. With only <code>n-1</code>
comparisons, we can construct a selection tree as
shown in Fig. 2.3. and identify the root as the desired least key
<a href='#[2.2]'>[2.2]</a>.</p>

<img src="fig/2.3.png" width="700"/>
<p>Fig. 2.3. Repeated selection among two keys</p>

<p>The second step now consists of descending down along the path
marked by the least key and eliminating it by successively
replacing it by either an empty hole at the bottom, or by the item
at the alternative branch at intermediate nodes (see Figs. 2.4 and
2.5). Again, the item emerging at the root of the tree has the (now
second) smallest key and can be eliminated. After <code>n</code>
such selection steps, the tree is empty (i.e., full
of holes), and the sorting process is terminated. It should be
noted that each of the <code>n</code> selection steps
requires only <code>log(n)</code> comparisons.
Therefore, the total selection process requires only on the order
of <code>n*log(n)</code> elementary operations in
addition to the <code>n</code> steps required by the
construction of the tree. This is a very significant improvement
over the straight methods requiring <code>n<sup>2</sup></code>
steps, and even over Shellsort that requires <code>n<sup>1.2</sup></code>
steps. Naturally, the task of bookkeeping has
become more elaborate, and therefore the complexity of individual
steps is greater in the tree sort method; after all, in order to
retain the increased amount of information gained from the initial
pass, some sort of tree structure has to be created. Our next task
is to find methods of organizing this information efficiently.</p>

<img src="fig/2.4.png" width="700"/>
<p>Fig. 2.4. Selecting the least key</p>

<img src="fig/2.5.png" width="700"/>
<p>Fig. 2.5. Refilling the holes</p>

<p>Of course, it would seem particularly desirable to
eliminate the need for the holes that in the end populate the
entire tree and are the source of many unnecessary comparisons.
Moreover, a way should be found to represent the tree of n items in
n units of storage, instead of in 2n - 1 units as shown above.
These goals are indeed achieved by a method called Heapsort by its
inventor J. Williams [2-14]; it is plain that this method
represents a drastic improvement over more conventional tree
sorting approaches. A heap is defined as a sequence of keys
<code>h<sub>L</sub>, h<sub>L+1</sub>, ... , h<sub>R</sub> (L ≥ 0)</code>
such that</p>
<code>h<sub>i</sub> &lt; h<sub>2i+1</sub> </code>
and
<code> h<sub>i</sub> &lt; h<sub>2i+2</sub></code>
for
<code>i = L ... R/2-1</code>.

<p>If a binary tree is represented as an array as
shown in Fig. 2.6, then it follows that the sort trees in Figs. 2.7
and 2.8 are heaps, and in particular that the element
<code>h<sub>0</sub></code>
of a heap is its least element:</p>
<p><code>h<sub>0</sub> = min(h<sub>0</sub>, h<sub>1</sub>, ... , h<sub>n-1</sub>)</code></p>

<img src="fig/2.6.png" width="700"/>
<p>Fig. 2.6. Array viewed as a binary tree</p>

<img src="fig/2.7.png" width="600"/>
<p>Fig. 2.7. Heap with 7 elements</p>

<img src="fig/2.8.png" width="500"/>
<p>Fig. 2.8. Key 44 sifting through the heap</p>

<p>Let us now assume that a heap with elements
<code>h<sub>L+1</sub> ... h<sub>R</sub></code>
is given for some values <code>L</code> and <code>R</code>,
and that a new element <code>x</code>
has to be added to form the extended heap
<code>h<sub>L</sub> ... h<sub>R</sub></code>.
Take, for example, the initial heap
<code>h<sub>1</sub> ... h<sub>7</sub></code>
shown in Fig. 2.7
and extend the heap to the left by an element
<code>h<sub>0</sub> = 44</code>.
A new heap is obtained by
first putting <code>x</code> on top of the tree structure
and then by letting it sift down along the path of the smaller
comparands, which at the same time move up. In the given example
the value 44 is first exchanged with 06, then with 12, and thus
forming the tree shown in Fig. 2.8. We now formulate this sifting
algorithm as follows: <code>i, j</code> are the pair of
indices denoting the items to be exchanged during each sift step.
The reader is urged to convince himself that the proposed method of
sifting actually preserves the heap invariants that define a
heap.</p>

<p>A neat way to construct a heap <i>in situ</i> was suggested by R. W. Floyd.
It uses the sifting procedure shown below. Given is an array
<code>h<sub>0</sub> ... h<sub>n-1</sub></code>;
clearly, the elements
<code>h<sub>m</sub> ... h<sub>n-1</sub></code>
(with <code>m = n DIV 2</code>) form a
heap already, since no two indices <code>i</code>,
<code>j</code> are such that <code>j = 2i+1</code>
or <code>j = 2i+2</code>. These elements form what
may be considered as the bottom row of the associated binary tree
(see Fig. 2.6) among which no ordering relationship is required.
The heap is now extended to the left, whereby in each step a new
element is included and properly positioned by a sift. This process
is illustrated in Table 2.6 and yields the heap shown in Fig.2.6.</p>

<code class='large'>PROCEDURE sift (L, R: INTEGER);
  VAR i, j: INTEGER; x: Item;
BEGIN
  i := L; j := 2*i+1; x := a[i];
  IF (j &lt; R) &amp; (a[j+1] &lt; a[j]) THEN j := j+1 END;
  WHILE (j &lt;= R) &amp; (a[j] &lt; x) DO
    a[i] := a[j]; i := j; j := 2*j + 1;
    IF (j &lt; R) &amp; (a[j+1] &lt; a[j]) THEN j := j+1 END
  END;
  a[i] := x
END sift</code>
<br/><br/>

<div class='table'><table>
<tr>
<td>44</td><td></td><td>55</td><td></td><td>12</td><td></td><td>42</td><td><b>|</b></td><td>94</td><td></td><td>18</td><td></td><td>06</td><td></td><td>67</td></tr>
<tr>
<td>44</td><td></td><td>55</td><td></td><td>12</td><td><b>|</b></td><td>42</td><td></td><td>94</td><td></td><td>18</td><td></td><td>06</td><td></td><td>67</td></tr>
<tr>
<td>44</td><td></td><td>55</td><td><b>|</b></td><td><u>06</u></td><td></td><td>42</td><td></td><td>94</td><td></td><td>18</td><td></td><td><u>12</u></td><td></td><td>67</td></tr>
<tr>
<td>44</td><td><b>|</b></td><td><u>42</u></td><td></td><td>06</td><td></td><td><u>55</u></td><td></td><td>94</td><td></td><td>18</td><td></td><td>12</td><td></td><td>67</td></tr>
<tr>
<td><u>06</u></td><td></td><td>42</td><td></td><td><u>12</u></td><td></td><td>55</td><td></td><td>94</td><td></td><td>18</td><td></td><td><u>44</u></td><td></td><td>67</td></tr>
</table></div>

<p>Table 2.6. Constructing a Heap.</p>

<p>Consequently, the process of generating a heap
of <code>n</code> elements
<code>h<sub>0</sub> ... h<sub>n-1</sub></code> <i>in situ</i>
is described as follows:</p>
<code class='large'>L := n DIV 2;
WHILE L &gt; 0 DO DEC(L); sift(L, n-1) END</code>

<p>In order to obtain not only a partial,
but a full ordering among the
elements, n sift steps have to follow, whereby after
each step the next (least) item may be picked off the
top of the heap. Once more, the question arises about where to
store the emerging top elements and whether or not an in situ sort
would be possible. Of course there is such a solution: In each step
take the last component (say <code>x</code>) off the
heap, store the top element of the heap in the now free location of
<code>x</code>, and let <code>x</code> sift
down into its proper position. The necessary <code>n-1</code>
steps are illustrated on the heap of Table 2.7. The
process is described with the aid of the procedure
<code>sift</code> as follows:</p>
<code class='large'>R := n-1;
WHILE R &gt; 0 DO
  x := a[0]; a[0] := a[R]; a[R] := x; DEC(R); sift(1, R)
END</code>
<br/><br/>

<div class='table'><table>
<tr><td>06</td><td></td><td>42</td><td></td><td>12</td><td></td><td>55</td><td></td><td>94</td><td></td><td>18</td><td></td><td>44</td><td></td><td>67</td></tr>
<tr><td><u>12</u></td><td></td><td>42</td><td></td><td><u>18</u></td><td></td><td>55</td><td></td><td>94</td><td></td><td><u>67</u></td><td></td><td>44</td><td><b>|</b></td><td>06</td></tr>
<tr><td><u>18</u></td><td></td><td>42</td><td></td><td><u>44</u></td><td></td><td>55</td><td></td><td>94</td><td></td><td>67</td><td>| </td><td>12</td></td><td><td>06</td></tr>
<tr><td><u>42</u></td><td></td><td><u>55</u></td><td></td><td>44</td><td></td><td><u>67</u></td><td></td><td>94</td><td><b>|</b></td><td>18</td><td></td><td>12</td><td></td><td>06</td></tr>
<tr><td><u>44</u></td><td></td><td><u>55</u></td><td></td><td>94</td><td></td><td>67</td><td><b>|</b></td><td>42</td><td></td><td>18</td><td></td><td>12</td><td></td><td>06</td></tr>
<tr><td><u>55</u></td><td></td><td><u>67</u></td><td></td><td>94</td><td><b>|</b></td><td>44</td><td></td><td>42</td><td></td><td>18</td><td></td><td>12</td><td></td><td>06</td></tr>
<tr><td>67</td><td></td><td>94</td><td><b>|</b></td><td>55</td><td></td><td>44</td><td></td><td>42</td><td></td><td>18</td><td></td><td>12</td><td></td><td>06</td></tr>
<tr><td>94</td><td><b>|</b></td><td>67</td><td></td><td>55</td><td></td><td>44</td><td></td><td>42</td><td></td><td>18</td><td></td><td>12</td><td></td><td>06</td></tr>
</table></div>

<p>Table 2.7. Example of a <code>HeapSort</code> Process.</p>

<p>The example of Table 2.7 shows that the resulting order is actually
inverted. This, however, can easily be remedied by changing the
direction of the ordering relations in the <code>sift</code>
procedure. This results in the following procedure
<code>HeapSort</code>. (Note that sift should actually
be declared local to <code>HeapSort</code>.)</p>

<code class='large'>PROCEDURE sift (L, R: INTEGER); <span>(*ADenS2_Sorts *)</span>
  VAR i, j: INTEGER; x: Item;
BEGIN
  i := L; j := 2*i+1; x := a[i];
  IF (j &lt; R) &amp; (a[j] &lt; a[j+1]) THEN j := j+1 END;
  WHILE (j &lt;= R) &amp; (x &lt; a[j]) DO
    a[i] := a[j]; i := j; j := 2*j+1;
    IF (j &lt; R) &amp; (a[j] &lt; a[j+1]) THEN j := j+1 END
  END;
  a[i] := x
END sift;

PROCEDURE HeapSort;
  VAR L, R: INTEGER; x: Item;
BEGIN
  L := n DIV 2; R := n-1;
  WHILE L &gt; 0 DO
    DEC(L); sift(L, R)
  END;
  WHILE R &gt; 0 DO
    x := a[0]; a[0] := a[R]; a[R] := x;
    DEC(R); sift(L, R)
  END
END HeapSort</code>

<p><i><b>Analysis of Heapsort.</b></i> At first sight it is not
evident that this method of sorting provides good results. After
all, the large items are first sifted to the left before finally
being deposited at the far right. Indeed, the procedure is not
recommended for small numbers of items, such as shown in the
example. However, for large <code>n</code>, Heapsort is
very efficient, and the larger <code>n</code> is, the
better it becomes — even compared to Shellsort.</p>

<p>In the worst case, there are <code>n/2</code>
sift steps necessary, sifting items through
<code>log(n/2), log(n/2+1), ... , log(n-1)</code> positions,
where the logarithm (to the base 2) is truncated to the next lower
integer. Subsequently, the sorting phase takes <code>n-1</code>
sifts, with at most <code>log(n-1), log(n-2), ..., 1</code>
moves. In addition, there are <code>n-1</code>
moves for stashing the item from the top away at
the right. This argument shows that Heapsort takes of the order
of <code>n × log(n)</code> moves
even in the worst possible case. This excellent worst-case
performance is one of the strongest qualities of
Heapsort.</p>

<p>It is not at all clear in which case the worst (or
the best) performance can be expected. But generally Heapsort seems
to like initial sequences in which the items are more or less
sorted in the inverse order, and therefore it displays an unnatural
behavior. The heap creation phase requires zero moves if the
inverse order is present. The average number of moves is
approximately <code>n/2 × log(n)</code>,
and the deviations from this value are relatively small.</p>
</li>

<li data-list-text="2.3.3" id="2.3.3">
<h4><a href='#2.3.3'>Partition Sort</a></h4>

<p>After having discussed two advanced sorting methods based on the
principles of insertion and selection, we introduce a third
improved method based on the principle of exchange. In view of the
fact that Bubblesort was on the average the least effective of the
three straight sorting algorithms, a relatively significant
improvement factor should be expected. Still, it comes as a
surprise that the improvement based on exchanges to be discussed
subsequently yields the best sorting method on arrays known so far.
Its performance is so spectacular that its inventor, C.A.R. Hoare,
called it Quicksort [<a href='#[2.5]'>2.5</a> and <a href='#[2.6]'>2.6</a>].</p>

<p>Quicksort is based on the recognition that exchanges should
preferably be performed over large distances in order to be most
effective. Assume that <code>n</code> items are given in
reverse order of their keys. It is possible to sort them by
performing only <code>n/2</code> exchanges, first taking
the leftmost and the rightmost and gradually progressing inward
from both sides. Naturally, this is possible only if we know that
their order is exactly inverse. But something might still be
learned from this example.</p>

<p>Let us try the following algorithm: Pick any item
at random (and call it <code>x</code>); scan the array
from the left until an item <code>a<sub>i</sub> &gt; x</code>
is found and then scan from the right until an
item <code>a<sub>j</sub> &lt; x</code> is
found. Now exchange the two items and continue this scan and swap
process until the two scans meet somewhere in the middle of the
array. The result is that the array is now partitioned into a left
part with keys less than (or equal to) <code>x</code>,
and a right part with keys greater than (or equal to)
<code>x</code>. This partitioning process is now formulated in
the form of a procedure. Note that the relations &gt; and &lt; have
been replaced by ≥ and ≤, whose
negations in the while clause are &lt; and &gt;. With this
change <code>x</code> acts as a sentinel for both
scans.</p>

<code class='large'>PROCEDURE partition;
  VAR i, j: INTEGER; w, x: Item;
BEGIN
  i := 0; j := n-1;
  <code class="pseudo">select an item <code>x</code> at random</code>;
  REPEAT
    WHILE a[i] &lt; x DO i := i+1 END;
    WHILE x &lt; a[j] DO j := j-1 END;
    IF i &lt;= j THEN
      w := a[i]; a[i] := a[j]; a[j] := w; i := i+1; j := j-1
    END
  UNTIL i &gt; j
END partition</code>

<p>As an example, if the middle key 42 is selected as comparand
<code>x</code>, then the array of keys</p>
<code>44 55 12 42 94 06 18 67</code>
<p>requires the two exchanges <code>18 ↔ 44</code> and <code>6 ↔ 55</code>
to yield the partitioned array</p>
<code>18 06 12 42 94 55 44 67</code>,
<p>and the final index values <code>i = 4</code>
and <code>j = 2</code>. Keys
<code>a<sub>0</sub> ... a<sub>i-1</sub></code>
are less or equal to key <code>x = 42</code>,
and keys</p>
<code>a<sub>j+1</sub> ... a<sub>n-1</sub></code>
<p>are greater or equal to key <code>x</code>.
Consequently, there are three parts, namely</p>
<code class='large'><b>A</b>k: 1 ≤ k &lt; i :    a<sub>k</sub> ≤ x
<b>A</b>k: i ≤ k ≤ j :    a<sub>k</sub> ? x
<b>A</b>k: j &lt; k ≤ n-1 :  x ≤ a<sub>k</sub></code>

<p>The goal is to increase <code>i</code> and decrease
<code>j</code>, so that the middle part vanishes. This
algorithm is very straightforward and efficient because the
essential comparands <code>i</code>, <code>j</code>
and <code>x</code> can be kept in fast
registers throughout the scan. However, it can also be cumbersome,
as witnessed by the case with <code>n</code> identical
keys, which result in <code>n/2</code> exchanges. These
unnecessary exchanges might easily be eliminated by changing the
scanning statements to</p>

<code class='large'>WHILE a[i] &lt;= x DO i := i+1 END;
WHILE x &lt;= a[j] DO j := j-1 END</code>

<p>In this case, however, the choice element
<code>x</code>, which is present as a member of the array, no
longer acts as a sentinel for the two scans. The array with all
identical keys would cause the scans to go beyond the bounds of the
array unless more complicated termination conditions were used. The
simplicity of the conditions is well worth the extra exchanges that
occur relatively rarely in the average random case. A slight
saving, however, may be achieved by changing the clause controlling
the exchange step to <code>i &lt; j</code> instead
of <code>i ≤ j</code>.
But this change must not be extended over the two statements</p>
<code>i := i+1; j := j-1</code>
<p>which therefore require a separate conditional clause. Confidence
in the correctness of the partition algorithm can be gained by
verifying that the ordering relations are invariants of the repeat
statement. Initially, with <code>i = 0</code> and
<code>j = n-1</code>, they are trivially true, and upon
exit with <code>i &gt; j</code>, they imply the desired
result.</p>

<p>We now recall that our goal is not only to find partitions of the
original array of items, but also to sort it. However, it is only a
small step from partitioning to sorting: after partitioning the
array, apply the same process to both partitions, then to the
partitions of the partitions, and so on, until every partition
consists of a single item only. This recipe is described as
follows. (Note that <code>sort</code> should actually be
declared local to <code>QuickSort</code>).</p>

<code class='large'>PROCEDURE sort (L, R: INTEGER); <span>(*ADenS2_Sorts *)</span>
  VAR i, j: INTEGER; w, x: Item;
BEGIN
  i := L; j := R;
  x := a[(L+R) DIV 2];
  REPEAT
    WHILE a[i] &lt; x DO i := i+1 END;
    WHILE x &lt; a[j] DO j := j-1 END;
    IF i &lt;= j THEN
      w := a[i]; a[i] := a[j]; a[j] := w; i := i+1; j := j-1
    END
  UNTIL i &gt; j;
  IF L &lt; j THEN sort(L, j) END;
  IF i &lt; R THEN sort(i, R) END
END sort;

PROCEDURE QuickSort;
BEGIN
  sort(0, n-1)
END QuickSort</code>

<p>Procedure <code>sort</code> activates itself
recursively. Such use of recursion in algorithms is a very powerful
tool and will be discussed further in Chap. 3. In some programming
languages of older provenience, recursion is disallowed for certain
technical reasons. We will now show how this same algorithm can be
expressed as a non-recursive procedure. Obviously, the solution is
to express recursion as an iteration, whereby a certain amount of
additional bookkeeping operations become necessary.</p>

<p>The key to an iterative solution lies in maintaining a list of
partitioning requests that have yet to be performed. After each
step, two partitioning tasks arise. Only one of them can be
attacked directly by the subsequent iteration; the other one is
stacked away on that list. It is, of course, essential that the
list of requests is obeyed in a specific sequence, namely, in
reverse sequence. This implies that the first request listed is the
last one to be obeyed, and vice versa; the list is treated as a
pulsating stack. In the following nonrecursive version of
Quicksort, each request is represented simply by a left and a right
index specifying the bounds of the partition to be further
partitioned. Thus, we introduce two array variables
<code>low</code>, <code>high</code>, used as stacks with
index <code>s</code>. The appropriate choice of the
stack size <code>M</code> will be discussed during the
analysis of Quicksort.</p>

<code class='large'>PROCEDURE NonRecursiveQuickSort; <span>(* ADenS2_Sorts *)</span>
  CONST M = 12;
  VAR i, j, L, R, s: INTEGER; x, w: Item;
    low, high: ARRAY M OF INTEGER; (*index stack*)
BEGIN
  s := 0; low[0] := 0; high[0] := n-1;
  REPEAT (*take top request from stack*)
    L := low[s]; R := high[s]; DEC(s);
    REPEAT (*partition a[L] ... a[R]*)
      i := L; j := R; x := a[(L+R) DIV 2];
      REPEAT
        WHILE a[i] &lt; x DO i := i+1 END;
        WHILE x &lt; a[j] DO j := j-1 END;
        IF i &lt;= j THEN
          w := a[i]; a[i] := a[j]; a[j] := w;
          i := i+1; j := j-1
        END
      UNTIL i &gt; j;
      IF i &lt; R THEN (*stack request to sort right partition*)
        INC(s); low[s] := i; high[s] := R
      END;
      R := j (*now L and R delimit the left partition*)
    UNTIL L &gt;= R
  UNTIL s &lt; 0
END NonRecursiveQuickSort</code>

<p><i><b>Analysis of Quicksort.</b></i> In order to analyze the
performance of Quicksort, we need to investigate the behavior of
the partitioning process first. After having selected a bound
<code>x</code>, it sweeps the entire array. Hence,
exactly <code>n</code> comparisons are performed. The
number of exchanges can be determind by the following probabilistic
argument.</p>

<p>With a fixed bound <code>u</code>, the expected number
of exchange operations is equal to the number of elements in the
left part of the partition, namely <code>u</code>,
multiplied by the probability that such an element reached its
place by an exchange. An exchange had taken place if the element
had previously been part of the right partition; the probablity for
this is <code>(n-u)/n</code>. The expected number of
exchanges is therefore the average of these expected values over
all possible bounds <code>u</code>:</p>

<code class='large'>M   = [Su: 0 ≤ u ≤ n-1 : u*(n-u)]/n<sup>2</sup>
    = n*(n-1)/2n - (2n<sup>2</sup> - 3n + 1)/6n
    = (n - 1/n)/6</code>

<p>Assuming that we are very lucky and always happen to select the
median as the bound, then each partitioning process splits the
array in two halves, and the number of necessary passes to sort is
<code>log(n)</code>. The resulting total number of
comparisons is then <code>n*log(n)</code>, and the total
number of exchanges is <code>n*log(n)/6</code>.</p>

<p>Of course, one cannot expect to hit the median all the time. In
fact, the chance of doing so is only <code>1/n</code>.
Surprisingly, however, the average performance of Quicksort is
inferior to the optimal case by a factor of only
<code>2*ln(2)</code>, if the bound is chosen at random.</p>

<p>But Quicksort does have its pitfalls. First of all, it performs
moderately well for small values of <code>n</code>, as
do all advanced methods. Its advantage over the other advanced
methods lies in the ease with which a straight sorting method can
be incorporated to handle small partitions. This is particularly
advantageous when considering the recursive version of the
program.</p>

<p>Still, there remains the question of the worst case. How does
Quicksort perform then? The answer is unfortunately disappointing
and it unveils the one weakness of Quicksort. Consider, for
instance, the unlucky case in which each time the largest value of
a partition happens to be picked as comparand <code>x</code>.
Then each step splits a segment of <code>n</code>
items into a left partition with <code>n-1</code>
items and a right partition with a single element.
The result is that <code>n</code> (instead of
<code>log(n)</code>) splits become necessary, and that
the worst-case performance is of the order <code>n<sup>2</sup></code>.</p>

<p>Apparently, the crucial step is the selection of the comparand
<code>x</code>. In our example program it is chosen as
the middle element. Note that one might almost as well select
either the first or the last element. In these cases, the worst
case is the initially sorted array; Quicksort then shows a definite
dislike for the trivial job and a preference for disordered arrays.
In choosing the middle element, the strange characteristic of
Quicksort is less obvious because the initially sorted array
becomes the optimal case. In fact, also the average performance is
slightly better, if the middle element is selected. Hoare suggests
that the choice of <code>x</code> be made at random, or
by selecting it as the median of a small sample of, say, three keys
[2.12 and 2.13]. Such a judicious choice hardly influences the
average performance of Quicksort, but it improves the worst-case
performance considerably. It becomes evident that sorting on the
basis of Quicksort is somewhat like a gamble in which one should be
aware of how much one may afford to lose if bad luck were to
strike.</p>

<p>There is one important lesson to be learned from this experience;
it concerns the programmer directly. What are the consequences of
the worst case behavior mentioned above to the performance
Quicksort? We have realized that each split results in a right
partition of only a single element; the request to sort this
partition is stacked for later execution. Consequently, the maximum
number of requests, and therefore the total required stack size, is
<code>n</code>. This is, of course, totally
unacceptable. (Note that we fare no better — in fact even worse —
with the recursive version because a system allowing recursive
activation of procedures will have to store the values of
local variables and parameters of
all procedure activations automatically, and it will use an
implicit stack for this purpose.) The remedy lies in stacking the
sort request for the longer partition and in continuing directly
with the further partitioning of the smaller section. In this case,
the size of the stack <code>M</code> can be limited to
<code>log(n)</code>.</p>

<p>The change necessary is localized in the section setting up new
requests. It now reads</p>
<code class='large'>IF j - L &lt; R - i THEN
  IF i &lt; R THEN (*stack request for sorting right partition*)
    INC(s); low[s] := i; high[s] := R
  END;
  R := j (*continue sorting left partition*)
ELSE
  IF L &lt; j THEN (*stack request for sorting left parition*)
    INC(s); low[s] := L; high[s] := j
  END;
  L := i (*continue sorting right partition*)
END</code>

</li>

<li data-list-text="2.3.4" id="2.3.4">
<h4><a href='#2.3.4'>Finding the Median</a></h4>

<p>The median of <code>n</code> items is defined as that
item which is less than (or equal to) half of the <code>n</code>
items and which is larger than (or equal to) the
other half of the <code>n</code> items. For example, the
median of</p>
<code>16 12 99 95 18 87 10</code>
<p>is <code>18</code>. The problem of finding the median is
customarily connected with that of sorting, because the obvious
method of determining the median is to sort the <code>n</code>
items and then to pick the item in the middle. But
partitioning yields a potentially much faster way of finding the
median. The method to be displayed easily generalizes to the
problem of finding the <code>k</code>-th smallest of
<code>n</code> items. Finding the median represents the
special case <code>k = n/2</code>.</p>

<p>The algorithm invented by C.A.R. Hoare [2-4] functions as follows.
First, the partitioning operation of Quicksort is applied with
<code>L = 0</code> and <code>R = n-1</code>
and with <code>a<sub>k</sub></code>
selected as splitting value <code>x</code>. The
resulting index values <code>i</code> and <code>j</code> are such that</p>
<ol class="noindent" id="l44">
<li data-list-text="1.">
<code>a<sub>h</sub> &lt; x  </code> for all <code>  h &lt; i</code>
</li>

<li data-list-text="2.">
<code>a<sub>h</sub> &gt; x  </code> for all <code>  h &gt; j</code>
</li>

<li data-list-text="3.">
<code>i &gt; j</code>
<p>There are three possible cases that may arise:</p>
<ol class="noindent" id="l45">
<li data-list-text="1.">
<p>The splitting value <code>x</code> was
too small; as a result, the limit between the two partitions is
below the desired value <code>k</code>. The partitioning
process has to be repeated upon the elements
<code>a<sub>i</sub> ... a<sub>R</sub></code> (see Fig. 2.9).</p>

<img alt="≤ ≥ L j i k R" src="fig/2.9.png" width="300"/>
<p>Fig. 2.9. Bound <code>x</code> too small</p>
</li>

<li data-list-text="2.">
<p>The chosen bound <code>x</code> was too
large. The splitting operation has to be repeated on the
partition <code>a<sub>L</sub> ... a<sub>j</sub></code> (see Fig. 2.10).</p>

<img alt="≤ ≥ L k j i R" src="fig/2.10.png" width="300"/>
<p>Fig. 2.10. Bound <code>x</code> too large</p>
</li>

<li data-list-text="3.">
<p><code>j &lt; k &lt; i:</code> the element <code>a<sub>k</sub></code>
splits the array into two partitions
in the specified proportions and therefore is the desired quantile
(see Fig. 2.11).</p>
</li>
</ol>


<img alt="≥ ≤ L j k i R" src="fig/2.11.png" width="300"/>
<p>Fig. 2.11. Correct bound</p>

<p>The splitting process has to be repeated until case 3 arises. This
iteration is expressed by the following piece of program:</p>
<code class='large'>L := 0; R := n;
WHILE L &lt; R-1 DO
  x := a[k];
  <i>partition</i> (a[L] ... a[R-1]);
  IF j &lt; k THEN L := i END;
  IF k &lt; i THEN R := j END
END</code>

<p>For a formal proof of the correctness of this algorithm, the reader
is referred to the original article by Hoare. The entire procedure
<code>Find</code> is readily derived from this.</p>

<code class='large'>PROCEDURE Find (k: INTEGER); <span>(* ADenS2_Sorts *)</span>
  (*reorder a such that a[k] is k-th largest*)
  VAR L, R, i, j: INTEGER; w, x: Item;
BEGIN
  L := 0; R := n-1;
  WHILE L &lt; R-1 DO
    x := a[k]; i := L; j := R;
    REPEAT
      WHILE a[i] &lt; x DO i := i+1 END;
      WHILE x &lt; a[j] DO j := j-1 END;
      IF i &lt;= j THEN
        w := a[i]; a[i] := a[j]; a[j] := w;
        i := i+1; j := j-1
      END
    UNTIL i &gt; j;
    IF j &lt; k THEN L := i END;
    IF k &lt; i THEN R := j END
  END
END Find</code>

<p>If we assume that on the average each split halves the size of the
partition in which the desired quantile lies, then the number of
necessary comparisons is</p>
<code>n + n/2 + n/4 + ... + 1 ≈ 2n</code>
<p>i.e., it is of order <code>n</code>. This explains the
power of the program <code>Find</code> for finding
medians and similar quantiles, and it explains its superiority over
the straightforward method of sorting the entire set of candidates
before selecting the <code>k</code>-th (where the best
is of order <code>n*log(n)</code>). In the worst case,
however, each partitioning step reduces the size of the set of
candidates only by 1, resulting in a required number of comparisons
of order <code>n<sup>2</sup></code>.
Again, there is hardly any advantage in using this algorithm, if
the number of elements is small, say, fewer than 10.</p>

</li>
</ol>
</li>

<li data-list-text="2.3.5" id="2.3.5">
<h4><a href='#2.3.5'>A Comparison of Array Sorting Methods</a></h4>

<p>To conclude this parade of sorting methods, we shall try to compare
their effectiveness. If <code>n</code> denotes the
number of items to be sorted, <code>C</code> and
<code>M</code> shall again stand for the number of
required key comparisons and item moves, respectively. Closed
analytical formulas can be given for all three straight sorting
methods. They are tabulated in Table 2.8. The column headings
<code>min</code>, <code>max</code>,
<code>avg</code> specify the respective minima, maxima,
and values averaged over all <code>n!</code>
permutations of <code>n</code> items.</p>

<div class='table'><table>
<tr>
<td></td><td></td><td>min</td><td>avg</td><td>max</td></tr>
<tr>
<td>Straight</td>
<td>C =</td>
<td>n-1</td>
<td>(n<sup>2</sup> + n - 2)/4</td>
<td>(n<sup>2</sup> - n)/2 - 1</td>
</tr>
<tr>
<td>insertion</td>
<td>M =</td>
<td>2(n-1)</td>
<td>(n<sup>2</sup> - 9n -10)/4</td>
<td>(n<sup>2</sup> - 3n - 4)/2</td>
</tr>
<tr>
<td>Straight</td>
<td>C =</td>
<td>(n<sup>2</sup> - n)/2</td>
<td>(n<sup>2</sup> - n)/2</td>
<td>(n<sup>2</sup> - n)/2</td>
</tr>
<tr>
<td>selection</td>
<td>M =</td>
<td>3(n-1)</td>
<td>n*(ln(n) + 0.57)</td>
<td>n<sup>2</sup>/4 + 3(n-1)</td>
</tr>
<tr>
<td>Straight</td>
<td>C =</td>
<td>(n<sup>2</sup>-n)/2</td>
<td>(n<sup>2</sup>-n)/2</td>
<td>(n<sup>2</sup>-n)/2</td>
</tr>
<tr>
<td>exchange</td>
<td>M =</td>
<td>0</td>
<td>(n<sup>2</sup>-n)*0.75</td>
<td>(n<sup>2</sup>-n)*1.5</td>
</tr>
</table></div>

<p>Table 2.8. Comparison of straight sorting methods.</p>
<p>No reasonably simple accurate formulas are available on the
advanced methods. The essential facts are that the computational
effort needed is <code>c*n<sup>1.2</sup></code>
in the case of Shellsort and is <code>c*n*log(n)</code>
in the cases of Heapsort and Quicksort,
where the <code>c</code> are appropriate coefficients.</p>

<p>These formulas merely provide a rough measure of performance as
functions of <code>n</code>, and they allow the
classification of sorting algorithms into primitive, straight
methods (<code>n<sup>2</sup></code>) and
advanced or "logarithmic" methods (<code>n*log(n)</code>).
For practical purposes, however, it is
helpful to have some experimental data available that shed light on
the coefficients <code>c</code> which further
distinguish the various methods. Moreover, the formulas do not take
into account the computational effort expended on operations other
than key comparisons and item moves, such as loop control, etc.
Clearly, these factors depend to some degree on individual systems,
but an example of experimentally obtained data is nevertheless
informative. Table 2.9 shows the times (in seconds) consumed by the
sorting methods previously discussed, as executed by the Modula-2
system on a Lilith personal computer. The three columns contain the
times used to sort the already ordered array, a random permutation,
and the inversely ordered array. Table 2.9 is for 256 items, Table
2.10 for 2048 items. The data clearly separate the
<code>n<sup>2</sup></code> methods from the
<code>n*log(n)</code> methods. The following points are
noteworthy:</p>
<ol class="noindent" id="l46">
<li data-list-text="1.">
The improvement of binary insertion over straight insertion is
marginal indeed, and even negative in the case of an already
existing order.
<li data-list-text="2.">
Bubblesort is definitely the worst sorting method among all
compared. Its improved version Shakersort is still worse than
straight insertion and straight selection (except in the
pathological case of sorting a sorted array).
</li>
<li data-list-text="3.">
Quicksort beats Heapsort by a factor of 2 to 3. It sorts the
inversely ordered array with speed practically identical to the one
that is already sorted.
</li>
</ol>

<div class='table'><table>
  <caption>Table 2.9. Execution times of sort programs with 256 elements</caption>
<tr>
<td></td><td>Ordered</td><td>Random</td><td>Inverse</td></tr>
<tr>
<td>StraightInsertion</td><td>0.02</td><td>0.82</td><td>1.64</td></tr>
<tr>
<td>BinaryInsertion</td><td>0.12</td><td>0.70</td><td>1.30</td></tr>
<tr>
<td>StraightSelection</td><td>0.94</td><td>0.96</td><td>1.18</td></tr>
<tr>
<td>BubbleSort</td><td>1.26</td><td>2.04</td><td>2.80</td></tr>
<tr>
<td>ShakerSort</td><td>0.02</td><td>1.66</td><td>2.92</td></tr>
<tr>
<td>ShellSort</td><td>0.10</td><td>0.24</td><td>0.28</td></tr>
<tr>
<td>HeapSort</td><td>0.20</td><td>0.20</td><td>0.20</td></tr>
<tr>
<td>QuickSort</td><td>0.08</td><td>0.12</td><td>0.08</td></tr>
<tr>
<td>NonRecQuickSort</td><td>0.08</td><td>0.12</td><td>0.08</td></tr>
<tr>
<td>StraightMerge</td><td>0.18</td><td>0.18</td><td>0.18</td></tr>
</table></div>

<div class='table'><table>
  <caption>Table 2.10. Execution times of sort programs with 2048 elements</caption>
<tr>
<td></td>
<td>Ordered</td><td>Random</td><td>Inverse</td></tr>
<tr>
<td>StraightInsertion</td><td>0.22</td><td>50.74</td><td>103.80</td></tr>
<tr>
<td>BinaryInsertion</td><td>1.16</td><td>37.66</td><td>76.06</td></tr>
<tr>
<td>StraightSelection</td><td>58.18</td><td>58.34</td><td>73.46</td></tr>
<tr>
<td>BubbleSort</td><td>80.18</td><td>128.84</td><td>178.66</td></tr>
<tr>
<td>ShakerSort</td><td>0.16</td><td>104.44</td><td>187.36</td></tr>
<tr>
<td>ShellSort</td><td>0.80</td><td>7.08</td><td>12.34</td></tr>
<tr>
<td>HeapSort</td><td>2.32</td><td>2.22</td><td>2.12</td></tr>
<tr>
<td>QuickSort</td><td>0.72</td><td>1.22</td><td>0.76</td></tr>
<tr>
<td>NonRecQuickSort</td><td>0.72</td><td>1.32</td><td>0.80</td></tr>
<tr>
<td>StraightMerge</td><td>1.98</td><td>2.06</td><td>1.98</td></tr>
</table></div>

</li>
</ol>
</li>

<li data-list-text="2.4" id="2.4">
<h3><a href='#2.4'>Sorting Sequences</a></h3>
<ol class="page" id="l47">
<li data-list-text="2.4.1" id="2.4.1">
<h4><a href='#2.4.1'>Straight Merging</a></h4>

<p>Unfortunately, the sorting algorithms presented in the preceding
chapter are inapplicable, if the amount of data to be sorted does
not fit into a computer's main store, but if it is, for instance,
represented on a peripheral and sequential storage device such as a
tape or a disk. In this case we describe the data as a (sequential)
file whose characteristic is that at each moment one and only one
component is directly accessible. This is a severe restriction
compared to the possibilities offered by the array structure, and
therefore different sorting techniques have to be used. The most
important one is sorting by merging. Merging (or collating) means
combining two (or more) ordered sequences into a single, ordered
sequence by repeated selection among the currently accessible
components. Merging is a much simpler operation than sorting, and
it is used as an auxiliary operation in the more complex process of
sequential sorting. One way of sorting on the basis of merging,
called <i>straight merging</i>, is the following:</p>

<ol class="noindent" id="l48">
<li data-list-text="1.">
Split the sequence a into two halves, called <code>b</code> and <code>c</code>.
</li>
<li data-list-text="2.">
Merge <code>b</code> and <code>c</code> by
combining single items into ordered pairs.
</li>
<li data-list-text="3.">
Call the merged sequence <code>a</code>, and repeat
steps 1 and 2, this time merging ordered pairs into ordered
quadruples.
</li>
<li data-list-text="4.">
Repeat the previous steps, merging quadruples into octets, and
continue doing this, each time doubling the lengths of the merged
subsequences, until the entire sequence is ordered.
</li>
</ol>

<p>As an example, consider the sequence</p>
<code>44  55  12  42  94  18  06  67</code>
<p>In step 1, the split results in the sequences</p>
<code class='large'>44  55  12  42
94  18  06  67</code>
<p>The merging of single components (which are ordered sequences of
length 1), into ordered pairs yields</p>
<code>44  94'  18  55'  06  12'  42  67</code>
<p>Splitting again in the middle and merging ordered pairs yields</p>
<code>06  12  44  94'  18  42  55  67</code>
<p>A third split and merge operation finally produces the desired
result</p>
<code>06  12  18  42  44  55  67  94</code>
<p>Each operation that treats the entire set of data once is called a
<i>phase</i>, and the smallest subprocess that by repetition
constitutes the sort process is called a pass or a stage. In the
above example the sort took three passes, each pass consisting of a
splitting phase and a merging phase. In order to perform the sort,
three tapes are needed; the process is therefore called a
three-tape merge.</p>

<p>Actually, the splitting phases do not contribute to the sort since
they do in no way permute the items; in a sense they are
unproductive, although they constitute half of all copying
operations. They can be eliminated altogether by combining the
split and the merge phase. Instead of merging into a single
sequence, the output of the merge process is immediately
redistributed onto two tapes, which constitute the sources of the
subsequent pass. In contrast to the previous two-phase merge sort,
this method is called a <i>single-phase merge</i> or a <i>balanced
merge</i>. It is evidently superior because only half as many
copying operations are necessary; the price for this advantage is a
fourth tape.</p>

<p>We shall develop a merge program in detail and initially let the
data be represented as an array which, however, is scanned in
strictly sequential fashion. A later version of merge sort will
then be based on the sequence structure, allowing a
comparison of the two programs and
demonstrating the strong dependence of the form of a program on the
underlying representation of its data.</p>

<p>A single array may easily be used in place of two sequences, if it
is regarded as double-ended. Instead of merging from two source
files, we may pick items off the two ends of the array. Thus, the
general form of the combined merge-split phase can be illustrated
as shown in Fig. 2.12. The destination of the merged items is
switched after each ordered pair in the first pass, after each
ordered quadruple in the second pass, etc., thus evenly filling the
two destination sequences, represented by the two ends of a single
array. After each pass, the two arrays interchange their roles, the
source becomes the new destination, and vice versa.</p>

<img src="fig/2.12.png" width="700"/>
<p>Fig. 2.12. Straight merge sort with two arrays</p>

<p>A further simplification of the program can be achieved by joining
the two conceptually distinct arrays into a single array of doubled
size. Thus, the data will be represented by</p>
<code>a: ARRAY 2*n OF item</code>
<p>and we let the indices <code>i</code> and <code>j</code>
denote the two source items, whereas <code>k</code>
and <code>L</code> designate the two destinations
(see Fig. 2.12). The initial
data are, of course, the items
<code>a<sub>0</sub> ... a<sub>n-1</sub></code>.
Clearly, a Boolean variable <code>up</code>
is needed to denote the
direction of the data flow; <code>up</code> shall mean
that in the current pass components
<code>a<sub>0</sub> ... a<sub>n-1</sub></code>
will be moved up to the variables
<code>a<sub>n</sub> ... a<sub>2n-1</sub></code>,
whereas <code>~up</code> will indicate that
<code>a<sub>n</sub> ... a<sub>2n-1</sub></code>
will be transferred down into
<code>a<sub>0</sub> ... a<sub>n-1</sub></code>.
The value of <code>up</code> strictly alternates between
consecutive passes. And, finally, a variable <code>p</code>
is introduced to denote the length of the subsequences to be
merged. Its value is initially 1, and it is doubled before each
successive pass. To simplify matters somewhat, we shall assume
that <code>n</code> is always a power of 2. Thus, the
first version of the straight merge program assumes the following
form:</p>
<code class='large'>PROCEDURE StraightMerge;
  VAR i, j, k, L, p: INTEGER; up: BOOLEAN;
BEGIN
  up := TRUE; p := 1;
  REPEAT
    <code class="pseudo">initialize index variables;</code>
    IF up THEN
      i := 0; j := n-1; k := n; L := 2*n-1
    ELSE
      k := 0; L := n-1; i := n; j := 2*n-1
    END;
    <code class="pseudo">merge p-tuples from i- and j-sources to k- and L-destinations;</code>
    up := ~up; p := 2*p
  UNTIL p = n
END StraightMerge</code>

<p>In the next development step we further refine the statements
expressed in italics. Evidently, the merge pass involving
<code>n</code> items is itself a sequence of merges of
sequences, i.e. of <code>p</code>-tuples. Between every
such partial merge the destination is switched from the lower to
the upper end of the destination array, or vice versa,
to guarantee equal distribution onto both destinations. If
the destination of the merged items is the lower end of the
destination array, then the destination index is
<code>k</code>, and <code>k</code> is incremented after
each move of an item. If they are to be moved to the upper end of
the destination array, the destination index is <code>L</code>,
and it is decremented after each move. In order to
simplify the actual merge statement, we choose the destination to
be designated by <code>k</code> at all times, switching
the values of the variables <code>k</code> and
<code>L</code> after each <code>p</code>-tuple merge,
and denote the increment to be used at
all times by <code>h</code>, where <code>h</code>
is either 1 or -1. These design discussions lead to
the following refinement:</p>

<code class='large'>h := 1; m := n; (*m = no. of items to be merged*)
REPEAT
  q := p; r := p; m := m - 2*p;
  <code class='pseudo'>merge q items from i-source with r items from j-source.
  destination index is k. increment k by h;</code>
  h := -h;
  <code class='pseudo'>exchange k and L</code>
UNTIL m = 0</code>

<p>In the further refinement step the actual merge statement is to be
formulated. Here we have to keep in mind that the tail of the one
subsequence which is left non-empty after the merge has to be
appended to the output sequence by simple copying operations.</p>
<code class='large'>WHILE (q &gt; 0) &amp; (r &gt; 0) DO
  IF a[i] &lt; a[j] THEN
    <code class='pseudo'>move an item from i-source to k-destination;
    advance i and k;</code>
    q := q-1
  ELSE
    <code class='pseudo'>move an item from j-source to k-destination;
    advance j and k;</code>
    r := r-1
  END
END;
<code class='pseudo'>copy tail
of i-sequence; copy tail of j-sequence</code></code>

<p>After this further refinement of the tail copying operations, the
program is laid out in complete detail. Before writing it out in
full, we wish to eliminate the restriction that
<code>n</code> be a power of 2. Which parts of the algorithm are
affected by this relaxation of constraints? We easily convince
ourselves that the best way to cope with the more general situation
is to adhere to the old method as long as possible. In this example
this means that we continue merging <code>p</code>-tuples
until the remainders of the source sequences
are of length less than <code>p</code>. The one and only
part that is influenced are the statements that determine the
values of <code>q</code> and <code>r</code>.
The following four statements replace the three statements</p>
<code>q := p; r := p; m := m -2*p</code>
<p>and, as the reader should convince himself, they represent an
effective implementation of the strategy specified above; note that
<code>m</code> denotes the total number of items in the
two source sequences that remain to be merged:</p>
<code class='large'>IF m &gt;= p THEN q := p ELSE q := m END;
m := m-q;
IF m &gt;= p THEN r := p ELSE r := m END;
m := m-r</code>
<p>In addition, in order to guarantee termination of
the program, the condition <code>p = n</code>, which
controls the outer repetition, must be changed to <code>p ≥ n</code>.
After these modifications, we may now proceed to describe the entire algorithm
in terms of a procedure operating on the global array a with
<code>2n</code> elements.</p>
<code class='large'>PROCEDURE StraightMerge; <span>(* ADenS24_MergeSorts *)</span>
  VAR i, j, k, L, t: INTEGER; (* index range of a is 0 .. 2*n-1 *)
    h, m, p, q, r: INTEGER; up: BOOLEAN;
BEGIN
  up := TRUE; p := 1;
  REPEAT
    h := 1; m := n;
    IF up THEN
      i := 0; j := n-1; k := n; L := 2*n-1
    ELSE
      k := 0; L := n-1; i := n; j := 2*n-1
    END;
    REPEAT (*merge a run from i- and j-sources to k-destination*)
      IF m &gt;= p THEN q := p ELSE q := m END;
      m := m-q;
      IF m &gt;= p THEN r := p ELSE r := m END;
      m := m-r;
      WHILE (q &gt; 0) &amp; (r &gt; 0) DO
        IF a[i] &lt; a[j] THEN
          a[k] := a[i]; k := k+h; i := i+1; q := q-1
        ELSE
          a[k] := a[j]; k := k+h; j := j-1; r := r-1
        END
      END;
      WHILE r &gt; 0 DO
        a[k] := a[j]; k := k+h; j := j-1; r := r-1
      END;
      WHILE q &gt; 0 DO
        a[k] := a[i]; k := k+h; i := i+1; q := q-1
      END;
      h := -h; t := k; k := L; L := t
    UNTIL m = 0;
    up := ~up; p := 2*p
  UNTIL p &gt;= n;
  IF ~up THEN
    FOR i := 0 TO n-1 DO
      a[i] := a[i+n]
    END
  END
END StraightMerge</code>
<p><i><b>Analysis of Mergesort.</b></i> Since each pass doubles
<code>p</code>, and since the sort is terminated as soon
as <code>p &gt; n</code>, it involves <code>⌈log(n)⌉</code> passes.
Each pass, by definition, copies the entire set
of <code>n</code> items exactly once.
As a consequence, the total number of moves is exactly
<code>M = n × ⌈log(n)⌉</code></p>
<p>The number <code>C</code> of key comparisons is even
less than <code>M</code> since no comparisons are
involved in the tail copying operations. However, since the
mergesort technique is usually applied in connection with the use
of peripheral storage devices, the computational effort involved in
the move operations dominates the effort of comparisons often by
several orders of magnitude. The detailed analysis of the number of
comparisons is therefore of little practical interest.</p>

<p>The merge sort algorithm apparently compares well with even the
advanced sorting techniques discussed in the previous chapter.
However, the administrative overhead for the manipulation of
indices is relatively high, and the decisive disadvantage is the
need for storage of <code>2n</code> items. This is the
reason sorting by merging is rarely used on arrays, i.e., on data
located in main store. Figures comparing the real time behavior of
this <code>Mergesort</code> algorithm appear in the last
line of Table 2.9. They compare favorably with <code>Heapsort</code>
but unfavorably with <code>Quicksort</code>.</p>
</li>

<li data-list-text="2.4.2" id="2.4.2">
<h4><a href="#2.4.2" id='2.4.2'>Natural Merging</a></h4>

<p>In straight merging no advantage is gained when the data are
initially already partially sorted. The length of all merged
subsequences in the <code>k</code>-th pass is less than
or equal to <code>2k</code>, independent of whether
longer subsequences are already ordered and could as well be
merged. In fact, any two ordered subsequences of lengths
<code>m</code> and <code>n</code> might be
merged directly into a single sequence of <code>m+n</code>
items. A mergesort that at any time merges the two
longest possible subsequences is called a <i>natural merge
sort</i>.</p>

<p>An ordered subsequence is often called a string. However, since the
word string is even more frequently used to describe sequences of
characters, we will follow Knuth in our terminology and use the
word <i>run</i> instead of string when referring to ordered
subsequences. We call a subsequence
<code>a<sub>i</sub> ... a</span><sub>j</sub></code> such that</p>
<code class='large'>(a<sub>i-1</sub> &gt; a<sub>i</sub>) &amp; (<b>A</b>k: i ≤ k &lt; j : a<sub>k</sub> ≤ a<sub>k+1</sub>) &amp; (a<sub>j</sub> &gt; a<sub>j+1</sub>)</code>
<p>a <i>maximal run</i> or, for short, a run. A natural merge sort,
therefore, merges (maximal) runs instead of sequences of fixed,
predetermined length. Runs have the property that if two sequences
of <code>n</code> runs are merged, a single sequence of
exactly <code>n</code> runs emerges. Therefore, the
total number of runs is halved in each pass, and the number of
required moves of items is in the worst case <code>n*log(n)</code>,
but in the average case it is even less. The
expected number of comparisons, however, is much larger because in
addition to the comparisons necessary for the selection of items,
further comparisons are needed between consecutive items of each
file in order to determine the end of each run.</p>

<p>Our next programming exercise develops a natural merge algorithm in
the same stepwise fashion that was used to explain the straight
merging algorithm. It employs the sequence structure (represented
by files, see Sect. 1.7) instead of the array, and it represents an
unbalanced, two-phase, three-tape merge sort. We assume that the
file variable <code>c</code>. represents the initial
sequence of items. (Naturally, in actual data processing
application, the initial data are first copied from the original
source to <code>c</code> for reasons of safety.)
<code>a</code> and <code>b</code> are two
auxiliary file variables. Each pass consists of a distribution
phase that distributes runs equally from <code>c</code>
to <code>a</code> and <code>b</code>, and a
merge phase that merges runs from <code>a</code> and
<code>b</code> to <code>c</code>. This
process is illustrated in Fig. 2.13.</p>

<img src="fig/2.13.png" width="600"/>
<p>Fig. 2.13. Sort phases and passes</p>

<div class='table'>
<div class='table'><table>
<tr>
<td>17</td><td>31'</td><td>05</td><td>59'</td><td>13</td><td>41</td><td>43</td><td>67'</td><td>11</td><td>23</td><td>29</td><td>47'</td><td>03</td><td>07</td><td>71'</td><td>02</td><td>19</td><td>57'</td><td>37</td><td>61</td></tr>
<tr>
<td>05</td><td>17</td><td>31</td><td>59'</td><td>11</td><td>13</td><td>23</td><td>29</td><td>41</td><td>43</td><td>47</td><td>67'</td><td>02</td><td>03</td><td>07</td><td>19</td><td>57</td><td>71'</td><td>37</td><td>61</td></tr>
<tr>
<td>05</td><td>11</td><td>13</td><td>17</td><td>23</td><td>29</td><td>31</td><td>41</td><td>43</td><td>47</td><td>59</td><td>67'</td><td>02</td><td>03</td><td>07</td><td>19</td><td>37</td><td>57</td><td>61</td><td>71</td></tr>
<tr>
<td>02</td><td>03</td><td>05</td><td>07</td><td>11</td><td>13</td><td>17</td><td>19</td><td>23</td><td>29</td><td>31</td><td>37</td><td>41</td><td>43</td><td>47</td><td>57</td><td>59</td><td>61</td><td>67</td><td>71</td></tr>
</table></div>
</div>

<p>Table 2.11. Example of a Natural Mergesort.</p>
<p>As an example, Table 2.11 shows the file <code>c</code>
in its original state (line1) and after each pass (lines 2-4) in a
natural merge sort involving 20 numbers. Note that only three
passes are needed. The sort terminates as soon as the number of
runs on <code>c</code> is 1. (We assume that there
exists at least one non-empty run on the initial sequence). We
therefore let a variable <code>L</code> be used for
counting the number of runs merged onto <code>c</code>.
By making use of the type <code>Rider</code> defined in
Sect. 1.7.1, the program can be formulated as follows:</p>
<code class='large'>VAR L: INTEGER;
  r0, r1, r2: Files.Rider; (*see 1.7.1*)

REPEAT
  Files.Set(r0, a, 0); Files.Set(r1, b, 0); Files.Set(r2, c, 0);
  distribute(r2, r0, r1); (*c to a and b*)
  Files.Set(r0, a, 0); Files.Set(r1, b, 0); Files.Set(r2, c, 0);
  L := 0;
  merge(r0, r1, r2) (*a and b into c*)
UNTIL L = 1</code>

<p>The two phases clearly emerge as two distinct statements. They are
now to be refined, i.e., expressed in more detail. The refined
descriptions of <code>distribute</code> (from rider
<code>r2</code> to riders <code>r0</code> and
<code>r1</code>) and <code>merge</code> (from
riders <code>r0</code> and <code>r1</code> to
rider <code>r2</code>) follow:</p>
<code class='large'>REPEAT
  copyrun(r2, r0);
  IF ~r2.eof THEN copyrun(r2, r1) END
UNTIL r2.eof

REPEAT
  mergerun(r0, r1, r2); INC(L)
UNTIL r1.eof;
IF ~r0.eof THEN
  copyrun(r0, r2); INC(L)
END</code>

<p>This method of distribution supposedly results in either equal
numbers of runs in both <code>a</code> and <code>b</code>,
or in sequence <code>a</code> containing
one run more than <code>b</code>. Since corresponding
pairs of runs are merged, a leftover run may still be on file
<code>a</code>, which simply has to be copied. The
statements <code>merge</code> and <code>distribute</code>
are formulated in terms of a refined
statement <code>mergerun</code> and a subordinate
procedure <code>copyrun</code> with obvious tasks. When
attempting to do so, one runs into a serious difficulty: In order
to determine the end of a run, two consecutive keys must be
compared. However, files are such that only a single element is
immediately accessible. We evidently cannot avoid to look ahead,
i.e to associate a buffer with every sequence. The buffer is to
contain the first element of the file still to be read and
constitutes something like a window sliding over the file.</p>

<p>Instead of programming this mechanism explicitly into our program,
we prefer to define yet another level of abstraction. It is
represented by a new module <code>Runs</code>. It can be
regarded as an extension of module <code>Files</code> of
Sect. 1.7, introducing a new type <code>Rider</code>,
which we may consider as an extension of type <code>Files.Rider</code>.
This new type will not only accept all
operations available on <code>Riders</code> and indicate
the end of a file, but also indicate the end of a run and the first
element of the remaining part of the file. The new type as well as
its operators are presented by the following definition.</p>
<code class='large'>DEFINITION Runs; <span>(* ADenS242_Runs *)</span>
  IMPORT Files, Texts;
  TYPE Rider = RECORD (Files.Rider) first: INTEGER; eor: BOOLEAN END;

  PROCEDURE OpenRandomSeq (f: Files.File; length, seed: INTEGER);
  PROCEDURE Set (VAR r: Rider; VAR f: Files.File);
  PROCEDURE copy (VAR source, destination: Rider);
  PROCEDURE ListSeq(VAR W: Texts.Writer; f: Files.File);
END Runs.</code>

<p>A few additional explanations for the choice of the procedures are
necessary. As we shall see, the sorting algorithms discussed here
and later are based on copying elements from one file to another. A
procedure <code>copy</code> therefore takes the place of
separate <code>read</code> and <code>write</code> operations.</p>

<p>For convenience of testing the following examples, we also
introduce a procedure <code>ListSeq</code>, converting a
file of integers into a text. Also for convenience an additional
procedure is included: <code>OpenRandomSeq</code>
initializes a file with numbers in random order. These two
procedures will serve to test the algorithms to be discussed below.
The values of the fields <code>eof</code> and
<code>eor</code> are defined as results of <code>copy</code>
in analogy to <code>eof</code> having
been defined as result of a <code>read</code>
operation.</p>
<code class='large'>MODULE Runs; <span>(* ADenS242_Runs *)</span>
  IMPORT Files, Texts;
  TYPE Rider* = RECORD (Files.Rider) first: INTEGER; eor: BOOLEAN END;

  PROCEDURE OpenRandomSeq* ( f: Files.File; length, seed: INTEGER);
    VAR i: INTEGER; w: Files.Rider;
  BEGIN
    Files.Set(w, f, 0);
    FOR i := 0 TO length-1 DO
      Files.WriteInt(w, seed); seed := (31*seed) MOD 997 + 5
    END;
    Files.Close(f)
  END OpenRandomSeq;

  PROCEDURE Set* (VAR r: Rider; f: Files.File);
  BEGIN
    Files.Set(r, f, 0); Files.ReadInt (r, r.first); r.eor := r.eof
  END Set;

  PROCEDURE copy* (VAR src, dest: Rider);
  BEGIN
    dest.first := src.first;
    Files.WriteInt(dest, dest.first); Files.ReadInt(src, src.first);
    src.eor := src.eof OR (src.first &lt; dest.first)
  END copy;

  PROCEDURE ListSeq* (VAR W: Texts.Writer; f: Files.File;);
    VAR x, y, k, n: INTEGER; r: Files.Rider;
  BEGIN
    k := 0; n := 0;
    Files.Set(r, f, 0); Files.ReadInt(r, x);
    WHILE ~r.eof DO
      Texts.WriteInt(W, x, 6); INC(k); Files.ReadInt(r, y);
      IF y &lt; x THEN (*end of run*) Texts.Write(W, "|"); INC(n) END;
      x := y
    END;
    Texts.Write(W, "$"); Texts.WriteInt(W, k, 5); Texts.WriteInt(W, n, 5);
    Texts.WriteLn(W)
  END ListSeq;
END Runs.</code>

<p>We now return to the process of successive refinement of the
process of natural merging. Procedure <code>copyrun</code>
and the statement <code>merge</code>
are now conveniently expressible as shown below. Note that we refer
to the sequences (files) indirectly via the riders attached to
them. In passing, we also note that the rider's field
<code>first</code> represents the <i>next</i> key on a sequence
being read, and the <i>last</i> key of a sequence being
written.</p>

<code class='large'>PROCEDURE copyrun (VAR x, y: Runs.Rider);
BEGIN (*copy from x to y*)
  REPEAT Runs.copy(x, y) UNTIL x.eor
END copyrun</code>

<code class='large'>(*merge from r0 and r1 to r2*)
REPEAT
  IF r0.first &lt; r1.first THEN
    Runs.copy(r0, r2);
    IF r0.eor THEN copyrun(r1, r2) END
  ELSE Runs.copy(r1, r2);
    IF r1.eor THEN copyrun(r0, r2) END
  END
UNTIL r0.eor OR r1.eor</code>

<p>The comparison and selection process of keys in merging a run
terminates as soon as one of the two runs is exhausted. After this,
the other run (which is not exhausted yet) has to be transferred to
the resulting run by merely copying its tail. This is done by a
call of procedure <code>copyrun</code>.</p>

<p>This should supposedly terminate the development of the natural
merging sort procedure. Regrettably, the program is incorrect, as
the very careful reader may have noticed. The program is incorrect
in the sense that it does not sort properly in some cases.
Consider, for example, the following sequence of input data:</p>
<code class='large'>03 02 05 11 07 13 19 17 23 31 29 37 43 41 47 59 57 61 71 67</code>
<p>By distributing consecutive runs alternately to
<code>a</code> and <code>b</code>, we obtain</p>
<code class='large'>a = 03 ' 07 13 19 ' 29 37 43 ' 57 61 71'
b = 02 05 11 ' 17 23 31 ' 41 47 59 ' 67</code>

<p>These sequences are readily merged into a single run, whereafter
the sort terminates successfully. The example, although it does not
lead to an erroneous behaviour of the program, makes us aware that
mere distribution of runs to serveral files may result in a number
of output runs that is less than the number of input runs. This is
because the first item of the <code>i+2</code>nd run may
be larger than the last item of the <code>i</code>-th
run, thereby causing the two runs to merge automatically into a
single run.</p>

<p>Although procedure <code>distribute</code> supposedly
outputs runs in equal numbers to the two files, the important
consequence is that the actual number of resulting runs on
<code>a</code> and <code>b</code> may differ
significantly. Our merge procedure, however, only merges pairs of
runs and terminates as soon as <code>b</code> is read,
thereby losing the tail of one of the sequences. Consider the
following input data that are sorted (and truncated) in two
subsequent passes:</p>

<code class='large'>17 19 13 57 23 29 11 59 31 37 07 61 41 43 05 67 47 71 02 03
13 17 19 23 29 31 37 41 43 47 57 71 11 59
11 13 17 19 23 29 31 37 41 43 47 57 59 71</code>

<p>Table 2.12. Incorrect Result of <code>MergeSort</code>
Program.</p>

<p>The example of this programming mistake is typical for many
programming situations. The mistake is caused by an oversight of
one of the possible consequences of a presumably simple operation.
It is also typical in the sense that serval ways of correcting the
mistake are open and that one of them has to be chosen. Often there
exist two possibilities that differ in a very important,
fundamental way:</p>

<ol class="noindent" id="l49">
<li data-list-text="1.">
<p>We recognize that the operation of distribution is incorrectly
programmed and does not satisfy the requirement that the number of
runs differ by at most 1. We stick to the original scheme of
operation and correct the faulty procedure accordingly.</p>
</li>
<li data-list-text="2.">
<p>We recognize that the correction of the faulty part involves
far-reaching modifications, and we try to find ways in which other
parts of the algorithm may be changed to accommodate the currently
incorrect part.</p>
</li>
</ol>
<p>In general, the first path seems to be the safer, cleaner one, the
more honest way, providing a fair degree of immunity from later
consequences of overlooked, intricate side effects. It is,
therefore, the way toward a solution that is generally
recommended.</p>

<p>It is to be pointed out, however, that the second possibility
should sometimes not be entirely ignored. It is for this reason
that we further elaborate on this example and illustrate a fix by
modification of the merge procedure rather than the distribution
procedure, which is primarily at fault.</p>

<p>This implies that we leave the distribution scheme untouched and
renounce the condition that runs be equally distributed. This may
result in a less than optimal performance. However, the worst-case
performance remains unchanged, and moreover, the case of highly
unequal distribution is statistically very unlikely. Efficiency
considerations are therefore no serious argument against this
solution.</p>

<p>If the condition of equal distribution of runs no longer exists,
then the merge procedure has to be changed so that, after reaching
the end of one file, the entire tail of the remaining file is
copied instead of at most one run. This change is straightforward
and is very simple in comparison with any change in the
distribution scheme. (The reader is urged to convince himself of
the truth of this claim). The revised version of the merge
algorithm is shown below in the form of a function procedure:</p>
<code class='large'>PROCEDURE copyrun (VAR x, y: Runs.Rider); <span>(* ADenS24_MergeSorts *)</span>
BEGIN (*from x to y*)
  REPEAT Runs.copy(x, y) UNTIL x.eor
END copyrun;

PROCEDURE NaturalMerge (src: Files.File): Files.File;
  VAR L:INTEGER; (*no. of runs merged*)
    f0, f1, f2: Files.File; r0, r1, r2: Runs.Rider;
BEGIN
  Runs.Set(r2, src);
  REPEAT
    f0 := Files.New("test0"); Files.Set(r0, f0, 0);
    f1 := Files.New("test1"); Files.Set (r1, f1, 0);
    (*distribute from r2 to r0 and r1*)
    REPEAT
      copyrun(r2, r0);
      IF ~r2.eof THEN copyrun(r2, r1) END
    UNTIL r2.eof;
    Runs.Set(r0, f0);
    Runs.Set(r1, f1);
    f2 := Files.New(""); Files.Set(r2, f2, 0);
    (*merge from r0 and r1 to r2*)
    L := 0;
    REPEAT
      REPEAT
        IF r0.first &lt; r1.first THEN
          Runs.copy(r0, r2);
          IF r0.eor THEN copyrun(r1, r2) END
        ELSE
          Runs.copy(r1, r2);
          IF r1.eor THEN copyrun(r0, r2) END
        END
      UNTIL r0.eor &amp; r1.eor;
      INC(L)
    UNTIL r0.eof OR r1.eof;
    WHILE ~r0.eof DO
      copyrun(r0, r2); INC(L)
    END;
    WHILE ~r1.eof DO
      copyrun(r1, r2); INC(L)
    END;
    Runs.Set(r2, f2)
  UNTIL L = 1;
  RETURN f2
END NaturalMerge;</code>
</li>

<li data-list-text="2.4.3" id="2.4.3">
<h4><a href='#2.4.3' id='2.4.3'>Balanced Multiway Merging</a></h4>

<p>The effort involved in a sequential sort is
proportional to the number of required passes since, by definition,
every pass involves the copying of the entire set of data. One way
to reduce this number is to distribute runs onto more than two
files. Merging <code>r</code> runs that are equally
distributed on <code>N</code> files results in a sequence
of <code>r/N</code> runs. A second pass reduces their
number to <code>r/N<sup>2</sup></code>, a
third pass to <code>r/N<sup>3</sup></code>,
and after <code>k</code> passes there are
<code>r/N<sup>k</sup></code> runs left. The total
number of passes required to sort <code>n</code> items
by <code>N</code>-way merging is therefore
<code>k = log<sub>N</sub>(n)</code>. Since each pass
requires <code>n</code> copy operations, the total number
of copy operations is in the worst case <code>M = n×log<sub>N</sub>(n)</code>.
</p>

<p>As the next programming exercise, we will develop a sort program
based on multiway merging. In order to further contrast the program
from the previous natural two-phase merging procedure, we shall
formulate the multiway merge as a single phase, balanced mergesort.
This implies that in each pass there are an equal number of input
and output files onto which consecutive runs are alternately
distributed. Using <code>2N</code> files, the algorithm
will therefore be based on <code>N</code>-way merging.
Following the previously adopted strategy, we will not bother to
detect the automatic merging of two consecutive runs distributed
onto the same file. Consequently, we are forced to design the merge
program whithout assuming strictly equal numbers of runs on the
input files.
</p>

<p>In this program we encounter for the first time a natural
application of a data structure consisting of arrays of files. As a
matter of fact, it is surprising how strongly the following program
differs from the previous one because of the change from two-way to
multiway merging. The change is primarily a result of the
circumstance that the merge process can no longer simply be
terminated after one of the input runs is exhausted. Instead, a
list of inputs that are still active, i.e., not yet exhausted, must
be kept. Another complication stems from the need to switch the
groups of input and output files after each pass. Here the
indirection of access to files via riders comes in handy. In each
pass, data may be copied from the same riders <code>r</code>
to the same riders <code>w</code>. At the
end of each pass we merely need to reset the input and output files
to different riders.
</p>

<p>Obviously, file numbers are used to index the array of files. Let
us then assume that the initial file is the parameter
<code>src</code>, and that for the sorting process
<code>2N</code> files are available:
</p>
<code class='large'>f, g: ARRAY N OF Files.File;
r, w: ARRAY N OF Runs.Rider
</code>
<p>The algorithm can now be sketched as follows:</p>
<code class='large'>PROCEDURE BalancedMerge (src: Files.File): Files.File;
  VAR i, j: INTEGER;
    L: INTEGER; (*no. of runs distributed*)
    R: Runs.Rider;
BEGIN
  Runs.Set(R, src); (*distribute initial runs from R to w[0] ... w[N-1]*)
  j := 0; L := 0;
  <code class="pseudo">position riders w on files g;</code>
  REPEAT
    <code class="pseudo">copy one run from R to w[j];</code>
    INC(j); INC(L);
    IF j = N THEN j := 0 END
  UNTIL R.eof;

  REPEAT (*merge from riders r to riders w*)
    <code class="pseudo">switch files g to riders r;</code>
    L := 0; j := 0; (*j = index of output file*)
    REPEAT
      INC(L);
      <code class="pseudo">merge one run from inputs to w[j];</code>
      IF j &lt; N THEN INC(j) ELSE j := 0 END
    UNTIL <code class="pseudo">all inputs exhausted</code>;
  UNTIL L = 1
  (*sorted file is with w[0]*)
END BalancedMerge.</code>

<p>Having associated a rider <code>R</code> with the source
file, we now refine the statement for the initial distribution of
runs. Using the definition of <code>copy</code>, we
replace <code class="pseudo">copy one run from R to w[j]</code>
by:</p>
<code>REPEAT Runs.copy(R, w[j]) UNTIL R.eor</code>

<p>Copying a run terminates when either the first item of the next run
is encountered or when the end of the entire input file is
reached.</p>

<p>In the actual sort algorithm, the following statements remain to be
specified in more detail:</p>
<ol class="noindent" id="l50">
<li data-list-text="(1)">
<code class="pseudo">position riders w on files g</code>
</li>
<li data-list-text="(2)">
<code class="pseudo">merge one run from inputs to w[j]</code>
</li>
<li data-list-text="(3)">
<code class="pseudo">switch files g to riders r</code>
</li>
<li data-list-text="(4)">
<code class="pseudo">all inputs exhausted</code>
</li>
</ol>

<p>First, we must accurately identify the current input sequences.
Notably, the number of <i>active</i> inputs may be less than
<code>N</code>. Obviously, there can be at most as many
sources as there are runs; the sort terminates as soon as there is
one single sequence left. This leaves open the possibility that at
the initiation of the last sort pass there are fewer than
<code>N</code> runs. We therefore introduce a variable,
say <code>k1</code>, to denote the actual number of
inputs used. We incorporate the initialization of <code>k1</code>
in the statement <code class="pseudo">switch files</code> as follows</p>
<code class='large'>IF L &lt; N THEN k1 := L ELSE k1 := N END;
FOR i := 0 TO k1-1 DO Runs.Set(r[i], g[i]) END</code>
<p>Naturally, statement (2) is to decrement <code>k1</code>
whenever an input source ceases. Hence, predicate (4) may easily be
expressed by the relation <code>k1 = 0</code>. Statement
(2), however, is more difficult to refine; it consists of the
repeated selection of the least key among the available sources and
its subsequent transport to the destination, i.e.,
the current output sequence. The process is
further complicated by the necessity of determining the end of each
run. The end of a run may be reached because (a) the subsequent key
is less than the current key or (b) the end of the source is
reached. In the latter case the source is eliminated by
decrementing <code>k1</code>; in the former case the run
is closed by excluding the sequence from further selection of
items, but only until the creation of the current output run is
completed. This makes it obvious that a second variable, say
<code>k2</code>, is needed to denote the number of
sources actually available for the selection of the next item. This
value is initially set equal to <code>k1</code> and is
decremented whenever a run teminates because of condition (a).</p>

<p>Unfortunately, the introduction of <code>k2</code>
is not sufficient. We need to know not only the
number of files, but also which files are still in actual use. An
obvious solution is to use an array with Boolean components
indicating the availability of the files. We choose, however, a
different method that leads to a more efficient selection procedure
which, after all, is the most frequently repeated part of the
entire algorithm. Instead of using a Boolean array, a file index
map, say <code>t</code>, is introduced. This map is used
so that <code>t<sub>0</sub> ... t<sub>k2-1</sub></code>
are the indices of the available
sequences. Thus statement (2) can be formulated as
follows:</p>
<code class='large'>k2 := k1;
REPEAT
  <code class='pseudo'>select the minimal key, let t[m] be the sequence number on which it occurs;</code>
  Runs.copy(r[t[m]], w[j]);
  IF r[t[m]].eof THEN <code class="pseudo">eliminate sequence</code>
  ELSIF r[t[m]].eor THEN <code class="pseudo">close run</code>
  END
UNTIL k2 = 0</code>
<p>Since the number of sequences will be fairly small for any
practical purpose, the selection algorithm to be specified in
further detail in the next refinement step may as well be a
straightforward linear search. The statement
<code class="pseudo">eliminate sequence</code> implies a decrease of
<code>k1</code> as well as <code>k2</code> and also a
reassignment of indices in the map <code>t</code>. The
statement <code class="pseudo">close run</code> merely decrements
<code>k2</code> and rearranges components of
<code>t</code> accordingly. The details are shown in the
following procedure, being the last refinement. The statement
<code class="pseudo">switch files</code> is elaborated according to
explanations given earlier.</p>
<code class='large'>PROCEDURE BalancedMerge (src: Files.File): Files.File; <span>(* ADenS24_MergeSorts *)</span>
  VAR i, j, m, tx: INTEGER;
    L, k1, k2, K1: INTEGER;
    min, x: INTEGER;
    t: ARRAY N OF INTEGER; (*index map*)
    R: Runs.Rider; (*source*)
    f, g: ARRAY N OF Files.File;
    r, w: ARRAY N OF Runs.Rider;
BEGIN Runs.Set(R, src);
  FOR i := 0 TO N-1 DO
    g[i] := Files.New(""); Files.Set(w[i], g[i], 0)
  END;
  (*distribute initial runs from src to g[0] ... g[N-1]*)
  j := 0; L := 0;
  REPEAT
    REPEAT Runs.copy(R, w[j]) UNTIL R.eor;
    INC(L); INC(j);
    IF j = N THEN j := 0 END
  UNTIL R.eof;
  REPEAT
    IF L &lt; N THEN k1 := L ELSE k1 := N END;
    K1 := k1;
    FOR i := 0 TO k1-1 DO (*set input riders*)
      Runs.Set(r[i], g[i])
    END;
    FOR i := 0 TO k1-1 DO (*set output riders*)
      g[i] := Files.New("");
      Files.Set(w[i], g[i], 0)
    END;
    (*merge from r[0] ... r[k1-1] to w[0] ... w[K1-1]*)
    FOR i := 0 TO k1-1 DO
      t[i] := i
    END;
    L := 0; (*nof runs merged*)
    j := 0;
    REPEAT (*merge on run from inputs to w[j]*)
      INC(L); k2 := k1;
      REPEAT (*select the minimal key*)
        m := 0; min := r[t[0]].first; i := 1;
        WHILE i &lt; k2 DO
          x := r[t[i]].first;
          IF x &lt; min THEN min := x; m := i END;
          INC(i)
        END;
        Runs.copy(r[t[m]], w[j]);
        IF r[t[m]].eof THEN (*eliminate this sequence*)
          DEC(k1); DEC(k2);
          t[m] := t[k2]; t[k2] := t[k1]
        ELSIF r[t[m]].eor THEN (*close run*)
          DEC(k2);
          tx := t[m]; t[m] := t[k2]; t[k2] := tx
        END
      UNTIL k2 = 0;
      INC(j);
      IF j = K1 THEN j := 0 END
    UNTIL k1 = 0
  UNTIL L = 1;
  RETURN g[0]
END BalancedMerge</code>
</li>

<li data-list-text="2.4.4" id="2.4.4">
<h4><a href='#2.4.4' id='2.4.4'>Polyphase Sort</a></h4>

<p>We have now discussed the necessary techniques and have acquired
the proper background to investigate and program yet another
sorting algorithm whose performance is superior to the balanced
sort. We have seen that balanced merging eliminates the pure
copying operations necessary when the distribution and the merging
operations are united into a single phase. The question arises
whether or not the given sequences could be processed even more
efficiently. This is indeed the case; the key to this next
improvement lies in abandoning the rigid notion of strict passes,
i.e., to use the sequences in a more sophisticated way than by
always having <code>N</code> sources and as many
destinations and exchanging sources and destinations at the end of
each distinct pass. Instead, the notion of a pass becomes diffuse.
The method was invented by R.L. Gilstad [2-3] and called
<i>Polyphase Sort</i>.</p>

<p>It is first illustrated by an example using three sequences. At any
time, items are merged from two sources into a third sequence
variable. Whenever one of the source sequences is exhausted, it
immediately becomes the destination of the merge operations of data
from the non-exhausted source and the previous destination
sequence.</p>

<p>As we know that <code>n</code> runs on each input are
transformed into <code>n</code> runs on the output, we
need to list only the number of runs present on each sequence
(instead of specifying actual keys). In Fig. 2.14 we assume that
initially the two input sequences <code>f0</code> and
<code>f1</code> contain 13 and 8 runs, respectively.
Thus, in the first pass 8 runs are merged from
<code>f0</code> and <code>f1</code> to <code>f2</code>,
in the second pass the remaining 5 runs are merged
from <code>f2</code> and <code>f0</code> to
<code>f1</code>, etc. In the end, <code>f0</code> is the sorted sequence.</p>

<img src="fig/2.14.png" width="300"/>
<p>Fig. 2.14. Polyphase mergesort of 21 runs with 3 sequences</p>

<p>
A second example shows the Polyphase method with 6 sequences. Let
there initially be 16 runs on <code>f0</code>, 15 on
<code>f1</code>, 14 on <code>f2</code>, 12 on
<code>f3</code>, and 8 on <code>f4</code>. In
the first partial pass, 8 runs are merged onto <code>f5</code>. In the end, <code>f1</code> contains the
sorted set of items (see Fig. 2.15).</p>

<img src="fig/2.15.png" width="700"/>
<p>Fig. 2.15. Polyphase mergesort of 65 runs with 6 sequences</p>

<p>Polyphase is more efficient than balanced merge
because, given <code>N</code> sequences, it always
operates with an <code>N-1</code>-way merge instead of
an  <code>N/2</code>-way merge. As the number of required
passes is approximately <code>log<sub>N</sub>n</code>,
<code>n</code> being the
number of items to be sorted and being the degree of the merge
operations, Polyphase promises a significant improvement over
balanced merging.</p>

<p>Of course, the distribution of initial runs was carefully chosen in
the above examples. In order to find out which initial
distributions of runs lead to a proper functioning, we work
backward, starting with the final distribution (last line in Fig.
2.15). Rewriting the tables of the two examples and rotating each
row by one position with respect to the prior row yields Tables
2.13 and 2.14 for six passes and for three and six sequences,
respectively.</p>

<div class='table'><table>
<tr>
<td>L</td><td>a<sub>0</sub>(L)</td><td>a<sub>1</sub>(L)</td><td>Sum a<sub>i</sub>(L)</td></tr>
<tr>
<td>0</td><td>1</td><td>0</td><td>1</td></tr>
<tr>
<td>1</td><td>1</td><td>1</td><td>2</td></tr>
<tr>
<td>2</td><td>2</td><td>1</td><td>3</td></tr>
<tr>
<td>3</td><td>3</td><td>2</td><td>5</td></tr>
<tr>
<td>4</td><td>5</td><td>3</td><td>8</td></tr>
<tr>
<td>5</td><td>8</td><td>5</td><td>13</td></tr>
<tr>
<td>6</td><td>13</td><td>8</td><td>21</td></tr>
</table></div>

<p>Table 2.13. Perfect distribution of runs on two sequences.</p>

<div class='table'><table>
<tr>
<td>L</td><td>a<sub>0</sub>(L)</td><td>a<sub>1</sub>(L)</td><td>a<sub>2</sub>(L)</td><td>a<sub>3</sub>(L)</td><td>a<sub>4</sub>(L)</td><td>Sum a<sub>i</sub>(L)</td>
</tr>
<tr>
<td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
<tr>
<td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>5</td></tr>
<tr>
<td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>1</td><td>9</td></tr>
<tr>
<td>3</td><td>4</td><td>4</td><td>4</td><td>3</td><td>2</td><td>17</td></tr>
<tr>
<td>4</td><td>8</td><td>8</td><td>7</td><td>6</td><td>4</td><td>33</td></tr>
<tr>
<td>5</td><td>16</td><td>15</td><td>14</td><td>12</td><td>8</td><td>65</td></tr>
</table></div>

<p>Table 2.14. Perfect distribution of runs on five sequences.</p>

<p>From Table 2.13 we can deduce for <code>L &gt; 0</code>
the relations</p>
<code class='large'>a<sub>1</sub>(L+1) = a<sub>0</sub>(L)
a<sub>0</sub>(L+1) = a<sub>0</sub>(L) + a<sub>1</sub>(L)</code>
<p>and <code>a<sub>0</sub>(0) = 1</code>, <code>a<sub>1</sub>(0) = 0</code>.
Defining <code>f<sub>i+1</sub> = a<sub>0</sub>(i)</code>, we obtain
for <code>i &gt; 0</code>:</p>
<code>f<sub>i+1</sub> = f<sub>i</sub> + f<sub>i-1</sub>, f<sub>1</sub> = 1, f<sub>0</sub> = 0</code>

<p>These are the recursive rules (or recurrence relations) defining
the <i>Fibonacci numbers</i>:</p>
<code class='large'>f = 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...</code>
<p>Each Fibonacci number is the sum of its two predecessors. As a
consequence, the numbers of initial runs on the two input sequences
must be two consecutive Fibonacci numbers in order to make
Polyphase work properly with three sequences.</p>

<p>How about the second example (Table 2.14) with six sequences? The
formation rules are easily derived as</p>
<code class='large'>a<sub>4</sub>(L+1) = a<sub>0</sub>(L)
a<sub>3</sub>(L+1) = a<sub>0</sub>(L) + a<sub>4</sub>(L) = a<sub>0</sub>(L) + a<sub>0</sub>(L-1)
a<sub>2</sub>(L+1) = a<sub>0</sub>(L) + a<sub>3</sub>(L) = a<sub>0</sub>(L) + a<sub>0</sub>(L-1) + a<sub>0</sub>(L-2)
a<sub>1</sub>(L+1) = a<sub>0</sub>(L) + a<sub>2</sub>(L) = a<sub>0</sub>(L) + a<sub>0</sub>(L-1) + a<sub>0</sub>(L-2) + a<sub>0</sub>(L-3)
a<sub>0</sub>(L+1) = a<sub>0</sub>(L) + a<sub>1</sub>(L) = a<sub>0</sub>(L) + a<sub>0</sub>(L-1) + a<sub>0</sub>(L-2) + a<sub>0</sub>(L-3) + a<sub>0</sub>(L-4)</code>

<p>Substituting <code>f<sub>i</sub></code> for <code>a<sub>0</sub>(i)</code> yields</p>
<code>f<sub>i+1</sub> = f<sub>i</sub> + f<sub>i-1</sub> + f<sub>i-2</sub> + f<sub>i-3</sub> + f<sub>i-4</sub></code>
for <code>i &gt; 4</code>
<p><code>f<sub>4</sub>   = 1</code></p>
<p><code>f<sub>i</sub>   = 0 </code> for <code> i &lt; 4</code></p>
<p>These numbers are the Fibonacci numbers of order 4. In general, the
Fibonacci numbers of order <code>p</code> are defined as
follows:</p>
<div class='table'>
<p><code>f<sub>i+1</sub>(p) = f<sub>i</sub>(p) + f<sub>i-1</sub>(p) + ... + f<sub>i-p</sub>(p) </code>
for <code> i &gt; p</code></p>
<code>f<sub>p</sub>(p)   = 1</code>
<p><code>f<sub>i</sub>(p)   = 0 </code> for <code> 0 ≤ i &lt; p</code></p>
</div>

<p>Note that the ordinary Fibonacci numbers are those of order 1.</p>

<p>We have now seen that the initial numbers of runs for a perfect
Polyphase Sort with <code>N</code> sequences are the
sums of any <code>N-1, N-2, ... , 1</code> (see Table
2.15) consecutive Fibonacci numbers of order <code>N-2</code>.</p>

<div class='table'><table>
<tr>
<td>L \ N:</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td></tr>
<tr>
<td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr>
<tr>
<td>2</td><td>3</td><td>5</td><td>7</td><td>9</td><td>11</td><td>13</td></tr>
<tr>
<td>3</td><td>5</td><td>9</td><td>13</td><td>17</td><td>21</td><td>25</td></tr>
<tr>
<td>4</td><td>8</td><td>17</td><td>25</td><td>33</td><td>41</td><td>49</td></tr>
<tr>
<td>5</td><td>13</td><td>31</td><td>49</td><td>65</td><td>81</td><td>97</td></tr>
<tr>
<td>6</td><td>21</td><td>57</td><td>94</td><td>129</td><td>161</td><td>193</td></tr>
<tr>
<td>7</td><td>34</td><td>105</td><td>181</td><td>253</td><td>321</td><td>385</td></tr>
<tr>
<td>8</td><td>55</td><td>193</td><td>349</td><td>497</td><td>636</td><td>769</td></tr>
<tr>
<td>9</td><td>89</td><td>355</td><td>673</td><td>977</td><td>1261</td><td>1531</td></tr>
<tr>
<td>10</td><td>144</td><td>653</td><td>1297</td><td>1921</td><td>2501</td><td>3049</td></tr>
<tr>
<td>11</td><td>233</td><td>1201</td><td>2500</td><td>3777</td><td>4961</td><td>6073</td></tr>
<tr>
<td>12</td><td>377</td><td>2209</td><td>4819</td><td>7425</td><td>9841</td><td>12097</td></tr>
<tr>
<td>13</td><td>610</td><td>4063</td><td>9289</td><td>14597</td><td>19521</td><td>24097</td></tr>
<tr>
<td>14</td><td>987</td><td>7473</td><td>17905</td><td>28697</td><td>38721</td><td>48001</td></tr>
</table></div>
<p>Table 2.15. Numbers of runs allowing for perfect distribution.</p>

<p>This apparently implies that this method is only applicable to
inputs whose number of runs is the sum of <code>N-1</code>
such Fibonacci sums. The important question thus
arises: What is to be done when the number of initial runs is not
such an ideal sum? The answer is simple (and typical for such
situations): we simulate the existence of hypothetical empty runs,
such that the sum of real and hypothetical runs is a perfect sum.
The empty runs are called <i>dummy runs</i>.</p>

<p>But this is not really a satisfactory answer because it immediately
raises the further and more difficult question: How do we recognize
dummy runs during merging? Before answering this question we must
first investigate the prior problem of initial run distribution and
decide upon a rule for the distribution of actual and dummy runs
onto the <code>N-1</code> tapes.</p>

<p>In order to find an appropriate rule for distribution, however, we
must know how actual and dummy runs are merged. Clearly, the
selection of a dummy run from sequence <code>i</code>means
precisely that sequence <code>i</code> is ignored
during this merge. resulting in a merge
from fewer than <code>N-1</code> sources. Merging of a
dummy run from all <code>N-1</code> sources implies no
actual merge operation, but instead the recording of the resulting
dummy run on the output sequence. From this we conclude that dummy
runs should be distributed to the <code>n-1</code>
sequences as uniformly as possible, since we are interested in
active merges from as many sources as possible.</p>

<p>Let us forget dummy runs for a moment and consider the problem of
distributing an unknown number of runs onto <code>N-1</code>
sequences. It is plain that the Fibonacci numbers
of order <code>N-2</code> specifying the desired numbers
of runs on each source can be generated while the distribution
progresses. Assuming, for example, <code>N = 6</code>
and referring to Table 2.14, we start by distributing runs as
indicated by the row with index <code>L = 1 (1, 1, 1, 1, 1)</code>;
if there are more runs available, we proceed to the
second row <code>(2, 2, 2, 2, 1)</code>; if the source
is still not exhausted, the distribution proceeds according to the
third row <code>(4, 4, 4, 3, 2)</code>, and so on. We
shall call the row index <i>level</i>. Evidently, the larger the
number of runs, the higher is the level of Fibonacci numbers which,
incidentally, is equal to the number of merge passes or switchings
necessary for the subsequent sort. The distribution algorithm can
now be formulated in a first version as follows:
</p>

<ol id="l51">
<li data-list-text="1.">
<p>Let the distribution goal be the Fibonacci numbers of order
<code>N-2</code>, level 1.</p>
</li>
<li data-list-text="2.">
<p>Distribute according to the set goal.</p>
</li>
<li data-list-text="3.">
<p>If the goal is reached, compute the next level of Fibonacci
numbers; the difference between them and those on the former level
constitutes the new distribution goal. Return to step 2. If the
goal cannot be reached because the source is exhausted, terminate
the distribution process.</p>
</li>
</ol>

<p>The rules for calculating the next level of Fibonacci numbers are
contained in their definition. We can thus concentrate our
attention on step 2, where, with a given goal, the subsequent runs
are to be distributed one after the other onto the <code>N-1</code>
output sequences. It is here where the dummy runs
have to reappear in our considerations.</p>

<p>Let us assume that when raising the level, we record the next goal
by the differences <code>d<sub>i</sub></code> for <code>i = 0 ... N-2</code>, where
<code>d<sub>i</sub></code> denotes the
number of runs to be put onto sequence <code>i</code> in
this step. We can now assume that we immediately put
<code>d<sub>i</sub></code> dummy runs onto sequence
<code>i</code> and then regard the subsequent
distribution as the replacement of dummy runs by actual runs, each
time recording a replacement by subtracting 1 from the count
<code>d<sub>i</sub></code>. Thus, the
<code>d<sub>i</sub></code> indicates the
number of dummy runs on sequence <code>i</code> when the
source becomes empty.</p>

<p>It is not known which algorithm yields the optimal distribution,
but the following has proved to be a very good method. It is called
<i>horizontal distribution</i> (cf. Knuth, Vol 3. p. 270), a term
that can be understood by imagining the runs as being piled up in
the form of silos, as shown in Fig. 2.16 for <code>N = 6</code>,
level <code>5</code> (cf. Table 2.14). In
order to reach an equal distribution of remaining dummy runs as
quickly as possible, their replacement by actual runs reduces the size of the
piles by picking off dummy runs on horizontal levels proceeding
from left to right. In this way, the runs are distributed onto the
sequences as indicated by their numbers as shown in Fig. 2.16.</p>

<img src="fig/2.16.png" width="280"/>
<p>Fig. 2.16. Horizontal distribution of runs</p>

<p>We are now in a position to describe the algorithm in the form of a
procedure called <code>select</code>, which is activated
each time a run has been copied and a new source is selected for
the next run. We assume the existence of a variable <code>j</code>
denoting the index of the current destination sequence.
<code>a<sub>i</sub></code> and
<code>d<sub>i</sub></code> denote the
ideal and dummy distribution numbers for sequence <code>i</code>.</p>
<code class='large'>j, level: INTEGER;
a, d: ARRAY N OF INTEGER;</code>
<p>These variables are initialized with the following values:</p>

<div class='table'><table>
<tr>
<td>a<sub>i</sub> = 1,
<p class="s14">
a<sub>N-1</sub> = 0,</p>
</td>
<td>
d<sub>i</sub> = 1
<p class="s14">
d<sub>N-1</sub> = 0</p>
</td>
<td>
for <span class="s14">i = 0 ... N-2</span>
<p class="s42">
dummy</p>
</td>
</tr>
<tr>
<td>j = 0,</td><td>level = 0</td><td>

</td>
</tr>
</table></div>

<p>Note that <code>select</code> is to
compute the next row of Table 2.14, i.e., the values
<code>a<sub>0</sub>(L) ... a<sub>N-2</sub>(L)</code>
each time that the level is increased. The next
goal, i.e., the differences
<code>d<sub>i</sub> = a<sub>i</sub>(L) - a<sub>i</sub>(L-1)</code>
are also computed at that time. The indicated
algorithm relies on the fact that the resulting
<code>d<sub>i</sub></code> decrease with
increasing index (descending stair in Fig. 2.16). Note that the
exception is the transition from level 0 to level 1; this algorithm
must therefore be used starting at level 1. <code>Select</code>
ends by decrementing <code>d<sub>j</sub></code>
by 1; this operation stands for the replacement of a
dummy run on sequence <code>j</code> by an actual run.</p>
<code class='large'>PROCEDURE select;
  VAR i, z: INTEGER;
BEGIN
  IF d[j] &lt; d[j+1] THEN
    INC(j)
  ELSE
    IF d[j] = 0 THEN
      INC(level); z := a[0];
      FOR i := 0 TO N-2 DO
        d[i] := z + a[i+1] - a[i]; a[i] := z + a[i+1]
      END
    END;
    j := 0
  END;
  DEC(d[j])
END select</code>

<p>Assuming the availability of a routine to copy a run from the
source <code>src</code> with rider <code>R</code> onto
<code>f<sub>j</sub></code> with rider <code>r<sub>j</sub></code>,
we can formulate the initial distribution phase as
follows (assuming that the source contains at least one run):</p>
<code>REPEAT select; copyrun UNTIL R.eof</code>
<p>Here, however, we must pause for a moment to recall the effect
encountered in distributing runs in the previously discussed
natural merge algorithm: The fact that two runs consecutively
arriving at the same destination may merge into a single run,
causes the assumed numbers of runs to be incorrect. By devising the
sort algorithm such that its correctness does not depend on the
number of runs, this side effect can safely be ignored. In the
Polyphase Sort, however, we are particularly concerned about
keeping track of the exact number of runs on each file.
Consequently, we cannot afford to overlook the effect of such a
coincidental merge. An additional complication of the distribution
algorithm therefore cannot be avoided. It becomes necessary to
retain the keys of the last item of the last run on each sequence.
Fortunately, our implementation of <code>Runs</code>
does exactly this. In the case of output sequences,
<code>r.first</code> represents the item last written. A next
attempt to describe the distribution algorithm could therefore
be</p>
<code class='large'>REPEAT select;
  IF r[j].first &lt;= R.first THEN <code class='pseudo'>continue old run</code> END;
  copyrun
UNTIL R.eof</code>

<p>The obvious mistake lies in forgetting that <code>r[j].first</code> has only obtained a
(defined) value after copying the first run! A correct solution first distributes
one run onto each of the <code>N-1</code> destination sequences without inspection
of <code>first</code>. The remaining runs are distributed as follows:</p>
<code class='large'>WHILE ~R.eof DO
  select;
  IF r[j].first &lt;= R.first THEN
    copyrun;
    IF R.eof THEN INC(d[j]) ELSE copyrun END
  ELSE
    copyrun
  END
END</code>
<p>Now we are finally in a position to tackle the main polyphase merge
sort algorithm. Its principal structure is similar to the main part
of the <code>N</code>-way merge program: An outer loop
whose body merges runs until the sources are exhausted, an inner
loop whose body merges a single run from each source, and an
innermost loop whose body selects the initial key and transmits the
involved item to the target file. The principal differences to
balanced merging are the following:</p>

<ol id="l52">
<li data-list-text="1.">
<p>Instead of <code>N</code>, there is only one output
sequence in each pass.</p>
</li>
<li data-list-text="2.">
<p>Instead of switching <code>N</code> input and
<code>N</code> output sequences after each pass, the
sequences are rotated. This is achieved by using a sequence index
map <code>t</code>.</p>
</li>
<li data-list-text="3.">
<p>The number of input sequences varies from run to
run; at the start of each run, it is determined from the
counts <code>d<sub>i</sub></code> of dummy
runs. If <code>d<sub>i</sub> &gt; 0</code> for all <code>i</code>,
then <code>N-1</code> dummy runs are pseudo-merged into a single
dummy run by merely incrementing the count <code>d<sub>N-1</sub></code>
of the output sequence. Otherwise, one run is merged from all sources with
<code>d<sub>i</sub> = 0</code>, and <code>d<sub>i</sub></code>
is decremented for all other
sequences, indicating that one dummy run was taken off. We denote
the number of input sequences involved in a merge by
<code>k</code>.
</p>
</li>
<li data-list-text="4.">
<p>It is impossible to derive termination of a phase by the end-of
status of the <code>N-1</code>'st sequence, because more
merges might be necessary involving dummy runs from that source.
Instead, the theoretically necessary number of runs is determined
from the coefficients <code>a<sub>i</sub></code>.
The coefficients <code>a<sub>i</sub></code> were computed during the
distribution phase; they can now be recomputed backward.</p>
</li>
</ol>

<p>The main part of the Polyphase Sort can now be formulated according
to these rules, assuming that all
<code>N-1</code> sequences with initial runs are set to be read,
and that the tape map is initially set to <code>t<sub>i</sub> = i</code>.</p>
<code class='large'>REPEAT (*merge from t[0] ... t[N-2] to t[N-1]*)
  z := a[N-2]; d[N-1] := 0;
  REPEAT (*merge one run*)
    k := 0;
    (*determine no. of active sequences*)
    FOR i := 0 TO N-2 DO
      IF d[i] &gt; 0 THEN
        DEC(d[i])
      ELSE
        ta[k] := t[i]; INC(k)
      END
    END;
    IF k = 0 THEN
      INC(d[N-1])
    ELSE
      <code class='pseudo'>merge one real run from t[0] ... t[k-1] to t[N-1]</code>
    END;
    DEC(z)
  UNTIL z = 0;
  Runs.Set(r[t[N-1]], f[t[N-1]]);
  <code class='pseudo'>rotate sequences in map t;
  compute a[i] for next level;</code>
  DEC(level)
UNTIL level = 0
(*sorted output is f[t[0]]*)</code>

<p>The actual merge operation is almost identical with that of the
<code>N</code>-way merge sort, the only difference being
that the sequence elimination algorithm is somewhat simpler. The
rotation of the sequence index map and the corresponding counts
<code>d<sub>i</sub></code> (and the down-level recomputation
of the coefficients <code>a<sub>i</sub></code>) is straightforward and can
be inspected in the following program that represents the Polyphase
algorithm in its entirety.</p>
<code class='large'>PROCEDURE Polyphase (src: Files.File): Files.File; <span>(* ADenS24_MergeSorts *)</span>
  VAR i, j, mx, tn: INTEGER;
    k, dn, z, level: INTEGER; x, min: INTEGER;
    a, d: ARRAY N OF INTEGER;
    t, ta: ARRAY N OF INTEGER; (*index maps*)
    R: Runs.Rider; (*source*)
    f: ARRAY N OF Files.File;
    r: ARRAY N OF Runs.Rider;

  PROCEDURE select;
    VAR i, z: INTEGER;
  BEGIN
    IF d[j] &lt; d[j+1] THEN
      INC(j)
    ELSE
      IF d[j] = 0 THEN
        INC(level); z := a[0];
        FOR i := 0 TO N-2 DO
          d[i] := z + a[i+1] - a[i]; a[i] := z + a[i+1]
        END
      END;
      j := 0
    END;
    DEC(d[j])
  END select;

  PROCEDURE copyrun; (*from src to f[j]*)
  BEGIN
    REPEAT Runs.copy(R, r[j]) UNTIL R.eor
  END copyrun;

BEGIN
  Runs.Set(R, src);
  FOR i := 0 TO N-2 DO
    a[i] := 1; d[i] := 1;
    f[i] := Files.New(""); Files.Set(r[i], f[i], 0)
  END;
  (*distribute initial runs*)
  level := 1; j := 0; a[N-1] := 0; d[N-1] := 0;
  REPEAT
    select; copyrun
  UNTIL R.eof OR (j = N-2);

  WHILE ~R.eof DO
    select; (*r[j].first = last item written on f[j]*)
    IF r[j].first &lt;= R.first THEN
      copyrun;
      IF R.eof THEN INC(d[j]) ELSE copyrun END
    ELSE
      copyrun
    END
  END;
  FOR i := 0 TO N-2 DO
    t[i] := i; Runs.Set(r[i], f[i])
  END;
  t[N-1] := N-1;
  REPEAT (*merge from t[0] ... t[N-2] to t[N-1]*)
    z := a[N-2]; d[N-1] := 0;
    f[t[N-1]] := Files.New(""); Files.Set(r[t[N-1]], f[t[N-1]], 0);
    REPEAT (*merge one run*)
      k := 0;
      FOR i := 0 TO N-2 DO
        IF d[i] &gt; 0 THEN
          DEC(d[i])
        ELSE
          ta[k] := t[i]; INC(k)
        END
      END;
      IF k = 0 THEN
        INC(d[N-1])
      ELSE (*merge one real run from t[0] ... t[k-1] to t[N-1]*)
        REPEAT
          mx := 0;
          min := r[ta[0]].first; i := 1;
          WHILE i &lt; k DO
            x := r[ta[i]].first;
            IF x &lt; min THEN min := x; mx := i END;
            INC(i)
          END;
          Runs.copy(r[ta[mx]], r[t[N-1]]);
          IF r[ta[mx]].eor THEN
            ta[mx] := ta[k-1]; DEC(k)
          END
        UNTIL k = 0
      END;
      DEC(z)
    UNTIL z = 0;
    Runs.Set(r[t[N-1]], f[t[N-1]]); (*rotate sequences*)
    tn := t[N-1]; dn := d[N-1]; z := a[N-2];
    FOR i := N-1 TO 1 BY -1 DO
      t[i] := t[i-1]; d[i] := d[i-1]; a[i] := a[i-1] - z
    END;
    t[0] := tn; d[0] := dn; a[0] := z;
    DEC(level)
  UNTIL level = 0 ;
  RETURN f[t[0]]
END Polyphase</code>

</li>
<br/>

<li data-list-text="2.4.5" id="2.4.5">
<h4><a href='#2.4.5' id='2.4.5'>Distribution of Initial Runs</a></h4>

<p>We were led to the sophisticated sequential sorting programs,
because the simpler methods operating on arrays rely on the
availability of a random access store sufficiently large to hold
the entire set of data to be sorted. Often such a store is
unavailable; instead, sufficiently large sequential storage devices
such as tapes or disks must be used. We know that the sequential
sorting methods developed so far need practically no primary store
whatsoever, except for the file buffers and, of course, the program
itself. However, it is a fact that even small computers include a
random access, primary store that is almost always larger than what
is needed by the programs developed here. Failing to make optimal
use of it cannot be justified.</p>

<p>The solution lies in combining array and sequence sorting
techniques. In particular, an adapted array sort may be used in the
distribution phase of initial runs with the effect that these runs
do already have a length <code>L</code> of approximately
the size of the available primary data store. It is plain that in
the subsequent merge passes no additional array sorts could improve
the performance because the runs involved are steadily growing in
length, and thus they always remain larger than the available main
store. As a result, we may fortunately concentrate our attention on
improving the algorithm that generates initial runs.</p>

<p>Naturally, we immediately concentrate our search on the logarithmic
array sorting methods. The most suitable of them is the tree sort
or <code>HeapSort</code> method (see Sect. 2.3.2). The
heap may be regarded as a funnel through which all items must pass,
some quicker and some more slowly. The least key is readily picked
off the top of the heap, and its replacement is a very efficient
process. The action of funnelling a component from the input
sequence <code>src</code> (rider <code>r0</code>)
through a full heap <code>H</code> onto
an output sequence <code>dest</code> (rider <code>r1</code>)
may be described simply as follows:</p>

<code class='large'>Write(r1, H[0]); Read(r0, H[0]); sift(0, n-1)</code>

<p><code>Sift</code> is the process described in Sect. 2.3.2 for
sifting the newly inserted component <code>H<sub>0</sub></code>
down into its proper place. Note that <code>H<sub>0</sub></code>
is the least item on the heap. An example is shown in Fig. 2.17.
The program eventually becomes considerably more complex for the
following reasons:</p>

<ol id="l53">
<li data-list-text="1.">
<p>The heap <code>H</code> is initially empty and must
first be filled.</p>
</li>
<li data-list-text="2.">
<p>Toward the end, the heap is only partially filled, and it
ultimately becomes empty.</p>
</li>
<li data-list-text="3.">
<p>We must keep track of the beginning of new runs in order to change
the output index <code>j</code> at the right time.</p>
</li>
</ol>

<img src="fig/2.17.png" width="600"/>
<p>Fig. 2.17. Sifting a key through a heap</p>

<p>Before proceeding, let us formally declare the variables that are
evidently involved in the process:</p>
<code class='large'>VAR L, R, x: INTEGER;
  src, dest: Files.File; r, w: Files.Rider;
  H: ARRAY M OF INTEGER; (*heap*)</code>

<p><code>M</code> is the size of the heap <code>H</code>.
We use the constant <code>mh</code> to denote
<code>M/2</code>; <code>L</code> and <code>R</code> are indices
delimiting the heap. The funnelling process can then be divided
into five distinct parts.</p>

<ol id="l54">
<li data-list-text="1.">
  Read the first <code>mh</code> keys from <span class=
  "s7">src</span> (<code>r</code>) and put them into the
  upper half of the heap where no ordering among the keys is
  prescribed.
</li>
<li data-list-text="2.">
  Read another <code>mh</code> keys and put them into the
  lower half of the heap, sifting each item into its appropriate
  position (build heap).
</li>
<li data-list-text="3.">
  Set <code>L</code> to <code>M</code>
  and repeat the following step for all remaining
  items on <code>src</code>: Feed <code>H<sub>0</sub></code>
  to the appropriate output sequence.
  If its key is less or equal to the key of the next item on the
  input sequence, then this next item belongs to the same run and can
  be sifted into its proper position. Otherwise, reduce the size of
  the heap and place the new item into a second, upper heap that is
  built up to contain the next run. We indicate the borderline
  between the two heaps with the index <code>L</code>.
  Thus, the lower (current) heap consists of the items
  <code>H<sub>0</sub> ... H<sub>L-1</sub></code>, the upper (next) heap of
  <code>H<sub>L</sub> ... H<sub>M-1</sub></code>.
  If <code>L = 0</code>, then switch the
  output and reset <code>L</code> to <code>M</code>.
</li>
<li data-list-text="4.">
Now the source is exhausted. First, set <code>R</code>
to <code>M</code>; then flush the lower
part terminating the current run, and at the same time build up the
upper part and gradually relocate it into positions
<code>H<sub>L</sub> ... H<sub>R-1</sub></code>.
</p>
</li>
<li data-list-text="5.">
<p>The last run is generated from the remaining items in the heap.</p>
</li>
</ol>

<p>We are now in a position to describe the five stages in detail as a
complete program, calling a procedure <code>switch</code>
whenever the end of a run is detected and some
action to alter the index of the output sequence has to be invoked.
In the program presented below, a dummy routine is used instead,
and all runs are written onto sequence <code>dest</code>.</p>

<p>If we now try to integrate this program with, for instance, the
<code>Polyphase</code> sort, we encounter a serious
difficulty. It arises from the following circumstances: The sort
program consists in its initial part of a fairly complicated
routine for switching between sequence variables, and relies on the
availability of a procedure <code>copyrun</code> that
delivers exactly one run to the selected destination. The
<code>HeapSort</code> program, on the other hand, is a
complex routine relying on the availability of a closed procedure
<code>select</code> which simply selects a new
destination. There would be no problem, if in one (or both) of the
programs the required procedure would be called at a single place
only; but instead, they are called at several places in both
programs.</p>

<p>This situation is best reflected by the use of a coroutine
(thread); it is suitable in those cases in which several processes
coexist. The most typical representative is the combination of a
process that produces a stream of information in distinct entities
and a process that consumes this stream. This producer-consumer
relationship can be expressed in terms of two coroutines; one of
them may well be the main program itself. The coroutine may be
considered as a process that contains one or more breakpoints. If
such a breakpoint is encountered, then control returns to the
program that had activated the coroutine. Whenever the coroutine is
called again, execution is resumed at that breakpoint. In our
example, we might consider the <code>Polyphase</code>
sort as the main program, calling upon <code>copyrun</code>,
which is formulated as a coroutine. It
consists of the main body of the program presented below, in which
each call of <code>switch</code> now represents a
breakpoint. The test for <i>end of file</i> would then have to be
replaced systematically by a test of whether or not the coroutine
had reached its endpoint.</p>
<code class='large'>PROCEDURE Distribute (src: Files.File): Files.File; <span>(* ADenS24_MergeSorts *)</span>
  CONST M = 16; mh = M DIV 2; (*heap size*)
    VAR L, R: INTEGER;
      x: INTEGER;
      dest: Files.File; r, w: Files.Rider;
      H: ARRAY M OF INTEGER; (*heap*)

    PROCEDURE sift (L, R: INTEGER); VAR i, j, x: INTEGER;
    BEGIN
      i := L; j := 2*L+1; x := H[i];
      IF (j &lt; R) &amp; (H[j] &gt; H[j+1]) THEN
        INC(j)
      END;
      WHILE (j &lt;= R) &amp; (x &gt; H[j]) DO
        H[i] := H[j]; i := j; j := 2*j+1;
        IF (j &lt; R) &amp; (H[j] &gt; H[j+1]) THEN INC(j) END
      END;
      H[i] := x
    END sift;

  BEGIN
    Files.Set(r, src, 0);
    dest := Files.New(""); Files.Set(w, dest, 0);
  (*step 1: fill upper half of heap*)
    L := M;
    REPEAT DEC(L); Files.ReadInt(r, H[L]) UNTIL L = mh;
  (*step 2: fill lower half of heap*)
    REPEAT DEC(L); Files.ReadInt(r, H[L]); sift(L, M-1) UNTIL L = 0;
  (*step 3: pass elements through heap*)
    L := M;
    Files.ReadInt(r, x);
    WHILE ~r.eof DO
      Files.WriteInt(w, H[0]);
      IF H[0] &lt;= x THEN
        (*x belongs to same run*) H[0] := x; sift(0, L-1)
      ELSE (*start next run*)
        DEC(L); H[0] := H[L]; sift(0, L-1); H[L] := x;
        IF L &lt; mh THEN sift(L, M-1) END;
        IF L = 0 THEN (*heap full; start new run*) L := M END
      END;
      Files.ReadInt(r, x)
    END;
  (*step 4: flush lower half of heap*)
    R := M;
    REPEAT
      DEC(L); Files.WriteInt(w, H[0]);
      H[0] := H[L]; sift(0, L-1); DEC(R); H[L] := H[R];
      IF L &lt; mh THEN
        sift(L, R-1)
      END;
    UNTIL L = 0;
  (*step 5: flush upper half of heap, start new run*)
    WHILE R &gt; 0 DO
      Files.WriteInt(w, H[0]); H[0] := H[R]; DEC(R); sift(0, R)
    END;
    RETURN dest
  END Distribute</code>

<p><i><b>Analysis and conclusions.</b></i> What performance can be
expected from a <code>Polyphase</code> sort with initial
distribution of runs by a <code>HeapSort</code>? We
first discuss the improvement to be expected by introducing the
heap.</p>

<p>In a sequence with randomly distributed keys the expected average
length of runs is 2. What is this length after the sequence has
been funnelled through a heap of size <code>m</code>?
One is inclined to say <code>m</code>, but, fortunately,
the actual result of probabilistic analysis is much better, namely
<code>2m</code> (see Knuth, vol. 3, p. 254). Therefore,
the expected improvement factor is <code>m</code>.</p>

<p>An estimate of the performance of <code>Polyphase</code>
can be gathered from Table 2.15, indicating the maximal number of
initial runs that can be sorted in a given number of partial passes
(levels) with a given number <code>N</code> of
sequences. As an example, with six sequences and a heap of size
<code>m = 100</code>, a file with up to 165’680’100
initial runs can be sorted within 10 partial passes. This is a
remarkable performance.</p>

<p>Reviewing again the combination of <code>Polyphase</code>
and <code>HeapSort</code>one
cannot help but be amazed at the complexity of this program. After
all, it performs the same easily defined task of permuting a set of
items as is done by any of the short programs based on the straight
array sorting principles. The moral of the entire chapter may be
taken as an exhibition of the following:</p>

<ol id="l55">
<li data-list-text="1.">
<p>The intimate connection between algorithm and underlying data
structure, and in particular the influence of the latter on the
former.</p>
</li>
<li data-list-text="2.">
<p>The sophistication by which the performance of a program can be
improved, even when the available structure for its data (sequence
instead of array) is rather ill-suited for the task.</p>
</ol>

<h3 id="2.exe"><a href='#2.exe'>Exercises</a></h3>
<ol class="noindent" id="l56">
<li data-list-text="2.1.">
Which of the algorithms given for straight insertion, binary
insertion, straight selection, bubble sort, shakersort, shellsort,
heapsort, quicksort, and straight mergesort are stable sorting
methods?
</li>
<li data-list-text="2.2.">
<p>Would the algorithm for binary insertion still work
correctly if <code>L &lt; R</code> were replaced
by <code>L ≤ R</code> in the
while clause? Would it still be correct if the statement
<code>L := m+1</code> were simplified to <code>L := m</code>?
If not, find sets of values <code>a<sub>0</sub> ... a<sub>n-1</sub></code>
upon which the altered program would fail.</p>
</li>

<li data-list-text="2.3.">
Program and measure the execution time of the three straight
sorting methods on your computer, and find coefficients by which
the factors <code>C</code> and <code>M</code>
have to be multiplied to yield real time estimates.
</li>
<li data-list-text="2.4.">
Specifty invariants for the repetitions in the three straight
sorting algorithms.
</li>
<li data-list-text="2.5.">
<p>Consider the following "obvious" version of the
procedure <code>Partition</code> and find sets of
values <code>a<sub>0</sub> ... a<sub>n-1</sub></code>
for which this version fails:</p>
<code class='large'>i := 0; j := n-1; x := a[n DIV 2];
REPEAT
  WHILE a[i] &lt; x DO i := i+1 END;
  WHILE x &lt; a[j] DO j := j-1 END;
  w := a[i]; a[i] := a[j]; a[j] := w
UNTIL i &gt; j</code>

</li>
<li data-list-text="2.6.">
Write a procedure that combines the <code>QuickSort</code>
and <code>BubbleSort</code>
algorithms as follows: Use <code>QuickSort</code> to
obtain (unsorted) partitions of length <code>m</code>
(<code>1 &lt; m &lt; n</code>); then use <code>BubbleSort</code>
to complete the task. Note that the latter
may sweep over the entire array of <code>n</code>
elements, hence, minimizing the bookkeeping effort. Find that value
of <code>m</code> which minimizes the total sort time.
Note: Clearly, the optimum value of <code>m</code> will
be quite small. It may therefore pay to let the
<code>BubbleSort</code> sweep exactly <code>m-1</code>
times over the array instead of including a last pass establishing
the fact that no further exchange is necessary.
</li>
<li data-list-text="2.7.">
Perform the same experiment as in Exercise 2.6 with a straight
selection sort instead of a <code>BubbleSort</code>.
Naturally, the selection sort cannot sweep over the whole array;
therefore, the expected amount of index handling is somewhat
greater.
</li>
<li data-list-text="2.8.">
Write a recursive QuickSort algorithm according to the recipe that
the sorting of the shorter partition should be tackled before the
sorting of the longer partition. Perform the former task by an
iterative statement, the latter by a recursive call. (Hence, your
sort procedure will contain only one recursive call instead of
two.
</li>
<li data-list-text="2.9.">
<p>Find a permutation of the keys <code>1, 2, ... , n</code>
for which <code>QuickSort</code> displays its
worst (best) behavior (<code>n = 5, 6, 8</code>).</p>
</li>
<li data-list-text="2.10.">
<p>Construct a natural merge program similar to the straight merge,
operating on a double length array</p>

<p>from both ends inward; compare its performance with that of the
procedure given in this text.</p>
</li>
<li data-list-text="2.11.">

<p>Note that in a (two-way) natural merge we do not blindly select the
least value among the available keys. Instead, upon encountering
the end of a run, the tail of the other run is simply copied onto
the output sequence. For example, merging of</p>
<code class='large'>2, 4, 5, 1, 2, ...
3, 6, 8, 9, 7, ...</code>
<p>results in the sequence</p>
<code>2, 3, 4, 5, 6, 8, 9, 1, 2, ...</code>
<p>instead of</p>
<code>2, 3, 4, 5, 1, 2, 6, 8, 9, ...</code>
<p>which seems to be better ordered. What is the reason for this
strategy?</p>
</li>
<li data-list-text="2.12.">
<p>A sorting method similar to the Polyphase is the so-called Cascade
merge sort [2.1 and 2.9]. It uses a different merge pattern. Given,
for instance, six sequences <code>T0</code> ...
<code>T5</code>, the cascade merge, also starting with a
"perfect distribution" of runs on <code>T0 ... T4</code>,
performs a five-way merge from <code>T0 ... T4</code>
onto <code>T5</code> until <code>T4</code> is empty,
then (without involving <code>T5</code>)
a four-way merge onto <code>T4</code>,
then a three-way merge onto <code>T3</code>, a two-way
merge onto <code>T2</code>, and finally a copy operation
from <code>T0</code> onto <code>T1</code>.
The next pass operates in the same way starting with a five-way
merge to <code>T0,</code> and so on. Although this
scheme seems to be inferior to Polyphase because at times it
chooses to leave some sequences idle, and because it involves
simple copy operations, it surprisingly is superior to Polyphase
for (very) large files and for six or more sequences. Write a well
structured program for the Cascade merge principle.</p>
</li>
</ol>
</li>
</ol>

<h3 id="2.ref">References</h3>
<p><a href="#[2.1]" id="[2.1]">[2.1]</a>
 B. K. Betz and Carter. <i>Proc. ACM National Conf</i>. 14,
(1959), Paper 14.</p>

<p><a href="#[2.2]" id="[2.2]">[2.2]</a>
 R.W. Floyd. Treesort (Algorithms 113 and 243). <i>Comm.
ACM</i>, 5, No. 8, (1962), 434, and
<i>Comm. ACM</i>, 7, No. 12 (1964), 701.</p>

<p><a href="#[2.3]" id="[2.3]">[2.3]</a>
R.L. Gilstad. Polyphase Merge Sorting - An Advanced
Technique. <i>Proc. AFIPS Eastern Jt. Comp. Conf.</i>,
18, (1960), 143-48.</p>

<p><a href="#[2.4]" id="[2.4]">[2.4]</a>
C.A.R. Hoare. Proof of a Program: FIND. <i>Comm. ACM</i>, 13,
No. 1, (1970), 39-45.</p>
<p><a href="#[2.5]" id="[2.5]">[2.5]</a>
C.A.R. Hoare. Proof of a Recursive Program: Quicksort.
<i>Comp. J.</i>, 14, No. 4 (1971), 391-95.</p>

<p><a href="#[2.6]" id="[2.6]">[2.6]</a>
C.A.R. Hoare. Quicksort. <i>Comp.J.</i>, 5. No.1 (1962),
10-15.</p>

<p><a href="#[2.7]" id="[2.7]">[2.7]</a>
D.E. Knuth. The Art of Computer Programming. Vol. 3. Reading,
Mass.: Addison- Wesley, 1973.</p>

<p><a href="#[2.8]" id="[2.8]">[2.8]</a>
H. Lorin. A Guided Bibliography
to Sorting. <i>IBM Syst. J.</i>, 10, No. 3 (1971), 244-254.</p>

<p><a href="#[2.9]" id="[2.9]">[2.9]</a>
D.L. Shell. A Highspeed Sorting Procedure. <i>Comm. ACM</i>,
2, No. 7 (1959), 30-32.</p>

<p><a href="#[2.10]" id="[2.10]">[2.10]</a> R.C.
Singleton. An Efficient Algorithm for Sorting with
Minimal Storage (Algorithm 347). <i>Comm.ACM</i>,
12, No. 3 (1969), 185.</p>

<p><a href="#[2.11]" id="[2.11]">[2.11]</a>
M.H. Van Emden. Increasing the Efficiency of Quicksort
(Algorithm 402). <i>Comm. ACM</i>, 13, No. 9 (1970), 563-66, 693.</p>

<p><a href="#[2.12]" id="[2.12]">[2.12]</a> J.W.J. Williams. Heapsort (Algorithm 232) <i>Comm. ACM</i>,
7, No. 6 (1964), 347-48.</p>

</li>
</ol>
<p class="newpage"></p>
</li>

<li data-list-text="3" id="3">
<h2><a href='#3'>Recursive Algorithms</a></h2>
<ol class="page" id="l57">
<li data-list-text="3.1" id="3.1">
<h3><a href='#3.1'>Introduction</a></h3>

<p>An object is said to be recursive, if it partially consists or is
defined in terms of itself. Recursion is encountered not only in
mathematics, but also in daily life. Who has never seen an
advertising picture which contains itself?</p>

<div class='table'><table>
<tr>
<td><img width="318" height="200" src=
"data:image/jpg;base64,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" /></td>
</tr>
</table></div>

<p>Fig. 3.1. A picture with a recursion</p>

<p>Recursion is a particularly powerful technique in mathematical
definitions. A few familiar examples are those of natural numbers,
tree structures, and of certain functions:</p>
<ol id="l58">
<li data-list-text="1.">
<p>Natural numbers:</p>
<ol id="l59">
<li data-list-text="(a)">
<p>0 is a natural number.</p>
</li>
<li data-list-text="(b)">
<p>the successor of a natural number is a natural number.</p>
</li>
</ol>
</li>
<li data-list-text="2.">
<p>Tree structures:</p>
<ol id="l60">
<li data-list-text="(a)">
∅ is a tree (called the empty tree).</p>
</li>
<li data-list-text="(b)">
<p>If <code>t<sub>1</sub></code> and <code>t<sub>2</sub></code> are
trees, then the structure consisting of a node with two
descendants <code>t<sub>1</sub></code> and <code>t<sub>2</sub></code>
is also a (binary) tree.</p>
</li>
</ol>
</li>
<li data-list-text="3.">
<p>The factorial function <code>f(n)</code>:</p>
  <code>f(0) = 1</code>
<p><code>f(n) = n × f(n - 1) </code> for <code> n &gt; 0</code></p>
</li>
</ol>

<p>The power of recursion evidently lies in the possibility of
defining an infinite set of objects by a finite statement. In the
same manner, an infinite number of computations can be described by
a finite recursive program, even if this program contains no
explicit repetitions. Recursive algorithms, however, are primarily
appropriate when the problem to be solved, or the function to be
computed, or the data structure to be processed are already defined
in recursive terms. In general, a recursive program <code>P</code>
can be expressed as a composition <code><b>P</b></code> of a sequence
of statements <code>S</code> (not containing <code>P</code>) and
<code>P</code> itself.</p>
<code>P ≡ </b>P</b>[S, P]</code>
<p>The necessary and sufficient tool for expressing programs
recursively is the procedure or subroutine, for it allows a
statement to be given a name by which this statement may be
invoked. If a procedure <code>P</code> contains an
explicit reference to itself, then it is said to be <i>directly
recursive</i>; if <code>P</code> contains a reference to
another procedure <code>Q</code>, which contains a
(direct or indirect) reference to <code>P</code>, then
<code>P</code> is said to be <i>indirectly
recursive</i>. The use of recursion may therefore not be
immediately apparent from the program text.</p>

<p>It is common to associate a set of local objects with a procedure,
i.e., a set of variables, constants, types, and procedures which
are defined locally to this procedure and have no existence or
meaning outside this procedure. Each time such a procedure is
activated recursively, a new set of local, bound variables is
created. Although they have the same names as their corresponding
elements in the set local to the previous instance of the
procedure, their values are distinct, and any conflict in naming is
avoided by the rules of scope of identifiers: the identifiers
always refer to the most recently created set of variables. The
same rule holds for procedure parameters, which by definition are
bound to the procedure.</p>

<p>Like repetitive statements, recursive procedures introduce the
possibility of non- terminating computations, and thereby also the
necessity of considering the problem of termination. A fundamental
requirement is evidently that the recursive calls of <code>P</code>
are subjected to a condition <code>B</code>,
which at some time becomes false. The scheme for
recursive algorithms may therefore be expressed more precisely by
either one of the following forms:</p>
<code class='large'>P ≡ IF B THEN <b>P</b>[S, P] END
P ≡ <b>P</b>[S, IF B THEN P END]</code>
<p>For repetitions, the basic technique of demonstrating termination
consists of</p>
<ol id="l61">
<li data-list-text="1.">
<p>defining a function <code>f(x)</code> (<code>x</code>
shall be the set of variables), such that
<code>f(x) &lt; 0</code> implies the terminating
condition (of the while or repeat clause), and</p>
</li>
<li data-list-text="2.">
<p>proving that <code>f(x)</code> decreases during each
repetition step. <code>f</code> is called the
<i>variant</i> of the repetition.</p>
</li>
</ol>

<p>In the same manner, termination of a recursion can be proved by
showing that each execution of <code>P</code> decreases
some <code>f(x)</code>, and that <code>f(x) &lt; 0</code>
implies <code>~B</code>. A particularly
evident way to ensure termination is to associate a (value)
parameter, say <code>n</code>, with <code>P</code>,
and to recursively call <code>P</code>
with <code>n-1</code> as parameter value. Substituting
<code>n &gt; 0</code> for <code>B</code> then
guarantees termination. This may be expressed by the following
program schemata:</p>
<code class='large'>P(n) ≡ IF n &gt; 0 THEN <b>P</b>[S, P(n-1)] END
P(n) ≡ <b>P</b>[S, IF n &gt; 0 THEN P(n-1) END]</code>
<p>In practical applications it is mandatory to show that the ultimate
depth of recursion is not only finite, but that it is actually
quite small. The reason is that upon each recursive activation of a
procedure <code>P</code> some amount of storage is
required to accommodate its variables. In addition to these local
variables, the current state of the computation must be recorded in
order to be retrievable when the new activation of <code>P</code>
is terminated and the old one has to be resumed. We
have already encountered this situation in the development of the
procedure <code>QuickSort</code> in Chap. 2. It was
discovered that by naively composing the program out of a statement
that splits the <code>n</code> items into two partitions
and of two recursive calls sorting the two partitions, the depth of
recursion may in the worst case approach <code>n</code>.
By a clever reassessment of the situation, it was possible to limit
the depth to l<code>og(n)</code>. The difference between
<code>n</code> and <code>log(n)</code> is
sufficient to convert a case highly inappropriate for recursion
into one in which recursion is perfectly practical.</p>
</li>

<li data-list-text="3.2" id="3.2">
<h3><a href='#3.2' id='3.2'>When Not To Use Recursion</a></h3>
<p>Recursive algorithms are particularly appropriate when the
underlying problem or the data to be treated are defined in
recursive terms. This does not mean, however, that such recursive
definitions guarantee that a recursive algorithm is the best way to
solve the problem. In fact, the explanation of the concept of
recursive algorithm by such inappropriate examples has been a chief
cause of creating widespread apprehension and antipathy toward the
use of recursion in programming, and of equating recursion with
inefficiency.</p>

<p>Programs in which the use of algorithmic recursion is to be avoided
can be characterized by a schema which exhibits the pattern of
their composition. The equivalent schemata are shown below. Their
characteristic is that there is only a single call of
<code>P</code> either at the end (or the beginning) of the
composition.</p>
<code class='large'>P ≡ IF B THEN S; P END
P ≡ S; IF B THEN P END</code>
<p>These schemata are natural in those cases in which
values are to be computed that are defined in terms of simple
recurrence relations. Let us look at the well-known example of the
factorial numbers <code>f<sub>i</sub> = i!</code>:</p>
<code><div class='table'><table>
<tr><td>i</td><td>= 0, 1, 2, 3, 4,  5,   ...</td></tr>
<tr><td>f<sub>i</sub></td><td>= 1, 1, 2, 6, 24, 120, ...</td></tr>
</table></div></code>
<p>The first number is explicitly defined as
<code>f<sub>0</sub> = 1</code>, whereas the
subsequent numbers are defined recursively in terms of their
predecessor:</p>
<code>f<sub>i+1</sub> = (i+1) * f<sub>i</sub></code>
<p>This recurrence relation suggests a recursive algorithm to compute
the <code>n</code>-th factorial number. If we introduce
the two variables <code>I</code> and <code>F</code>
to denote the values <code>i</code> and
<code>f<sub>i</sub></code> at the
<code>i</code>-th level of recursion, we find the
computation necessary to proceed to the next numbers in the
sequences to be</p>
<code>I := I + 1; F := I * F</code>
<p>and, substituting these two statements for
<code>S</code>, we obtain the recursive program</p>
<code class='large'>P ≡ IF I &lt; n THEN I := I + 1; F := I * F; P END
I := 0; F := 1; P</code>
<p>The first line is expressed in terms of our conventional
programming notation as</p>
<code class='large'>PROCEDURE P;
BEGIN
  IF I &lt; n THEN I := I + 1; F := I*F; P END
END P</code>
<p>A more frequently used, but essentially equivalent, form is the one
given below. <code>P</code> is replaced by a function
procedure <code>F</code>, i.e., a procedure with which a
resulting value is explicitly associated, and which therefore may
be used directly as a constituent of expressions. The variable
<code>F</code> therefore becomes superfluous; and the
role of <code>I</code> is taken over by the explicit
procedure parameter.</p>
<code class='large'>PROCEDURE F(I: INTEGER): INTEGER;
BEGIN
  IF I &gt; 0 THEN RETURN I * F(I - 1) ELSE RETURN 1 END
END F</code>
<p>It now is plain that in this example recursion can be replaced
quite simply by iteration. This is expressed by the program</p>
<code class='large'>I := 0; F := 1;
WHILE I &lt; n DO I := I + 1; F := I*F END</code>
<p>In general, programs corresponding to the original schemata should
be transcribed into one according to the following schema:</p>
<code>P ≡ [x := x0; WHILE B DO S END]</code>
<p>There also exist more complicated recursive composition schemes
that can and should be translated into an iterative form. An
example is the computation of the Fibonacci numbers which are
defined by the recurrence relation</p>
<code>fib<sub>n+1</sub> = fib<sub>n</sub> + fib<sub>n-1</sub> </code> for <code> n &gt; 0</code>
<p>and <code>fib<sub>1</sub> = 1</code>,
<code>fib<sub>0</sub> = 0</code>.
A direct, naive transcription leads to the recursive program</p>
<code class='large'>PROCEDURE Fib (n: INTEGER): INTEGER;
  VAR res: INTEGER;
BEGIN
  IF n = 0 THEN res := 0 ELSIF n = 1 THEN res := 1
  ELSE res := Fib(n-1) + Fib(n-2) END;
  RETURN res
END Fib</code>
<p>Computation of <code>fib<sub>n</sub></code>
by a call <code>Fib(n)</code> causes this
function procedure to be activated recursively. How often? We
notice that each call with <code>n &gt; 1</code> leads
to 2 further calls, i.e., the total number of calls grows
exponentially (see Fig. 3.2). Such a program is clearly
impractical.</p>


<img src="fig/3.2.png" width="560"/>
<p>Fig. 3.2. The 15 activations of <code>Fib(5)</code></p>

<p>But fortunately the Fibonacci numbers can be computed by an
iterative scheme that avoids the recomputation of the same values
by use of auxiliary variables such that
<code>x = fib</span><sub>i</sub></code> and
<code>y = fib</span><sub>i-1</sub></code>.</p>
<code class='large'>i := 1; x := 1; y := 0;
WHILE i &lt; n DO z := x; x := x + y; y := z; i := i + 1 END</code>

<p>Note: The assignments to <code>x</code>, <code>y</code>,
<code>z</code> may be expressed by two
assignments only without a need for the auxiliary variable
<code>z</code>: <code>x := x + y; y := x - y</code>.</p>
<p>Thus, the lesson to be drawn is to avoid the use of recursion when
there is an obvious solution by iteration. This, however, should
not lead to shying away from recursion at any price. There are many
good applications of recursion, as the following paragraphs and
chapters will demonstrate. The fact that implementations of
recursive procedures on essentially non-recursive machines exist
proves that for practical purposes every recursive program can be
transformed into a purely iterative one. This, however, involves
the explicit handling of a recursion stack, and these operations
will often obscure the essence of a program to such an extent that
it becomes most difficult to comprehend. The lesson is that
algorithms which by their nature are recursive rather than
iterative should be formulated as recursive procedures. In order to
appreciate this point, the reader is referred to the algorithms for
<code>QuickSort</code> and <code>NonRecursiveQuickSort</code> in Sect. 2.3.3 for a
comparison.</p>

<p>The remaining part of this chapter is devoted to the development of
some recursive programs in situations in which recursion is
justifiably appropriate. Also Chap. 4 makes extensive use of
recursion in cases in which the underlying data structures let the
choice of recursive solutions appear obvious and natural.</p>

</li>

<li data-list-text="3.3" id="3.3">
<h3><a href='#3.3' id='3.3'>Two Examples of Recursive Programs</a></h3>
<p>The attractive graphic pattern shown in Fig. 3.4
consists of a superposition of five curves. These curves follow a
regular pattern and suggest that they might be drawn by a display
or a plotter under control of a computer. Our goal is to discover
the recursion schema, according to which the drawing program might
be constructed. Inspection reveals that three of the superimposed
curves have the shapes shown in Fig. 3.3; we denote them by
<code>H<sub>1</sub></code>, <code>H<sub>2</sub></code> and
<code>H<sub>3</sub></code>. The figures show that
<code>H<sub>i+1</sub></code> is obtained by the
composition of four instances of
<code>H<sub>i</sub></code>
of half size and appropriate rotation, and by tying
together the four <code>H<sub>i</sub></code>
by three connecting lines. Notice that <code>H<sub>1</sub></code>
may be considered as consisting of
four instances of an empty <code>H<sub>0</sub></code>
connected by three straight lines.
<code>H<sub>i</sub></code> is called the
<em>Hilbert curve</em> of order <code>i</code>
after its inventor, the mathematician D. Hilbert (1891).</p>

<div class='table'><table><tr>
<td>
<svg width='150' height='150' viewBox='440 325 150 150' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'>
<rect fill='#FFF' stroke='#000' x='0' y='0' width='1024' height='800'/>
<path fill='none' stroke='black' stroke-width='1' d='M 544 432 h-64 v-64 h64'/>
</svg>
</td>

<td>
<svg width='150' height='150' viewBox='440 325 150 150' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'>
<rect fill='#FFF' stroke='#000' x='0' y='0' width='1024' height='800'/>
<path fill='none' stroke='black' stroke-width='1' d='M 560 448 v-32 h-32 v32 h-32 h-32 v-32 h32 v-32 h-32 v-32 h32 h32 v32 h32 v-32'/>
</svg>
</td>

<td>
<svg width='150' height='150' viewBox='440 325 150 150' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'>
<rect fill='#FFF' stroke='#000' x='0' y='0' width='1024' height='800'/>
<path fill='none' stroke='black' stroke-width='1' d='M 568 456 h-16 v-16 h16 v-16 v-16 h-16 v16 h-16 v-16 h-16 v16 v16 h16 v16 h-16 h-16 v-16 h-16 v16 h-16 h-16 v-16 h16 v-16 h-16 v-16 h16 h16 v16 h16 v-16 v-16 v-16 h-16 v16 h-16 h-16 v-16 h16 v-16 h-16 v-16 h16 h16 v16 h16 v-16 h16 h16 v16 h-16 v16 v16 h16 v-16 h16 v16 h16 v-16 v-16 h-16 v-16 h16'/>
</svg>
</td>
</tr>

<tr><th>H1</th><th>H2</th><th>H3</th></tr>
</table></div>

<p>Fig. 3.3. Hilbert curves of order 1, 2, and 3</p>

<p>Since each curve <code>H<sub>i</sub></code>
consists of four half-sized copies of <code>H<sub>i-1</sub></code>,
we express the procedure
for drawing <code>H<sub>i</sub></code> as
a composition of four calls for drawing
<code>H<sub>i-1</sub></code> in half size and
appropriate rotation. For the purpose of illustration we denote the
four parts by <code>A</code>, <code>B</code>,
<code>C</code> and <code>D</code>, and the
routines drawing the interconnecting lines by arrows pointing in
the corresponding direction. Then the following recursion scheme
emerges (see Fig. 3.3).</p>

<div class='table'><table>
<tr>
<td>A:</td><td>D</td><td>←</td><td>A</td><td>↓</td><td>A</td><td>→</td><td>B</td></tr>
<tr>
<td>B:</td><td>C</td><td>↑</td><td>B</td><td>→</td><td>B</td><td>↓</td><td>A</td></tr>
<tr>
<td>C:</td><td>B</td><td>→</td><td>C</td><td>↑</td><td>C</td><td>←</td><td>D</td></tr>
<tr>
<td>D:</td><td>A</td><td>↓</td><td>D</td><td>←</td><td>D</td><td>↑</td><td>C</td></tr>
</table></div>

<p>Let us assume that for drawing line segments we
have at our disposal a procedure line which moves a drawing pen in
a given direction by a given distance. For our convenience, we
assume that the direction be indicated by an integer
parameter <code>i</code> as <code>45 × i</code>
degrees. If the length of the unit
line is denoted by <code>u</code>, the procedure
corresponding to the scheme <code>A</code> is readily
expressed by using recursive activations of analogously designed
procedures <code>B</code> and <code>D</code> and of itself.</p>
<code class='large'>PROCEDURE A (i: INTEGER);
BEGIN
  IF i &gt; 0 THEN
    D(i-1); line(4, u);
    A(i-1); line(6, u);
    A(i-1); line(0, u); B(i-1)
  END
END A</code>

<p>This procedure is initiated by the main program once for every
Hilbert curve to be superimposed. The main procedure determines
the initial point of the curve, i.e., the
initial coordinates of the pen denoted by
<code>x0</code> and <code>y0</code>, and the unit
increment <code>u</code>. The square in which the curves
are drawn is placed into the middle of the page with given width
and height. These parameters as well as the drawing procedure
<code>line</code> are taken from a module <code>Draw</code>.
Note that this module retains the current
position of the pen.</p>
<code class='large'>DEFINITION Draw; <span>(* ADenS33_Draw *)</span>
  CONST width = 1024; height = 800;

  PROCEDURE Clear; (*clear drawing plane*)
  PROCEDURE SetPen(x, y: INTEGER);
  PROCEDURE line(dir, len: INTEGER);
    (*draw line of length len in direction dir*45 degrees; move pen accordingly*)
END Draw.</code>

<p>Procedure <code>Hilbert</code> draws
the <code>n</code> Hilbert curves <code>H<sub>1</sub> ... H<sub>n</sub></code>.
It uses the four auxiliary procedures <code>A</code>,
<code>B</code>, <code>C</code> and <code>D</code> recursively:</p>
<code class='large'>VAR u: INTEGER; <span>(* ADenS33_Hilbert *)</span>
PROCEDURE A (i: INTEGER);
BEGIN
  IF i &gt; 0 THEN
    D(i-1); Draw.line(4, u); A(i-1); Draw.line(6, u); A(i-1); Draw.line(0, u); B(i-1)
  END
END A;

PROCEDURE B (i: INTEGER);
BEGIN
  IF i &gt; 0 THEN
    C(i-1); Draw.line(2, u); B(i-1); Draw.line(0, u); B(i-1); Draw.line(6, u); A(i-1)
  END
END B;

PROCEDURE C (i: INTEGER);
BEGIN
  IF i &gt; 0 THEN
    B(i-1); Draw.line(0, u); C(i-1); Draw.line(2, u); C(i-1); Draw.line(4, u); D(i-1)
  END
END C;

PROCEDURE D (i: INTEGER);
BEGIN
  IF i &gt; 0 THEN
    A(i-1); Draw.line(6, u); D(i-1); Draw.line(4, u); D(i-1); Draw.line(2, u); C(i-1)
  END
END D;

PROCEDURE Hilbert (n: INTEGER);
  CONST SquareSize = 512;
  VAR i, x0, y0: INTEGER;
BEGIN
  Draw.Clear;
  x0 := Draw.width DIV 2; y0 := Draw.height DIV 2; u := SquareSize; i := 0;
  REPEAT
    INC(i); u := u DIV 2;
    x0 := x0 + (u DIV 2); y0 := y0 + (u DIV 2);
    Draw.Set(x0, y0); A(i)
  UNTIL i = n
END Hilbert.</code>
<br/><br/>

<svg width='520' height='520' viewBox='255 145 520 520' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'>
<rect fill='#FFF' stroke='#000' x='0' y='0' width='1024' height='800'/>
<path fill='none' stroke='black' stroke-width='1' d='
M 640 528 h-256 v-256 h256
M 704 592 v-128 h-128 v128 h-128 h-128 v-128 h128 v-128 h-128 v-128 h128 h128 v128 h128 v-128
M 736 624 h-64 v-64 h64 v-64 v-64 h-64 v64 h-64 v-64 h-64 v64 v64 h64 v64 h-64 h-64 v-64 h-64 v64 h-64 h-64 v-64 h64 v-64 h-64 v-64 h64 h64 v64 h64 v-64 v-64 v-64 h-64 v64 h-64 h-64 v-64 h64 v-64 h-64 v-64 h64 h64 v64 h64 v-64 h64 h64 v64 h-64 v64 v64 h64 v-64 h64 v64 h64 v-64 v-64 h-64 v-64 h64
M 752 640 v-32 h-32 v32 h-32 h-32 v-32 h32 v-32 h-32 v-32 h32 h32 v32 h32 v-32 v-32 h-32 v-32 h32 v-32 v-32 h-32 v32 h-32 v-32 h-32 v32 v32 h32 v32 h-32 h-32 h-32 v-32 h32 v-32 v-32 h-32 v32 h-32 v-32 h-32 v32 v32 h32 v32 h-32 v32 v32 h32 v-32 h32 h32 v32 h-32 v32 h32 v32 h-32 h-32 v-32 h-32 v32 h-32 h-32 v-32 h32 v-32 v-32 h-32 v32 h-32 v-32 h-32 v32 v32 h32 v32 h-32 h-32 v-32 h-32 v32 h-32 h-32 v-32 h32 v-32 h-32 v-32 h32 h32 v32 h32 v-32 v-32 v-32 h-32 v32 h-32 h-32 v-32 h32 v-32 h-32 v-32 h32 h32 v32 h32 v-32 h32 h32 v32 h-32 v32 v32 h32 v-32 h32 v32 h32 v-32 v-32 h-32 v-32 h32 v-32 h-32 v-32 h32 v-32 v-32 h-32 v32 h-32 v-32 h-32 v32 v32 h32 v32 h-32 h-32 v-32 h-32 v32 h-32 h-32 v-32 h32 v-32 h-32 v-32 h32 h32 v32 h32 v-32 v-32 v-32 h-32 v32 h-32 h-32 v-32 h32 v-32 h-32 v-32 h32 h32 v32 h32 v-32 h32 h32 v32 h-32 v32 v32 h32 v-32 h32 v32 h32 v-32 v-32 h-32 v-32 h32 h32 v32 h32 v-32 h32 h32 v32 h-32 v32 h32 v32 h-32 h-32 v-32 h-32 v32 v32 h32 v32 h-32 v32 v32 h32 v-32 h32 v32 h32 v-32 v-32 h-32 v-32 h32 h32 h32 v32 h-32 v32 v32 h32 v-32 h32 v32 h32 v-32 v-32 h-32 v-32 h32 v-32 v-32 h-32 v32 h-32 h-32 v-32 h32 v-32 h-32 v-32 h32 h32 v32 h32 v-32
M 760 648 h-16 v-16 h16 v-16 v-16 h-16 v16 h-16 v-16 h-16 v16 v16 h16 v16 h-16 h-16 v-16 h-16 v16 h-16 h-16 v-16 h16 v-16 h-16 v-16 h16 h16 v16 h16 v-16 v-16 v-16 h-16 v16 h-16 h-16 v-16 h16 v-16 h-16 v-16 h16 h16 v16 h16 v-16 h16 h16 v16 h-16 v16 v16 h16 v-16 h16 v16 h16 v-16 v-16 h-16 v-16 h16 v-16 v-16 h-16 v16 h-16 h-16 v-16 h16 v-16 h-16 v-16 h16 h16 v16 h16 v-16 v-16 h-16 v-16 h16 v-16 v-16 h-16 v16 h-16 v-16 h-16 v16 v16 h16 v16 h-16 h-16 h-16 v-16 h16 v-16 v-16 h-16 v16 h-16 v-16 h-16 v16 v16 h16 v16 h-16 v16 v16 h16 v-16 h16 h16 v16 h-16 v16 h16 v16 h-16 h-16 v-16 h-16 v16 h-16 v-16 h-16 v16 h-16 h-16 v-16 h16 v-16 h-16 v-16 h16 h16 v16 h16 v-16 v-16 h-16 v-16 h16 v-16 v-16 h-16 v16 h-16 v-16 h-16 v16 v16 h16 v16 h-16 h-16 h-16 v-16 h16 v-16 v-16 h-16 v16 h-16 v-16 h-16 v16 v16 h16 v16 h-16 v16 v16 h16 v-16 h16 h16 v16 h-16 v16 h16 v16 h-16 h-16 v-16 h-16 v16 v16 h16 v16 h-16 v16 v16 h16 v-16 h16 v16 h16 v-16 v-16 h-16 v-16 h16 h16 v16 h16 v-16 h16 h16 v16 h-16 v16 h16 v16 h-16 h-16 v-16 h-16 v16 v16 v16 h16 v-16 h16 h16 v16 h-16 v16 h16 v16 h-16 h-16 v-16 h-16 v16 h-16 h-16 v-16 h16 v-16 v-16 h-16 v16 h-16 v-16 h-16 v16 v16 h16 v16 h-16 h-16 v-16 h-16 v16 h-16 h-16 v-16 h16 v-16 h-16 v-16 h16 h16 v16 h16 v-16 v-16 h-16 v-16 h16 v-16 v-16 h-16 v16 h-16 v-16 h-16 v16 v16 h16 v16 h-16 h-16 h-16 v-16 h16 v-16 v-16 h-16 v16 h-16 v-16 h-16 v16 v16 h16 v16 h-16 v16 v16 h16 v-16 h16 h16 v16 h-16 v16 h16 v16 h-16 h-16 v-16 h-16 v16 h-16 h-16 v-16 h16 v-16 v-16 h-16 v16 h-16 v-16 h-16 v16 v16 h16 v16 h-16 h-16 v-16 h-16 v16 h-16 h-16 v-16 h16 v-16 h-16 v-16 h16 h16 v16 h16 v-16 v-16 v-16 h-16 v16 h-16 h-16 v-16 h16 v-16 h-16 v-16 h16 h16 v16 h16 v-16 h16 h16 v16 h-16 v16 v16 h16 v-16 h16 v16 h16 v-16 v-16 h-16 v-16 h16 v-16 h-16 v-16 h16 v-16 v-16 h-16 v16 h-16 v-16 h-16 v16 v16 h16 v16 h-16 h-16 v-16 h-16 v16 h-16 h-16 v-16 h16 v-16 h-16 v-16 h16 h16 v16 h16 v-16 v-16 v-16 h-16 v16 h-16 h-16 v-16 h16 v-16 h-16 v-16 h16 h16 v16 h16 v-16 h16 h16 v16 h-16 v16 v16 h16 v-16 h16 v16 h16 v-16 v-16 h-16 v-16 h16 h16 v16 h16 v-16 h16 h16 v16 h-16 v16 h16 v16 h-16 h-16 v-16 h-16 v16 v16 h16 v16 h-16 v16 v16 h16 v-16 h16 v16 h16 v-16 v-16 h-16 v-16 h16 h16 h16 v16 h-16 v16 v16 h16 v-16 h16 v16 h16 v-16 v-16 h-16 v-16 h16 v-16 v-16 h-16 v16 h-16 h-16 v-16 h16 v-16 h-16 v-16 h16 h16 v16 h16 v-16 v-16 v-16 h-16 v16 h-16 h-16 v-16 h16 v-16 h-16 v-16 h16 h16 v16 h16 v-16 v-16 h-16 v-16 h16 v-16 v-16 h-16 v16 h-16 v-16 h-16 v16 v16 h16 v16 h-16 h-16 h-16 v-16 h16 v-16 v-16 h-16 v16 h-16 v-16 h-16 v16 v16 h16 v16 h-16 v16 v16 h16 v-16 h16 h16 v16 h-16 v16 h16 v16 h-16 h-16 v-16 h-16 v16 h-16 h-16 v-16 h16 v-16 v-16 h-16 v16 h-16 v-16 h-16 v16 v16 h16 v16 h-16 h-16 v-16 h-16 v16 h-16 h-16 v-16 h16 v-16 h-16 v-16 h16 h16 v16 h16 v-16 v-16 v-16 h-16 v16 h-16 h-16 v-16 h16 v-16 h-16 v-16 h16 h16 v16 h16 v-16 h16 h16 v16 h-16 v16 v16 h16 v-16 h16 v16 h16 v-16 v-16 h-16 v-16 h16 v-16 h-16 v-16 h16 v-16 v-16 h-16 v16 h-16 v-16 h-16 v16 v16 h16 v16 h-16 h-16 v-16 h-16 v16 h-16 h-16 v-16 h16 v-16 h-16 v-16 h16 h16 v16 h16 v-16 v-16 v-16 h-16 v16 h-16 h-16 v-16 h16 v-16 h-16 v-16 h16 h16 v16 h16 v-16 h16 h16 v16 h-16 v16 v16 h16 v-16 h16 v16 h16 v-16 v-16 h-16 v-16 h16 h16 v16 h16 v-16 h16 h16 v16 h-16 v16 h16 v16 h-16 h-16 v-16 h-16 v16 v16 h16 v16 h-16 v16 v16 h16 v-16 h16 v16 h16 v-16 v-16 h-16 v-16 h16 h16 h16 v16 h-16 v16 v16 h16 v-16 h16 v16 h16 v-16 v-16 h-16 v-16 h16 v-16 v-16 h-16 v16 h-16 h-16 v-16 h16 v-16 h-16 v-16 h16 h16 v16 h16 v-16 h16 h16 v16 h-16 v16 v16 h16 v-16 h16 v16 h16 v-16 v-16 h-16 v-16 h16 h16 v16 h16 v-16 h16 h16 v16 h-16 v16 h16 v16 h-16 h-16 v-16 h-16 v16 v16 v16 h16 v-16 h16 h16 v16 h-16 v16 h16 v16 h-16 h-16 v-16 h-16 v16 h-16 h-16 v-16 h16 v-16 v-16 h-16 v16 h-16 v-16 h-16 v16 v16 h16 v16 h-16 v16 v16 h16 v-16 h16 h16 v16 h-16 v16 h16 v16 h-16 h-16 v-16 h-16 v16 v16 h16 v16 h-16 v16 v16 h16 v-16 h16 v16 h16 v-16 v-16 h-16 v-16 h16 h16 h16 v16 h-16 v16 v16 h16 v-16 h16 v16 h16 v-16 v-16 h-16 v-16 h16 v-16 v-16 h-16 v16 h-16 h-16 v-16 h16 v-16 h-16 v-16 h16 h16 v16 h16 v-16 h16 v16 h16 v-16 h16 h16 v16 h-16 v16 h16 v16 h-16 h-16 v-16 h-16 v16 v16 h16 v16 h-16 v16 v16 h16 v-16 h16 v16 h16 v-16 v-16 h-16 v-16 h16 h16 h16 v16 h-16 v16 v16 h16 v-16 h16 v16 h16 v-16 v-16 h-16 v-16 h16 v-16 v-16 h-16 v16 h-16 h-16 v-16 h16 v-16 h-16 v-16 h16 h16 v16 h16 v-16 v-16 h-16 v-16 h16 v-16 v-16 h-16 v16 h-16 v-16 h-16 v16 v16 h16 v16 h-16 h-16 v-16 h-16 v16 h-16 h-16 v-16 h16 v-16 h-16 v-16 h16 h16 v16 h16 v-16 v-16 v-16 h-16 v16 h-16 h-16 v-16 h16 v-16 h-16 v-16 h16 h16 v16 h16 v-16 h16 h16 v16 h-16 v16 v16 h16 v-16 h16 v16 h16 v-16 v-16 h-16 v-16 h16'/>
</svg>
<p>Fig. 3.4. Hilbert curves <code>H<sub>1</sub> … H<sub>5</sub></code>.</p>

<p>A similar but slightly more complex and aesthetically more
sophisticated example is shown in Fig. 3.6. This pattern is again
obtained by superimposing several curves, two of which are shown in
Fig. 3.5. <code>S<sub>i</sub></code> is
called the <i>Sierpinski curve</i> of order <code>i</code>.
What is its recursion scheme? One is tempted to
single out the leaf <code>S<sub>1</sub></code> as a
basic building block, possibly with one edge
left off. But this does not lead to a solution. The principal
difference between Sierpinski curves and Hilbert curves is that
Sierpinski curves are closed (without crossovers). This implies
that the basic recursion scheme must be an open curve and that the
four parts are connected by links not belonging to the recusion
pattern itself. Indeed, these links consist of the four straight
lines in the outermost four corners, drawn with thicker lines in
Fig. 3.5. They may be regarded as belonging to a non-empty initial
curve <code>S<sub>0</sub></code>, which is
a square standing on one corner. Now the recursion schema is
readily established. The four constituent patterns are again
denoted by <code>A</code>, <code>B</code>,
<code>C</code> and <code>D</code>, and the
connecting lines are drawn explicitly. Notice that the four
recursion patterns are indeed identical except for 90 degree
rotations.</p>

<div class='table'><table><tr>
  
<td><svg width='250' height='250' viewBox='380 280 250 250' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'>
<rect fill='#FFF' stroke='#000' x='0' y='0' width='1024' height='800'/>
<path fill='none' stroke='black' stroke-width='1' d='M 448 496 l32 -32 h64 l32 32 l32 -32 l-32 -32 v-64 l32 -32 l-32 -32 l-32 32 h-64 l-32 -32 l-32 32 l32 32 v64 l-32 32 l32 32'/>
</svg></td>

<td><svg width='250' height='250' viewBox='380 280 250 250' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'>
<rect fill='#FFF' stroke='#000' x='0' y='0' width='1024' height='800'/>
<path fill='none' stroke='black' stroke-width='1' d='M 416 512 l16 -16 h32 l16 16 l16 -16 l-16 -16 v-32 l16 -16 h32 l16 16 v32 l-16 16 l16 16 l16 -16 h32 l16 16 l16 -16 l-16 -16 v-32 l16 -16 l-16 -16 l-16 16 h-32 l-16 -16 v-32 l16 -16 h32 l16 16 l16 -16 l-16 -16 v-32 l16 -16 l-16 -16 l-16 16 h-32 l-16 -16 l-16 16 l16 16 v32 l-16 16 h-32 l-16 -16 v-32 l16 -16 l-16 -16 l-16 16 h-32 l-16 -16 l-16 16 l16 16 v32 l-16 16 l16 16 l16 -16 h32 l16 16 v32 l-16 16 h-32 l-16 -16 l-16 16 l16 16 v32 l-16 16 l16 16'/>
</svg></td>

</tr></table></div>

<p>Fig. 3.5. Sierpinski curves <code>S<sub>1</sub></code> and <code>S<sub>2</sub></code>.</p>

<p>The base pattern of the Sierpinski curves is</p>
<code>S: A ↘ B ↙ C ↖ D ↗ </code>
<p>and the recursion patterns are (horizontal and vertical arrows
denote lines of double length.)</p>
<code class='large'>A: A ↘ B  →  D ↗ A
B: B ↙ C  ↓  A ↘ B
C: C ↖ D  ←  B ↙ C
D: D ↗ A  ↑  C ↖ D</code>
<p>If we use the same primitives for drawing as in the Hilbert curve
example, the above recursion scheme is transformed without
difficulties into a (directly and indirectly) recursive
algorithm.</p>
<code class='large'>PROCEDURE A (k: INTEGER);
BEGIN
  IF k &gt; 0 THEN
    A(k-1); Draw.line(7, h); B(k-1); Draw.line(0, 2*h); D(k-1);
    Draw.line(1, h); A(k-1)
  END
END A;</code>

<p>This procedure is derived from the first line of the recursion
scheme. Procedures corresponding to the patterns
<code>B</code>, <code>C</code> and <code>D</code> are
derived analogously. The main program is composed
according to the base pattern. Its task is to set the initial
values for the drawing coordinates and to determine the unit line
length <code>h</code> according to the size of the
plane. The result of executing this program with
<code>n = 4</code> is shown in Fig. 3.6.</p>
<code class='large'>VAR h: INTEGER; <span>(* ADenS33_Sierpinski *)</span>

PROCEDURE A (k: INTEGER);
BEGIN
  IF k &gt; 0 THEN
    A(k-1); Draw.line(7, h); B(k-1); Draw.line(0, 2*h); D(k-1);
    Draw.line(1, h); A(k-1)
  END
END A;

PROCEDURE B (k: INTEGER);
BEGIN
  IF k &gt; 0 THEN
    B(k-1); Draw.line(5, h); C(k-1); Draw.line(6, 2*h); A(k-1);
    Draw.line(7, h); B(k-1)
  END
END B;

PROCEDURE C (k: INTEGER);
BEGIN
  IF k &gt; 0 THEN
    C(k-1); Draw.line(3, h); D(k-1); Draw.line(4, 2*h); B(k-1);
    Draw.line(5, h); C(k-1)
  END
END C;

PROCEDURE D (k: INTEGER);
BEGIN
  IF k &gt; 0 THEN
    D(k-1); Draw.line(1, h); A(k-1); Draw.line(2, 2*h); C(k-1);
    Draw.line(3, h); D(k-1)
  END
END D;

PROCEDURE Sierpinski* (n: INTEGER);
  CONST SquareSize = 512;
  VAR i, x0, y0: INTEGER;
BEGIN
  Draw.Clear;
  h := SquareSize DIV 4;
  x0 := Draw.width DIV 2; y0 := Draw.height DIV 2 + h; i := 0;
  REPEAT
    INC(i); x0 := x0-h;
    h := h DIV 2; y0 := y0+h; Draw.Set(x0, y0); A(i); Draw.line(7,h);
    B(i); Draw.line(5,h);
    C(i); Draw.line(3,h); D(i); Draw.line(1,h)
  UNTIL i = n
END Sierpinski.</code>

<p>The elegance of the use of recursion in these exampes is obvious
and convincing. The correctness of the programs can readily be
deduced from their structure and composition patterns. Moreover,
the use of an explicit (decreasing) level parameter guarantees
termination since the depth of recursion cannot become greater than
<code>n</code>. In contrast to this recursive
formulation, equivalent programs that avoid the explicit use of
recursion are extremely cumbersome and obscure. Trying to
understand the programs shown in [3-3] should easily convince the
reader of this.</p>


<svg width='520' height='520' viewBox='252 142 520 520' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'>
<rect fill='#FFF' stroke='#000' x='0' y='0' width='1024' height='800'/>
<path fill='none' stroke='black' stroke-width='1' d='
M 384 592 l64 -64 h128 l64 64 l64 -64 l-64 -64 v-128 l64 -64 l-64 -64 l-64 64 h-128 l-64 -64 l-64 64 l64 64 v128 l-64 64 l64 64
M 320 624 l32 -32 h64 l32 32 l32 -32 l-32 -32 v-64 l32 -32 h64 l32 32 v64 l-32 32 l32 32 l32 -32 h64 l32 32 l32 -32 l-32 -32 v-64 l32 -32 l-32 -32 l-32 32 h-64 l-32 -32 v-64 l32 -32 h64 l32 32 l32 -32 l-32 -32 v-64 l32 -32 l-32 -32 l-32 32 h-64 l-32 -32 l-32 32 l32 32 v64 l-32 32 h-64 l-32 -32 v-64 l32 -32 l-32 -32 l-32 32 h-64 l-32 -32 l-32 32 l32 32 v64 l-32 32 l32 32 l32 -32 h64 l32 32 v64 l-32 32 h-64 l-32 -32 l-32 32 l32 32 v64 l-32 32 l32 32
M 288 640 l16 -16 h32 l16 16 l16 -16 l-16 -16 v-32 l16 -16 h32 l16 16 v32 l-16 16 l16 16 l16 -16 h32 l16 16 l16 -16 l-16 -16 v-32 l16 -16 l-16 -16 l-16 16 h-32 l-16 -16 v-32 l16 -16 h32 l16 16 l16 -16 l-16 -16 v-32 l16 -16 h32 l16 16 v32 l-16 16 l16 16 l16 -16 h32 l16 16 v32 l-16 16 h-32 l-16 -16 l-16 16 l16 16 v32 l-16 16 l16 16 l16 -16 h32 l16 16 l16 -16 l-16 -16 v-32 l16 -16 h32 l16 16 v32 l-16 16 l16 16 l16 -16 h32 l16 16 l16 -16 l-16 -16 v-32 l16 -16 l-16 -16 l-16 16 h-32 l-16 -16 v-32 l16 -16 h32 l16 16 l16 -16 l-16 -16 v-32 l16 -16 l-16 -16 l-16 16 h-32 l-16 -16 l-16 16 l16 16 v32 l-16 16 h-32 l-16 -16 v-32 l16 -16 l-16 -16 l-16 16 h-32 l-16 -16 v-32 l16 -16 h32 l16 16 l16 -16 l-16 -16 v-32 l16 -16 h32 l16 16 v32 l-16 16 l16 16 l16 -16 h32 l16 16 l16 -16 l-16 -16 v-32 l16 -16 l-16 -16 l-16 16 h-32 l-16 -16 v-32 l16 -16 h32 l16 16 l16 -16 l-16 -16 v-32 l16 -16 l-16 -16 l-16 16 h-32 l-16 -16 l-16 16 l16 16 v32 l-16 16 h-32 l-16 -16 v-32 l16 -16 l-16 -16 l-16 16 h-32 l-16 -16 l-16 16 l16 16 v32 l-16 16 l16 16 l16 -16 h32 l16 16 v32 l-16 16 h-32 l-16 -16 l-16 16 l16 16 v32 l-16 16 h-32 l-16 -16 v-32 l16 -16 l-16 -16 l-16 16 h-32 l-16 -16 v-32 l16 -16 h32 l16 16 l16 -16 l-16 -16 v-32 l16 -16 l-16 -16 l-16 16 h-32 l-16 -16 l-16 16 l16 16 v32 l-16 16 h-32 l-16 -16 v-32 l16 -16 l-16 -16 l-16 16 h-32 l-16 -16 l-16 16 l16 16 v32 l-16 16 l16 16 l16 -16 h32 l16 16 v32 l-16 16 h-32 l-16 -16 l-16 16 l16 16 v32 l-16 16 l16 16 l16 -16 h32 l16 16 l16 -16 l-16 -16 v-32 l16 -16 h32 l16 16 v32 l-16 16 l16 16 l16 -16 h32 l16 16 v32 l-16 16 h-32 l-16 -16 l-16 16 l16 16 v32 l-16 16 h-32 l-16 -16 v-32 l16 -16 l-16 -16 l-16 16 h-32 l-16 -16 l-16 16 l16 16 v32 l-16 16 l16 16 l16 -16 h32 l16 16 v32 l-16 16 h-32 l-16 -16 l-16 16 l16 16 v32 l-16 16 l16 16
M 272 648 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 h16 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 v-16 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 h16 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 v16 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 h16 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 v-16 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 h-16 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 v-16 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 h16 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 v-16 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 h16 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 v16 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 h16 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 v16 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 h-16 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 v16 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 h16 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 v-16 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 h16 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 v16 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 h16 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 v-16 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 h-16 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 v-16 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 h16 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 v-16 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 h-16 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 v16 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 h-16 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 v-16 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 h-16 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 v-16 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 h16 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 v-16 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 h16 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 v16 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 h16 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 v-16 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 h-16 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 v-16 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 h16 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 v-16 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 h-16 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 v16 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 h-16 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 v-16 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 h-16 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 v16 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 h16 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 v16 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 h-16 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 v16 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 h-16 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 v-16 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 h-16 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 v-16 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 h16 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 v-16 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 h-16 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 v16 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 h-16 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 v-16 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 h-16 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 v16 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 h16 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 v16 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 h-16 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 v16 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 h16 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 v-16 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 h16 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 v16 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 h16 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 v16 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 h-16 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 v16 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 h-16 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 v-16 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 h-16 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 v16 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 l8 -8 l-8 -8 v-16 l8 -8 h16 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 v16 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 h-16 l-8 -8 v-16 l8 -8 l-8 -8 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 l8 8 l8 -8 h16 l8 8 v16 l-8 8 h-16 l-8 -8 l-8 8 l8 8 v16 l-8 8 l8 8'/>
</svg>
<p>Fig. 3.6. Sierpinski curves <code>S<sub>1</sub> … S<sub>4</sub></code>.</p>

</li>

<li data-list-text="3.4" id="3.4">
<h3><a href='#3.4' id='3.4'>Backtracking Algorithms</a></h3>
<p>A particularly intriguing programming endeavor is the subject of
so-called general problem solving. The task is to determine
algorithms for finding solutions to specific problems not by
following a fixed rule of computation, but by trial and error. The
common pattern is to decompose the trial-and-error process onto
partial tasks. Often these tasks are most naturally expressed in
recursive terms and consist of the exploration of a finite number
of subtasks. We may generally view the entire process as a trial or
search process that gradually builds up and scans (prunes) a tree
of subtasks. In many problems this search tree grows very rapidly,
often exponentially, depending on a given parameter. The search
effort increases accordingly. Frequently, the search tree can be
pruned by the use of heuristics only, thereby reducing computation
to tolerable bounds.</p>

<p>It is not our aim to discuss general heuristic rules in this text.
Rather, the general principle of breaking up such problem-solving
tasks into subtasks and the application of recursion is to be the
subject of this chapter. We start out by demonstrating the
underlying technique by using an example, namely, the well known
<i>knight's tour</i>.</p>

<p>Given is a <code>n × n</code>
board with <code>n<sup>2</sup></code>
fields. A knight — being allowed to move according
to the rules of chess — is placed on the field with initial
coordinates <code>x0</code>, <code>y0</code>.
The problem is to find a covering of the entire board, if there
exists one, i.e. to compute a tour of <code>n<sup>2</sup>-1</code>
moves such that every field of the
board is visited exactly once.</p>

<p>The obvious way to reduce the problem of covering
<code>n<sup>2</sup></code> fields is to consider the
problem of either performing a next move or finding out that none
is possible. Let us define the corresponding algorithm. A first
approach is to employ a linear search in order to find the next
move from which the tour can be completed:</p>
<code class='large'>PROCEDURE TryNextMove;
BEGIN
  IF <code class='pseudo'>board is not full</code> THEN
    <code class='pseudo'>initialize selection of candidates for the next move and select first one;</code>
    WHILE ~(<code class="pseudo">no more candidates</code>) &amp; ~(<code class="pseudo">tour can be completed from this candidate</code>) DO
      <code class="pseudo">select next candidate</code>
    END;
    <code class="pseudo">handle search results</code>
  ELSE
    <code class="pseudo">handle the case of full board</code>
  END
END TryNextMove;</code>

<p>Notice the <code>IF</code> encompassing the procedure
body: it ensures that the degenerate case of a full board is
handled correctly. This is a general device that is similar to how
arithmetic operations are defined to handle the zero case: the
purpose is convenience and robustness. If such checks are performed
outside of the procedure (as is often done for optimization) then
each call must be accompanied by such a check — or its absense must
be properly justified in each case. Introducing such complications
is best postponed until a correct algorithm is constructed and
their necessity is seen.</p>

<p>The predicate <em>tour can be completed from this
candidate</em> is conveniently expressed as a function-procedure
that returns a logical value. Since it is necessary to record the
sequence of moves being generated, the function-procedure is a
proper place both for recording the next move and for its rejection
because it is in this procedure that the success of completion of
the tour is determined.</p>

<code class='large'>PROCEDURE CanBeDone ( <i>move</i> ): BOOLEAN;
BEGIN
  <code class="pseudo">record move;</code>
  TryNextMove;
  IF <i>failed to complete the tour</i> THEN
    <code class="pseudo">erase move</code>
  END;
  RETURN <i>tour has been completed</i>
END CanBeDone</code>
<p>The recursion scheme is already evident here.</p>

<p>If we wish to be more precise in describing this algorithm, we are
forced to make some decisions on data representation. We wish to
keep track of the history of successive board occupations. Then
each move in the tour sequence can be characterized by an integer
<code>i</code> in addition to its two coordinates on the
board <code>x, y</code>.</p>

<p>At this point we can make decisions about the appropriate
parameters for the two procedures
<code>TryNextMove</code> and <code>CanBeDone</code>.</p>

<p>The parameters of <code>TryNextMove</code> are to
determine the starting conditions for the next move and also to
report on its success. The former task is adequately solved by
specifying the coordinates <code>x</code>, <code>y</code>
from which the move is to be made, and by specifying
the number <code>i</code> of the move (for recording
purposes). The latter task requires a Boolean result parameter with
the meaning <code class="pseudo">the move was successful</code>. The
resulting signature is</p>
<code class='large'>PROCEDURE TryNextMove (x, y, i: INTEGER; VAR done: BOOLEAN)</code>

<p>The function-procedure <code>CanBeDone</code> expresses
the predicate <span class="s21">tour can be completed from this
move</span> and is used within <code>TryNextMove</code>
in the linear search over possible move destinations determined
according to the jump pattern of knights. Introduce two local
variables <code>u</code> and <code>v</code>
to stand for the coordinates of the move destinations examined by
the linear search loop. The function <code>CanBeDone</code>
must know <code>u, v</code>. It is
also efficient to pass to <code>CanBeDone</code> the
number of this new move, which is known to be <code>i+1</code>.
Then the signature of <code>CanBeDone</code> can be chosen as follows:</p>

<code class='large'>PROCEDURE CanBeDone (u, v, i1: INTEGER): BOOLEAN</code>
<p>Certainly <code class="pseudo">board not full</code>
in <code>TryNextMove</code> can be expressed as
<code>i &lt; n</span><sup>2</sup></code>.
Also introduce a logical variable <code>eos</code>
to signal the condition <code class="pseudo">no more candidates</code>.
Then the algorithm is refined as follows:</p>
<code class='large'>PROCEDURE TryNextMove (x, y, i: INTEGER; VAR done: BOOLEAN);
  VAR eos: BOOLEAN; u, v: INTEGER;
BEGIN
  IF i &lt; n<sup>2</sup> THEN
    <code class='pseudo'>initialize selection of candidates for the next move and select first one u, v;</code>
    WHILE ~eos &amp; ~CanBeDone(u, v, i+1) DO
      <code class="pseudo">select next candidate u, v</code>
    END;
    done := ~eos
  ELSE
    done := TRUE
  END
END TryNextMove;

PROCEDURE CanBeDone (u, v, i1: INTEGER): BOOLEAN;
  VAR done: BOOLEAN;
BEGIN
  <code class="pseudo">record move;</code>
  TryNextMove(u, v, i1, done);
  IF ~done THEN
    <code class="pseudo">erase move</code>
  END;
  RETURN done
END CanBeDone</code>

<p>An obvious next step is to represent the board by a matrix, say
<code>h.</code> Let us also introduce a type to denote
index values:</p>
<code>VAR h: ARRAY n, n OF INTEGER</code>
<p>The decision to represent each field of the board by an integer
instead of a Boolean value denoting occupation allows to record the
history of successive board occupations in the simplest fashion.
The following convention is an obvious choice:</p>

<p><code>h[x, y] = 0:   </code> field <code> x, y </code> has
not been visited</p>
<p><code>h[x, y] = i:   </code> field <code> x, y </code> has
been visited in the  <code>i</code>-th move <code>(0 &lt; i ≤ n<sup>2</sup>)</code>

<p>Which statements can now be refined on the basis of
these decisions? We can actually complete the refinement of the
function-procedure <code>CanBeDone</code>: the operation
of recording the legal move is expressed by the assignment
<code>h<sub>xy</sub> := i</code>, and the cancellation of
this recording as <code>h<sub>xy</sub> := 0</code>.</p>

<p>Also, we can now express the enumeration of the allowed moves
<code>u, v</code> from the position <code>x, y</code> in the
procedure <code>TryNextMove</code>. On a
board that is infinite in all directions, each position
<code>x, y</code> has a number candidate moves <code>u, v</code>,
which at this point there is no need to specify
(see fig. 3.7). The predicate to choose an acceptable move can be
expressed as the logical conjunction of the conditions that the new
field lies on the board, i.e. <code>0 ≤ u &lt;n</code> and
<code>0 ≤ v &lt;n</code>, and that it had not been visited previously,
i.e., <code>h<sub>uv</sub> = 0</code>. One
further detail must not be overlooked: A variable
<code>h<sub>uv</sub></code> does exist only if
both <code>u</code> and  <code>v</code> lie
within the index range <code>0 ... n-1</code>.
Consequently, the Boolean expression, substituted for
<em>acceptable</em> in the general
schema, is valid only if its first four constituent terms are true.
It is therefore relevant that the term
<code>h<sub>uv</sub> = 0</code> appears last. As a result, the
selection of the next acceptable candidate move is expressed by the
familiar scheme of linear search (only formulated now in terms of
the repeat loop instead of while, which in this case is possible
and convenient). To signal that there are now further candidate
moves, the variable <code>eos</code> can be used. Let us
formulate the operation as a procedure <code>Next</code>,
explicitly specifying the relevant variables as
parameters:</p>
<code class='large'>PROCEDURE Next (VAR eos: BOOLEAN; VAR u, v: INTEGER);
BEGIN
  (*~eos*)
  REPEAT
    <code class='pseudo'>select the next candidate move u, v</code>
  UNTIL (<code class='pseudo'>no more candidates</code>) OR
        ((0 &lt;=u) &amp; (u &lt;n) &amp; (0 &lt;=v) &amp; (v &lt;n) &amp; (h[u, v] =0));
  eos := <code class='pseudo'>no more candidates</code>
END Next</code>

<p>The enumeration of candidate moves is accomplished in a similar
procedure <code>First</code> that generates the first
candidate move; see the details in the final program presented
below.</p>

<p>Just one more refinement step will lead us to a program expressed
fully in terms of our basic programming notation. We should note
that so far the program was developed completely independently of
the laws governing the jumps of the knight. This delaying of
considerations of particularities of the problem was quite
deliberate. But now is the time to take them into account.</p>

<p>Given a starting coordinate pair <code>x</code>,
<code>y</code> there are eight potential candidates
<code>u</code>, <code>v</code> of the
destination. They are numbered 1 to 8 in Fig. 3.7.</p>

<img src="fig/3.7.png" width="200"/>
<p>Fig. 3.7. The 8 possible moves of a knight</p>

<p>A simple method of obtaining <code>u</code>,
<code>v</code> from <code>x</code>,
<code>y</code> is by addition of the coordinate
differences stored in either an array of difference pairs or in two
arrays of single differences. Let these arrays be denoted by
<code>dx</code> and <code>dy</code>,
appropriately initialized.</p>
<code class='large'>dx = (2, 1, -1, -2, -2, -1, 1, 2)
dy = (1, 2, 2, 1, -1, -2, -2, -1)</code>
<p>Then an index <code>k</code> may be used to number the
<code class="pseudo">next candidate</code>. The details are shown in
the program presented below.</p>

<p>We assume a global <code>n × n</code> matrix <code>h</code>
representing the result, the constant <code>n</code>
(and <code>nsqr = n<sup>2</sup></code>), and arrays
<code>dx</code> and <code>dy</code>
representig the possible moves of a knight (see
Fig. 3.7). The recursive procedure is initiated by a call with the
coordinates <code>x0, y0</code> of that field as
parameters from which the tour is to start. This field
must be given the value 1; all others are to be marked free.</p>

<code class='large'>VAR h: ARRAY n, n OF INTEGER; <span>(* ADenS34_KnightsTour *)</span>

  dx, dy: ARRAY 8 OF INTEGER;

PROCEDURE CanBeDone (u, v, i: INTEGER): BOOLEAN;
  VAR done: BOOLEAN;
BEGIN
  h[u, v] := i; TryNextMove(u, v, i, done);
  IF ~done THEN h[u, v] := 0 END;
  RETURN done
END CanBeDone;

PROCEDURE TryNextMove (x, y, i: INTEGER; VAR done: BOOLEAN);
  VAR eos: BOOLEAN; u, v: INTEGER; k: INTEGER;

  PROCEDURE Next (VAR eos: BOOLEAN; VAR u, v: INTEGER);
  BEGIN
    REPEAT
      INC(k);
      IF k &lt; 8 THEN u := x + dx[k]; v := y + dy[k] END;
    UNTIL (k = 8) OR ((0 &lt;= u) &amp; (u &lt; n) &amp; (0 &lt;= v) &amp; (v &lt; n) &amp; (h[u, v] = 0));
    eos := (k = 8)
  END Next;

  PROCEDURE First (VAR eos: BOOLEAN; VAR u, v: INTEGER);
  BEGIN
    eos := FALSE; k := -1; Next(eos, u, v)
  END First;

BEGIN
  IF i &lt; nsqr THEN
    First(eos, u, v);
    WHILE ~eos &amp; ~CanBeDone(u, v, i+1) DO
      Next(neos, u, v)
    END;
    done := ~eos
  ELSE
    done := TRUE
  END;
END TryNextMove;

PROCEDURE Clear;
  VAR i, j: INTEGER;
BEGIN
  FOR i := 0 TO n-1 DO
    FOR j := 0 TO n-1 DO h[i,j] := 0 END
  END
END Clear;

PROCEDURE KnightsTour (x0, y0: INTEGER; VAR done: BOOLEAN);
BEGIN
  Clear; h[x0,y0] := 1; TryNextMove(x0, y0, 1, done);
END KnightsTour;</code>

<p>Table 3.1 indicates solutions obtained with initial positions
<code>&lt;2,2&gt;, &lt;1,3&gt;</code> for <code>n = 5</code> and <code>&lt;0,0&gt;</code> for
<code>n = 6</code>:</p>

<div class='table'><table>
<tr>
<td>23</td><td>10</td><td>15</td><td>4</td><td>25</td>
<td></td>
<td>23</td><td>4</td><td>9</td><td>14</td><td>25</td>
</tr>
<tr>
<td>16</td><td>5</td><td>24</td><td>9</td><td>14</td>
<td></td>
<td>10</td><td>15</td><td>24</td><td>1</td><td>8</td>
</tr>
<tr>
<td>11</td><td>22</td><td>1</td><td>18</td><td>3</td>
<td></td>
<td>5</td><td>22</td><td>3</td><td>18</td><td>13</td>
</tr>
<tr>
<td>6</td><td>17</td><td>20</td><td>13</td><td>8</td>
<td></td>
<td>16</td><td>11</td><td>20</td><td>7</td><td>2</td>
</tr>
<tr>
<td>21</td><td>12</td><td>7</td><td>2</td><td>19</td>
<td></td>
<td>21</td><td>6</td><td>17</td><td>12</td><td>19</td></tr>
<tr><td>&nbsp;</td>
</tr>
<tr>
<td>1</td><td>16</td><td>7</td><td>26</td><td>11</td><td>14</td>
<td></td>
</tr>
<tr>
<td>34</td><td>25</td><td>12</td><td>15</td><td>6</td><td>27</td></tr>
<tr>
<td>17</td><td>2</td><td>33</td><td>8</td><td>13</td><td>10</td></tr>
<tr>
<td>32</td><td>35</td><td>24</td><td>21</td><td>28</td><td>5</td></tr>
<tr>
<td>23</td><td>18</td><td>3</td><td>30</td><td>9</td><td>20</td></tr>
<tr>
<td>36</td><td>31</td><td>22</td><td>19</td><td>4</td><td>29</td></tr>
</table></div>

<p>Table 3.1. Three Knights' Tours.</p>

<p>What abstractions can now be made from this example? Which pattern
does it exhibit that is typical for this kind of problem-solving
algorithms? What does it teach us? The characteristic feature is
that steps toward the total solution are attempted and recorded
that may later be taken back and erased in the recordings when it
is discovered that the step does not possibly lead to the total
solution, that the step leads into a dead-end street. This action
is called <i>backtracking</i>. The general pattern below is derived
from <code>TryNextMove</code>, assuming that the number
of potential candidates in each step is finite.</p>
<code class='large'>PROCEDURE Try;
BEGIN
  IF <code class='pseudo'>solution incomplete</code> THEN
    <code class='pseudo'>initialize selection of candidates and choose the first one;</code>
    WHILE ~(<code class='pseudo'>no more candidates</code>) &amp; ~CanBeDone(<code class='pseudo'>candidate</code>)DO
      <code class='pseudo'>select next</code>
    END
  END
END Try;

PROCEDURE CanBeDone (<code class='pseudo'>move</code>): BOOLEAN;
BEGIN
  <code class="pseudo">record move;</code>
  Try;
  IF <code class='pseudo'>not successful</code> THEN
    <code class='pseudo'>cancel recording</code>
  END;
  RETURN <code class='pseudo'>successful</code>
END CanBeDone</code>

<p>Actual programs may, of course, assume various derivative forms of
this schema. In particular, the way input is passed to
<code>TryNextMove</code> may vary depending on the problem
specifics. Indeed, this procedure accesses global variables in
order to record the solution, and those variables contain, in
principle, a complete information about the current state of the
construction process. For instance, in the knight's tour problem
<code>TryNextMove</code> needs to know the knight's last
position on the board, which can be found by a search in the matrix
<code>h</code>. However, this information is explicitly
available when the procedure is called, and it is simpler to pass
it via parameters. In subsequent examples we will see variations on
this theme.</p>

<p>Note that the search condition in the while loop is modeled as a
procedure-function <code>CanBeDone</code> for a maximal
clarification of the logic of the algorithm while keeping the
program easily comprehensible.</p>

<p>Certainly the program can be optimized in other respects via
appropriate equivalent transformations. One can, for instance,
eliminate the two procedures <code>First</code> and
<code>Next</code> by merging the two easily verifiable
loops into one. Such a single loop would, in general, be more
complex, but the final result can turn out to be quite transparent
in the case when <i>all</i> solutions are to be found (see the last
program in the next section).</p>

<p>The remainder of this chapter is devoted to the treatment of three
more examples. They display various incarnations of the abstract
schema and are included as further illustrations of the appropriate
use of recursion.</p>

</li>
<li data-list-text="3.5" id="3.5">
<h3><a href='#3.5' id='3.5'>The Eight Queens Problem</a></h3>
<p>The problem of the eight queens is a well-known example of the use
of trial-and-error methods and of backtracking algorithms. It was
investigated by C .F. Gauss in 1850, but he did not completely
solve it. This should not surprise anyone. After all, the
characteristic property of these problems is that they defy
analytic solution. Instead, they require large amounts of exacting
labor, patience, and accuracy. Such algorithms have therefore
gained relevance almost exclusively through the automatic computer,
which possesses these properties to a much higher degree than
people, and even geniuses, do.</p>

<p>The eight queens poblem is stated as follows (see also [3-4]):
Eight queens are to be placed on a chess board in such a way that
no queen checks against any other queen. We will use the last
schema of Sect. 3.4 as a template.</p>

<p>Since we know from the rules of chess that a queen checks all other
figures lying in either the same column, row, or diagonal on the
board, we infer that each column may contain one and only one
queen, and that the choice of a position for the <code>i</code>-th
queen may be restricted to the <code>i</code>-th column.
The next move in the general recursive
scheme will be to position the next queen in the order of their
numbers, so <code>Try</code> will attempt to position
the <code>i</code>-th queen, receiving <code>i</code>
as a parameter which therefore becomes the column
index, and the selection process for positions ranges over the
eight possible values for a row index j.</p>

<code class='large'>PROCEDURE Try (i: INTEGER);
BEGIN
  IF i &lt; 8 THEN
    <code class="pseudo">initialize selection of safe j and select the first one;</code>
    WHILE ~(<code class="pseudo">no more safe j</code>) &amp; ~CanBeDone(i, j) DO
      <code class="pseudo">select next safe j</code>
    END
  END
END Try;

PROCEDURE CanBeDone (i, j: INTEGER): BOOLEAN;
  (*solution can be completed with i-th queen in j-th row*)
BEGIN
  <code class="pseudo">SetQueen;</code>
  <code>Try(i+1);</code>
  IF <code class="pseudo">not successful</code> THEN
    <code class="pseudo">RemoveQueen</code>
  END;
  RETURN <code class="pseudo">successful</code>
END CanBeDone</code>

<p>In order to proceed, it is necessary to make some commitments
concerning the data representation. An obvious choice would again
be a square matrix to represent the board, but a little inspection
reveals that such a representation would lead to fairly cumbersome
operations for checking the availability of positions. This is
highly undesirable since it is the most frequently executed
operation. We should therefore choose a data representation
which makes checking as simple
as possible. The best recipe is to represent as directly as
possible that information which is truly relevant and most often
used. In our case this is not the position of the queens, but
whether or not a queen has already been placed along each row and
diagonals. (We already know that exactly one is placed in each
column <code>k</code> for <code>0 ≤ k &lt; i</code>.)
This leads to the following choice of variables:</p>
<code class='large'>VAR x: ARRAY 8 OF INTEGER;
    a: ARRAY 8 OF BOOLEAN;
    b, c: ARRAY 15 OF BOOLEAN</code>
<p>where <code>x<sub>i</sub></code> denotes the position of the queen in the <code>i</code>-th column;</p>
<p><code>a<sub>j</sub></code> means "no queen lies in the</span> <code>j</code>-th row";</p>
<p><code>b<sub>k</sub></code> means "no queen occupies the <code>k</code>-th /-diagonal;</p>
<p><code>c<sub>k</sub></code> means "no queen sits onthe <code>k</code>-th \-diagonal.</p>

<p>We note that in a /-diagonal all fields have the same sums of their
coordinates <code>i</code> and <code>j</code>, and that in a \-diagonal the coordinate differences
<code>i-j</code> are constant. The appropriate solution
is shown in the following program <code>Queens</code>.
Given these data, the statement <code class="pseudo">SetQueen</code>
is elaborated to</p>
<code class='large'>[i] := j; a[j] := FALSE; b[i+j] := FALSE; c[i-j+7] := FALSE</code>
<p>the statement <code class="pseudo">RemoveQueen</code> is refined
into</p>
<code class='large'>a[j] := TRUE; b[i+j] := TRUE; c[i-j+7] := TRUE</code>
<p>The field &lt;<code>i, j</code>&gt; is safe if it lies
in a row and in diagonals which are still free. Hence, it can be
expressed by the logical expression</p>
<code>a[j] &amp; b[i+j] &amp; c[i-j+7]</code>

<p>This allows one to formulate the procedures for enumeration of safe
rows <code>j</code> for the <code>i-th</code>
queen by analogy with the preceding example.</p>

<p>This completes the development of this algorithm, that is shown in
full below. The computed solution is <code>x = (1, 5, 8, 6, 3, 7, 2, 4)</code>
and is shown in Fig. 3.8.</p>

<img src="fig/3.8.png" width="300"/>
<p>Fig. 3.8. A solution to the Eight Queens problem</p>

<code class='large'>PROCEDURE Try (i: INTEGER; VAR done: BOOLEAN); <span>(* ADenS35_Queens *)</span>
  VAR eos: BOOLEAN; j: INTEGER;

  PROCEDURE Next;
  BEGIN
    REPEAT INC(j);
    UNTIL (j = 8) OR (a[j] &amp; b[i+j] &amp; c[i-j+7]);
    eos := (j = 8)
  END Next;

  PROCEDURE First;
  BEGIN
    eos := FALSE; j := -1; Next
  END First;

BEGIN
  IF i &lt; 8 THEN
    First;
    WHILE ~eos &amp; ~CanBeDone(i, j) DO
      Next
    END;
    done := ~eos
  ELSE
    done := TRUE
  END
END Try;

PROCEDURE CanBeDone (i, j: INTEGER): BOOLEAN;
  (*solution can be completed with i-th queen in j-th row*)
  VAR done: BOOLEAN;
BEGIN
  x[i] := j; a[j] := FALSE; b[i+j] := FALSE; c[i-j+7] := FALSE;
  Try(i+1, done);
  IF ~done THEN
    x[i] := -1; a[j] := TRUE; b[i+j] := TRUE; c[i-j+7] := TRUE
  END;
  RETURN done
END CanBeDone;

PROCEDURE Queens*;
VAR done: BOOLEAN; i, j: INTEGER; (*uses global writer W*)
BEGIN
  FOR i := 0 TO  7 DO a[i] := TRUE; x[i] := -1 END;
  FOR i := 0 TO 14 DO b[i] := TRUE; c[i] := TRUE END;
  Try(0, done);
  IF done THEN
    FOR i := 0 TO 7 DO Texts.WriteInt(W, x[i], 4) END;
    Texts.WriteLn(W)
  END
END Queens.</code>

<p>Before we abandon the context of the chess board, the eight queens
example is to serve as an illustration of an important extension of
the trial-and-error algorithm. The extension is — in general terms
— to find not only one, but all solutions to a posed problem.</p>

<p>The extension is easily accommodated. We are to recall the fact
that the generation of candidates must progress in a systematic
manner that guarantees no candidate is generated more than once.
This property of the algorithm corresponds to a search of the candidate tree in a
systematic fashion in which every node is visited exactly once. It
allows — once a solution is found and duly recorded — merely to
proceed to the next candidate delivered by the systematic selection
process. The modification is formally accomplished by carrying the
procedure function <code>CanBeDone</code> from the
loop's guard into its body and substituting the procedure body in
place of its call. To return a logical value is no longer
necessary. The general schema is as follows:</p>

<code class='large'>PROCEDURE Try;
BEGIN
  IF <code class='pseudo'>solution incomplete</code> THEN
    <code class='pseudo'>initialize selection of candidate moves and select the first one;</code>
    WHILE ~(<i>no more moves</i>) DO
      <code class="pseudo">record move;</code>
      Try;
      <code class="pseudo">erase move; select next move</code>
    END
  ELSE
    <code class="pseudo">print solution</code>
  END
END Try</code>

<p>It comes as a surprise that the search for all possible solutions
is realized by a simpler program than the search for a single
solution.</p>

<p>In the eight queenn problem another simplification is posssible.
Indeed, the somewhat cumbersome mechanism of enumeration of safe
positions which consists of the two procedures
<code>First</code> and <code>Next</code>, was used to
disentangle the linear search of the next safe position
(the loop over <code>j</code> within <code>Next</code>)
and the linear search of the first <code>j</code> which
yields a complete solution. Now, thanks to the simplification of
the latter loop, such a disentanglement is no longer necessary as
the simplest loop over <code>j</code> will suffice, with
the safe <code>j</code> filtered by an <code>IF</code>
embedded within the loop, without invoking the
additional procedures.</p>

<p>The extended algorithm to determine all 92 solutions of the eight
queens problem is shown in the following program. Actually, there
are only 12 significantly differing solutions; our program does not
recognize symmetries. The 12 solutions generated first are listed
in Table 3.2. The numbers <code>n</code> to the right
indicate the frequency of execution of the test for safe fields.
Its average over all 92 solutions is 161.</p>
<code class='large'>PROCEDURE write; <span >(* ADenS35_Queens *)</span>
VAR k: INTEGER;
BEGIN
  FOR k := 0 TO 7 DO Texts.WriteInt(W, x[k], 4) END;
  Texts.WriteLn(W)
END write;

PROCEDURE Try (i: INTEGER); VAR j: INTEGER;
BEGIN
  IF i &lt; 8 THEN
    FOR j := 0 TO 7 DO
      IF a[j] &amp; b[i+j] &amp; c[i-j+7] THEN
        x[i] := j; a[j] := FALSE; b[i+j] := FALSE; c[i-j+7] := FALSE;
        Try(i + 1);
        x[i] := -1; a[j] := TRUE; b[i+j] := TRUE; c[i-j+7] := TRUE
      END
    END
  ELSE
    write;
    m := m+1 (*solutions count*)
  END
END Try;

PROCEDURE AllQueens*;
VAR i, j: INTEGER;
BEGIN
  FOR i := 0 TO 7  DO a[i] := TRUE; x[i] := -1 END;
  FOR i := 0 TO 14 DO b[i] := TRUE; c[i] := TRUE END;
  m := 0;
  Try(0);
  Log.String('no. of solutions: '); Log.Int(m); Log.Ln
END AllQueens.
</code>
<br/>

<div class='table'><table>
<tr>
<td>x0</td><td>x1</td><td>x2</td><td>x3</td><td>x4</td><td>x5</td><td>x6</td><td>x7</td><td>n</td></tr>
<tr>
<td>0</td><td>4</td><td>7</td><td>5</td><td>2</td><td>6</td><td>1</td><td>3</td><td>876</td></tr>
<tr>
<td>0</td><td>5</td><td>7</td><td>2</td><td>6</td><td>3</td><td>1</td><td>4</td><td>264</td></tr>
<tr>
<td>0</td><td>6</td><td>3</td><td>5</td><td>7</td><td>1</td><td>4</td><td>2</td><td>200</td></tr>
<tr>
<td>0</td><td>6</td><td>4</td><td>7</td><td>1</td><td>3</td><td>5</td><td>2</td><td>136</td></tr>
<tr>
<td>1</td><td>3</td><td>5</td><td>7</td><td>2</td><td>0</td><td>6</td><td>4</td><td>504</td></tr>
<tr>
<td>1</td><td>4</td><td>6</td><td>0</td><td>2</td><td>7</td><td>5</td><td>3</td><td>400</td></tr>
<tr>
<td>1</td><td>4</td><td>6</td><td>3</td><td>0</td><td>7</td><td>5</td><td>2</td><td>072</td></tr>
<tr>
<td>1</td><td>5</td><td>0</td><td>6</td><td>3</td><td>7</td><td>2</td><td>4</td><td>280</td></tr>
<tr>
<td>1</td><td>5</td><td>7</td><td>2</td><td>0</td><td>3</td><td>6</td><td>4</td><td>240</td></tr>
<tr>
<td>1</td><td>6</td><td>2</td><td>5</td><td>7</td><td>4</td><td>0</td><td>3</td><td>264</td></tr>
<tr>
<td>1</td><td>6</td><td>4</td><td>7</td><td>0</td><td>3</td><td>5</td><td>2</td><td>160</td></tr>
<tr>
<td>1</td><td>7</td><td>5</td><td>0</td><td>2</td><td>4</td><td>6</td><td>3</td><td>336</td></tr>
</table></div>

<p>Table 3.2. Twelve Solutions to the Eight Queens Problem.</p>
</li>

<li data-list-text="3.6" id="3.6">
<h3><a href='#3.6' id='3.6'>The Stable Marriage Problem</a></h3>

<p>Assume that two disjoint sets <code>A</code> and
<code>B</code> of equal size <code>n</code>
are given. Find a set of <code>n</code> pairs
<code>&lt;a, b&gt;</code> such that <code>a</code> in
<code>A</code> and <code>b</code> in <code>B</code> satisfy some constrains.
Many different criteria for such pairs exist; one of them is the
rule called the <i>stable marriage rule</i>.</p>

<p>Assume that <code>A</code> is a set of men and
<code>B</code> is a set of women. Each man and each
women has stated distinct preferences for their possible partners.
If the <code>n</code> couples are chosen such that there
exists a man and a woman who are not married, but who would both
prefer each other to their actual marriage partners, then the
assignment is unstable. If no such pair exists, it is called
stable. This situation characterizes many related problems in which
assignments have to be made according to preferences such as, for
example, the choice of a school by students, the choice of recruits
by different branches of the armed services, etc. The example of
marriages is particularly intuitive; note, however, that the stated
list of preferences is invariant and does not change after a
particular assignment has been made. This assumption simplifies the
problem, but it also represents a grave distortion of reality
(called abstraction).</p>

<p>One way to search for a solution is to try pairing off members of
the two sets one after the other until the two sets are exhausted.
Setting out to find all stable assignments, we can readily sketch a
solution by using the program schema of <code>AllQueens</code>
as a template. Let <code>Try(m)</code> denote the algorithm to find a partner for
man <code>m</code> , and let this search proceed in the order of the
man's list of stated preferences. The first version based on these
assumptions is:</p>

<code class='large'>PROCEDURE Try (m: man);
  VAR r: rank;
BEGIN
  IF m &lt; n THEN
    FOR r := 0 TO n-1 DO
      <code class="pseudo">pick the r-th preference of man m;</code>
      IF <i>acceptable</i> THEN
        <i>record the marriage</i>;
        Try(successor(m));
        <i>cancel the marriage</i>
      END
    END
  ELSE
    <code class="pseudo">record the stable set</code>
  END
END Try</code>
<p>The initial data are represented by two matrices that indicate the
men's and women's preferences.</p>
<code class='large'>VAR wmr: ARRAY n, n OF woman;
    mwr: ARRAY n, n OF man</code>

<p>Accordingly, <code>wmr<sub>m</sub></code>
denotes the preference list of man <code>m</code>, i.e.,
<code>wmr<sub>m,r</sub></code> is the
woman who occupies the <code>r</code>-th rank in the
list of man <code>m</code>.
Similarly, <code>mwr<sub>w</sub></code> is the preference list of
woman <code>w</code>, and <code>mwr<sub>w,r</sub></code>
is her <code>r</code>-th choice.</p>

<p>A sample data set is shown in Table 3.3.</p>
<p>The result is represented by an array of women
<code>x</code>, such that <code>x<sub>m</sub></code>
denotes the partner of man <code>m</code>.
In order to maintain symmetry between men and women,
an additional array <code>y</code>, such that
<code>y<sub>w</sub></code> denotes the
partner of woman <code>w</code>:</p>
<code>VAR x, y: ARRAY n OF INTEGER</code>

<div class='table'><table>
<tr>
<td></td><td>r =</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></td><td></td><td>
<td>r =</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr>
<tr>
<td>m =</td><td>0</td><td>6</td><td>1</td><td>5</td><td>4</td><td>0</td><td>2</td><td>7</td><td>3</td></td><td>
<td>w =</td><td>0</td><td>3</td><td>5</td><td>1</td><td>4</td><td>7</td><td>0</td><td>2</td><td>6</td></tr>
<tr>
<td></td><td>1</td><td>3</td><td>2</td><td>1</td><td>5</td><td>7</td><td>0</td><td>6</td><td>4</td></td><td></td><td>
<td>1</td><td>7</td><td>4</td><td>2</td><td>0</td><td>5</td><td>6</td><td>3</td><td>1</td></tr>
<tr>
<td></td><td>2</td><td>2</td><td>1</td><td>3</td><td>0</td><td>7</td><td>4</td><td>6</td><td>5</td></td><td></td><td>
<td>2</td><td>5</td><td>7</td><td>0</td><td>1</td><td>2</td><td>3</td><td>6</td><td>4</td></tr>
<tr>
<td></td><td>3</td><td>2</td><td>7</td><td>3</td><td>1</td><td>4</td><td>5</td><td>6</td><td>0</td></td><td></td><td>
<td>3</td><td>2</td><td>1</td><td>3</td><td>6</td><td>5</td><td>7</td><td>4</td><td>0</td></tr>
<tr>
<td></td><td>4</td><td>7</td><td>2</td><td>3</td><td>4</td><td>5</td><td>0</td><td>6</td><td>1</td><td></td><td></td>
<td>4</td><td>5</td><td>2</td><td>0</td><td>3</td><td>4</td><td>6</td><td>1</td><td>7</td></tr>
<tr>
<td></td><td>5</td><td>7</td><td>6</td><td>4</td><td>1</td><td>3</td><td>2</td><td>0</td><td>5</td></td><td></td><td>
<td>5</td><td>1</td><td>0</td><td>2</td><td>7</td><td>6</td><td>3</td><td>5</td><td>4</td></tr>
<tr>
<td></td><td>6</td><td>1</td><td>3</td><td>5</td><td>2</td><td>0</td><td>6</td><td>4</td><td>7</td></td><td></td><td>
<td>6</td><td>2</td><td>4</td><td>6</td><td>1</td><td>3</td><td>0</td><td>7</td><td>5</td></tr>
<tr>
<td></td><td>7</td><td>5</td><td>0</td><td>3</td><td>1</td><td>6</td><td>4</td><td>2</td><td>7</td></td><td></td><td>
<td>7</td><td>6</td><td>1</td><td>7</td><td>3</td><td>4</td><td>5</td><td>2</td><td>0</td></tr>
</table></div>
<p>Table 3.3. Sample Input Data for <code>wmr</code> and <code>mwr.</code></p>
<p>Actually, <code>y</code> is redundant, since it
represents information that is already present through the
existence of <code>x</code>. In fact, the relations</p>
<code>x[y[w]] = w, y[x[m]] = m</code>
<p>hold for all <code>m</code> and <code>w</code>
who are married. Thus, the value <code>y<sub>w</sub></code> could be determined by a
simple search of <code>x</code>; the array <code>y</code>,
however, clearly improves the efficiency of the
algorithm. The information represented by <code>x</code>
and <code>y</code> is needed to determine stability of a
proposed set of marriages. Since this set is constructed stepwise
by marrying individuals and testing stability after each proposed
marriage, <code>x</code> and <code>y</code>
are needed even before all their components are defined. In order
to keep track of defined components, we may introduce Boolean
arrays</p>
<code>singlem, singlew: ARRAY n OF BOOLEAN</code>
<p>with the meaning that <code>singlem<sub>m</sub></code>
implies that <code>x<sub>m</sub></code> is undefined,
and <code>singlew<sub>w</sub></code> implies that
<code>y<sub>w</sub></code> is undefined.
An inspection of the proposed algorithm, however, quickly reveals
that the marital status of a man <code>k</code> is
determined by the value <code>m</code> through the
relation</p>
<code>~singlem[k] = k &lt; m</code>
<p>This suggests that the array <code>singlem</code> be
omitted; accordingly, we will simplify the name
<code>singlew</code> to <code>single</code>. These
conventions lead to the refinement shown by the following procedure
<code>Try</code>. The predicate
<code class="pseudo">acceptable</code> can be refined
into the conjunction of
<code>single</code> and <code class="pseudo">stable</code>,
where <code class="pseudo">stable</code> is a
function to be still further elaborated.</p>
<code class='large'>PROCEDURE Try (m: man);
  VAR r: rank; w: woman;
BEGIN
  IF m &lt; n THEN
    FOR r := 0 TO n-1 DO
      w := wmr[m,r];
      IF single[w] &amp; <i>stable</i> THEN
        x[m] := w; y[w] := m; single[w] := FALSE; Try(m+1);
        single[w] := TRUE
      END
    END
  ELSE
    <code class="pseudo">record the solution</code>
  END
END Try</code>

<p>At this point, the strong similarity of this solution with
procedure <code>AllQueens</code> is still noticeable.
The crucial task is now the refinement of the algorithm to
determine stability. Unfortunately, it is not possible to represent
stability by such a simple expression as the safety of a queen's
position. The first detail that should be kept in mind is that
stability follows by definition from comparisons of ranks. The
ranks of men or women, however, are nowhere explicitly available in
our collection of data established so far. Surely, the rank of
woman <code>w</code> in the mind of man <code>m</code>
can be computed, but only by a costly search of
<code>w</code> in <code>wmr<sub>m</sub></code>. Since the computation of
stability is a very frequent operation, it is advisable to make
this information more directly accessible. To this end, we
introduce the two matrices</p>
<code class='large'>rmw: ARRAY man, woman OF rank;
rwm: ARRAY woman, man OF rank</code>
<p>such that <code>rmw<sub>m,w</sub></code>
denotes woman <code>w</code>'s rank in the preference
list of man <code>m</code>, and <code>rwm<sub>w,m</sub></code>
denotes the rank of man
<code>m</code> in the list of <code>w</code>.
It is plain that the values of these auxiliary arrays are constant
and can initially be determined from the values of
<code>wmr</code> and <code>mwr</code>.</p>

<p>The process of determining the predicate
<code class="pseudo">stable</code>
now proceeds strictly according to its original
definition. Recall that we are trying the feasibility of marrying
<code>m</code> and <code>w</code>, where
<code>w = wmr<sub>m,r</sub></code> , i.e.,
<code>w</code> is man <code>m</code>'s
<code>r</code>-th choice. Being optimistic, we first
presume that stability still prevails, and then we set out to find
possible sources of trouble. Where could they be hidden? There are
two symmetrical possibilities:</p>

<ol id="l62">
<li data-list-text="1.">
<p>There might be a women <code>pw</code>, preferred to
<code>w</code> by <code>m</code>, who herself
prefers <code>m</code> over her husband.</p>

</li>
<li data-list-text="2.">
<p>There might be a man <code>pm</code>, preferred to
<code>m</code> by <code>w</code>, who himself
prefers <code>w</code> over his wife.</p>
</li>
</ol>
<p>Pursuing trouble source 1, we compare ranks
<code>rwm<sub>pw,m</sub></code> and
<code>rwm<sub>pw,y[pw]</sub></code> for all women
preferred to <code>m</code> by <code>w</code>, i.e.
for all <code>pw = wmr<sub>m,i</sub></code> such that
<code>i &lt; r</code>. We happen to know that all these candidate women are
already married because, were anyone of them still single,
<code>m</code> would have picked her beforehand. The
described process can be formulated by a simple linear search;
<code>S</code> denotes stability.</p>

<code class='large'>i := -1; S := TRUE;
REPEAT
  INC(i);
  IF i &lt; r THEN
    pw := wmr[m,i];
    IF ~single[pw] THEN S := rwm[pw,m] &gt; rwm[pw, y[pw]] END
  END
UNTIL (i = r) OR ~S</code>

<p>Hunting for trouble source 2, we must investigate all candidates
<code>pm</code> who are preferred by <code>w</code>
to their current assignation <code>m</code>,
i.e., all preferred men <code>pm = mwr<sub>w,i</sub></code>
such that <code>i &lt; rwm<sub>w,m</sub></code>.
In analogy to tracing trouble source 1, comparison
between ranks <code>rmwp<sub>m,w</sub></code> and
<code>rmw<sub>pm,x[pm]</sub></code> is necessary. We
must be careful, however, to omit comparisons involving
<code>x<sub>pm</sub></code> where
<code>pm</code> is still single. The necessary safeguard
is a test <code>pm &lt; m</code>, since we know that all
men preceding <code>m</code> are already married.</p>

<p>The complete algorithm is shown below.
Table 3.4 specifies the nine
computed stable solutions from input data
<code>wmr</code> and <code>mwr</code> given in Table 3.3.</p>

<code class='large'>PROCEDURE write; <span>(* ADenS36_Marriages *)</span>
  (*global writer W*)
  VAR m: man; rm, rw: INTEGER;
BEGIN
  rm := 0; rw := 0;
  FOR m := 0 TO n-1 DO
    Texts.WriteInt(W, x[m], 4);
    rm := rmw[m, x[m]] + rm; rw := rwm[x[m], m] + rw
  END;
  Texts.WriteInt(W, rm, 8); Texts.WriteInt(W, rw, 4);
  Texts.WriteLn(W)
END write;

PROCEDURE stable (m, w, r: INTEGER): BOOLEAN;
  VAR pm, pw, rank, i, lim: INTEGER; S: BOOLEAN;
BEGIN
  i := -1; S := TRUE;
  REPEAT
    INC(i);
    IF i &lt; r THEN
      pw := wmr[m,i];
      IF ~single[pw] THEN S := rwm[pw,m] &gt; rwm[pw, y[pw]] END
    END
  UNTIL (i = r) OR ~S;

  i := -1; lim := rwm[w,m];
  REPEAT
    INC(i);
    IF i &lt; lim THEN
      pm := mwr[w,i];
      IF pm &lt; m THEN S := rmw[pm,w] &gt; rmw[pm, x[pm]] END
    END
  UNTIL (i = lim) OR ~S;

  RETURN S
END stable;

PROCEDURE Try (m: INTEGER);
  VAR w, r: INTEGER;
BEGIN
  IF m &lt; n THEN
    FOR r := 0 TO n-1 DO
      w := wmr[m,r];
      IF single[w] &amp; stable(m,w,r) THEN
        x[m] := w; y[w] := m; single[w] := FALSE; Try(m+1);
        single[w] := TRUE
      END
    END
  ELSE
    write
  END
END Try;

PROCEDURE FindStableMarriages (VAR S: Texts.Scanner);
  VAR m, w, r: INTEGER;
BEGIN
  FOR m := 0 TO n-1 DO
    FOR r := 0 TO n-1 DO
      Texts.Scan(S); wmr[m,r] := S.i; rmw[m, wmr[m,r]] := r
    END
  END;
  FOR w := 0 TO n-1 DO
    single[w] := TRUE;
    FOR r := 0 TO n-1 DO
      Texts.Scan(S); mwr[w,r] := S.i; rwm[w, mwr[w,r]] := r
    END
  END;
  Try(0)
END FindStableMarriages
</code>

<p>This algorithm is based on a straightforward backtracking scheme.
Its efficiency primarily depends on the sophistication of the
solution tree pruning scheme. A somewhat faster, but more complex
and less transparent algorithm has been presented by McVitie and
Wilson [3-1 and 3-2], who also have extended it to the case of sets
(of men and women) of unequal size.</p>

<p>Algorithms of the kind of the last two examples, which generate all
possible solutions to a problem (given certain constraints), are
often used to select one or several of the solutions that are
optimal in some sense. In the present example, one might, for
instance, be interested in the solution that on the average best
satisfies the men, or the women, or everyone.</p>

<p>Notice that Table 3.4 indicates the sums of the ranks of all women
in the preference lists of their husbands, and the sums of the
ranks of all men in the preference
lists of their wives. These are the values</p>

<code class='large'>rm = Sm: 0 ≤ m &lt; n: rmw<sub>m,x[m]</sub>
rw = Sm: 0 ≤ m &lt; n: rwm<sub>x[m],m</sub>
</code>
<br/>

<div class='table'><table>
<tr><td></td><td>x0</td><td> x1</td><td> x2</td><td> x3</td><td> x4</td><td> x5</td><td> x6</td><td> x7</td><td> rm</td><td> rw</td><td> c </td></tr>
<tr>
<td>0</td><td>6</td><td>3</td><td>2</td><td>7</td><td>0</td><td>4</td><td>1</td><td>5</td><td>8</td><td>24</td><td>21</td></tr>
<tr>
<td>1</td><td>1</td><td>3</td><td>2</td><td>7</td><td>0</td><td>4</td><td>6</td><td>5</td><td>14</td><td>19</td><td>449</td></tr>
<tr>
<td>2</td><td>1</td><td>3</td><td>2</td><td>0</td><td>6</td><td>4</td><td>7</td><td>5</td><td>23</td><td>12</td><td>59</td></tr>
<tr>
<td>3</td><td>5</td><td>3</td><td>2</td><td>7</td><td>0</td><td>4</td><td>6</td><td>1</td><td>18</td><td>14</td><td>62</td></tr>
<tr>
<td>4</td><td>5</td><td>3</td><td>2</td><td>0</td><td>6</td><td>4</td><td>7</td><td>1</td><td>27</td><td>7</td><td>47</td></tr>
<tr>
<td>5</td><td>5</td><td>2</td><td>3</td><td>7</td><td>0</td><td>4</td><td>6</td><td>1</td><td>21</td><td>12</td><td>143</td></tr>
<tr>
<td>6</td><td>5</td><td>2</td><td>3</td><td>0</td><td>6</td><td>4</td><td>7</td><td>1</td><td>30</td><td>5</td><td>47</td></tr>
<tr>
<td>7</td><td>2</td><td>5</td><td>3</td><td>7</td><td>0</td><td>4</td><td>6</td><td>1</td><td>26</td><td>10</td><td>758</td></tr>
<tr>
<td>8</td><td>2</td><td>5</td><td>3</td><td>0</td><td>6</td><td>4</td><td>7</td><td>1</td><td>35</td><td>3</td><td>34</td></tr>
</table></div>

<p><code>c</code>= number of evaluations of stability.</p>
<p>Solution 0 = male optimal solution; solution 8 = female optimal
solution.</p>
<p>Table 3.4. Result of the Stable Marriage Problem.</p>

<p>The solution with the least value <code>rm</code> is
called the male-optimal stable solution; the one with the smallest
<code>rw</code> is the female-optimal stable solution.
It lies in the nature of the chosen search strategy that good
solutions from the men's point of view are generated first and the
good solutions from the women's perspective appear toward the end.
In this sense, the algorithm is based toward the male population.
This can quickly be changed by systematically interchanging the
role of men and women, i.e., by merely interchanging
<code>mwr</code> with <code>wmr</code> and interchanging
<code>rmw</code> with <code>rwm</code>.</p>

<p>We refrain from extending this program further and leave the
incorporation of a search for an optimal solution to the next and
last example of a backtracking algorithm.</p>

</li>
<li data-list-text="3.7" id="3.7">
<h3><a href='#3.7' id='3.7'>The Optimal Selection Problem</a></h3>

<!--  обрыв
</li>
</ol>
</li>
</ol>
-->

<p>The last example of a backtracking algorithm is a logical extension
of the previous two examples represented by the general schema.
First we were using the principle of backtracking to find a
<i>single</i> solution to a given problem. This was exemplified by
the knight's tour and the eight queens. Then we tackled the goal of
finding <i>all</i> solutions to a given problem; the examples were
those of the eight queens and the stable marriages. Now we wish to
find an <i>optimal</i> solution.</p>

<p>To this end, it is necessary to generate all possible solutions,
and in the course of generating them to retain the one that is
optimal in some specific sense. Assuming that optimality is defined
in terms of some positive valued function <code>f(s)</code>,
the algorithm is derived from the general schema
of <code>Try</code> by replacing the statement
<code class="pseudo">print solution</code> by the statement</p>

<code class='large'>IF f(solution) &gt; f(optimum) THEN optimum := solution END</code>

<p>The variable <code>optimum</code> records the best
solution so far encountered. Naturally, it has to be properly
initialized; morever, it is customary to record to value
<code>f(optimum)</code> by another variable in order to
avoid its frequent recomputation.</p>

<p>An example of the general problem of finding an optimal solution to
a given problem follows: We choose the important and frequently
encountered problem of finding an optimal selection out of a given
set of objects subject to constraints. Selections that constitute
acceptable solutions are gradually built up by investigating
individual objects from the base set. A procedure
<code>Try</code> describes the process of investigating the
suitability of one individual object, and it is called recursively
(to investigate the next object) until all objects have been considered.</p>

<p>We note that the consideration of each object (called candidates in
previous examples) has two possible outcomes, namely, either the
inclusion of the investigated object in the current selection or
its exclusion. This makes the use of a repeat or for statement
inappropriate; instead, the two cases may as well be explicitly
written out. This is shown, assuming that the objects are numbered
<code>0, 1, ... , n-1.</code></p>

<code class='large'>PROCEDURE Try (i: INTEGER);
BEGIN
  IF i &lt; n THEN
    IF <i>inclusion is acceptable</i> THEN
      <code class="pseudo">include i-th object;</code>
      Try(i+1);
      <code class="pseudo">eliminate i-th object</code>
    END;
    IF <i>exclusion is acceptable</i> THEN
      Try(i+1)
    END
  ELSE
    <code class="pseudo">check optimality</code>
  END
END Try</code>

<p>From this pattern it is evident that there are
<code>2<sup>n</sup></code> possible sets; clearly,
appropriate acceptability criteria must be employed to reduce the
number of investigated candidates very drastically. In order to
elucidate this process, let us choose a concrete example for a
selection problem: Let each of the <code>n</code>
objects <code>a<sub>0</sub>, ... , a<sub>n-1</sub></code> be
characterized by its weight and its value. Let the optimal set be
the one with the largest sum of the values of its components, and
let the constraint be a limit on the sum of their weight. This is a
problem well known to all travellers who pack suitcases by
selecting from <code>n</code> items in such a way that
their total value is optimal and that their total weight does not
exceed a specific allowance.</p>

<p>We are now in a position to decide upon the representation of the
given facts in terms of global variables. The choices are easily
derived from the foregoing developments:</p>
<code class='large'>TYPE Object = RECORD weight, value: INTEGER END;
VAR a: ARRAY n OF Object;
  limw, totv, maxv: INTEGER; s, opts: SET
</code>

<p>The variables <code>limw</code> and <code>totv</code>
denote the weight limit and the total value of all
<code>n</code> objects. These two values are actually
constant during the entire selection process.
<code>s</code> represents the current selection of objects in which
each object is represented by its name (index).
<code>opts</code> is the optimal selection so far encountered, and
<code>maxv</code> is its value.</p>

<p>Which are now the criteria for acceptability of an object for the
current selection? If we consider <i>inclusion</i>, then an object
is selectable, if it fits into the weight allowance. If it does not
fit, we may stop trying to add further objects to the current
selection. If, however, we consider <i>exclusion</i>, then the
criterion for acceptability, i.e., for the continuation of building
up the current selection, is that the total value which is still
achievable after this exclusion is not less than the value of the
optimum so far encountered. For, if it is less, continuation of the
search, although it may produce some solution, will not yield the
optimal solution. Hence any further search on the current path is
fruitless. From these two conditions we determine the relevant
quantities to be computed for each step in the selection
process:</p>

<ol id="l63">
<li data-list-text="1.">
<p>The total weight <code>tw</code> of the selection
<code>s</code> so far made.</p>
</li>
<li data-list-text="2.">
<p>The still achievable value <code>av</code> of the
current selection <code>s</code>.</p>
</li>
</ol>

<p>These two entities are appropriately represented as parameters of
the procedure <code>Try</code>. The condition</p>
<code class="pseudo">inclusion is acceptable</code>
can now be formulated as</p>
<code>tw + a[i].weight &lt; limw</code>
<p>and the subsequent check for optimality as</p>
<code class='large'>IF av &gt; maxv THEN
  (*new optimum, record it*)
  opts := s; maxv := av
END</code>

<p>The last assignment is based on the reasoning that the achievable
value is the achieved value, once all <code>n</code>
objects have been dealt with. The condition
<code class="pseudo">exclusion is acceptable</code> is expressed by</p>
<code>av - a[i].value &gt; maxv</code>
<p>Since it is used again thereafter, the value
<code>av - a[i].value</code> is given the name
<code>av1</code> in order to circumvent its reevaluation.</p>

<p>The entire procedure is now composed of the discussed parts with
the addition of appropriate initialization statements for the
global variables. The ease of expressing inclusion and exclusion
from the set <code>s</code> by use of set operators is
noteworthy. The results <code>opts</code> and
<code>maxv</code> of the program <code>Selection</code>
with weight allowances ranging from 10 to 120
are listed in Table 3.5.</p>
<code class='large'>TYPE Object = RECORD value, weight: INTEGER END; <span>(* ADenS37_OptSelection *)</span>
  VAR a: ARRAY n OF Object;
    limw, totv, maxv: INTEGER; s, opts: SET;

PROCEDURE Try (i, tw, av: INTEGER);
  VAR tw1, av1: INTEGER;
BEGIN
  IF i &lt; n THEN
    (*try inclusion*)
    tw1 := tw + a[i].weight;
    IF tw1 &lt;= limw THEN
      s := s + {i};
      Try(i+1, tw1, av);
      s := s - {i}
    END;
    (*try exclusion*)
    av1 := av - a[i].value;
    IF av1 &gt; maxv THEN
      Try(i+1, tw, av1)
    END
  ELSIF av &gt; maxv THEN
    maxv := av; opts := s
  END
END Try;

PROCEDURE Selection (WeightInc, WeightLimit: INTEGER);
BEGIN
  limw := 0;
  REPEAT
    limw := limw + WeightInc; maxv := 0;
    s := {}; opts := {}; Try(0, 0, totv);
  UNTIL limw &gt;= WeightLimit
END Selection.</code>

<div class='table'><table>
<tr>
<td>Weight:</td><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td><td>16</td><td>17</td><td>18</td><td>19</td><td>

</td>
</tr>
<tr>
<td>Value:</td><td>18</td><td>20</td><td>17</td><td>19</td><td>25</td><td>21</td><td>27</td><td>23</td><td>25</td><td>24</td></tr>
<tr>
<td>limw <span class="s42">↓</span></td><td>

</td>
<td>

</td>
<td>

</td>
<td>

</td>
<td>

</td>
<td>

</td>
<td>

</td>
<td>

</td>
<td>

</td>
<td>

</td>
<td>maxv</td></tr>
<tr>
<td>10</td><td>*</td><td>

</td>
<td>

</td>
<td>

</td>
<td>

</td>
<td>

</td>
<td>

</td>
<td>

</td>
<td>

</td>
<td>

</td>
<td>18</td></tr>
<tr>
<td>20</td><td>

</td>
<td>

</td>
<td>

</td>
<td>

</td>
<td>

</td>
<td>

</td>
<td>*</td><td>

</td>
<td>

</td>
<td>

</td>
<td>27</td></tr>
<tr>
<td>30</td><td>

</td>
<td>

</td>
<td>

</td>
<td>

</td>
<td>*</td><td>

</td>
<td>*</td><td>

</td>
<td>

</td>
<td>

</td>
<td>52</td></tr>
<tr>
<td>40</td><td>*</td><td>

</td>
<td>

</td>
<td>

</td>
<td>*</td><td>

</td>
<td>*</td><td>

</td>
<td>

</td>
<td>

</td>
<td>70</td></tr>
<tr>
<td>50</td><td>*</td><td>*</td><td>

</td>
<td>*</td><td>

</td>
<td>

</td>
<td>*</td><td>

</td>
<td>

</td>
<td>

</td>
<td>84</td></tr>
<tr>
<td>60</td><td>*</td><td>*</td><td>*</td><td>*</td><td>*</td><td>

</td>
<td>

</td>
<td>

</td>
<td>

</td>
<td>

</td>
<td>99</td></tr>
<tr>
<td>70</td><td>*</td><td>*</td><td>

</td>
<td>

</td>
<td>*</td><td>

</td>
<td>*</td><td>

</td>
<td>*</td><td>

</td>
<td>115</td></tr>
<tr>
<td>80</td><td>*</td><td>*</td><td>*</td><td>

</td>
<td>*</td><td>

</td>
<td>*</td><td>*</td><td>

</td>
<td>

</td>
<td>130</td></tr>
<tr>
<td>90</td><td>*</td><td>*</td><td>

</td>
<td>

</td>
<td>*</td><td>

</td>
<td>*</td><td>

</td>
<td>*</td><td>*</td><td>139</td></tr>
<tr>
<td>100</td><td>*</td><td>*</td><td>

</td>
<td>*</td><td>*</td><td>

</td>
<td>*</td><td>*</td><td>*</td><td>

</td>
<td>157</td></tr>
<tr>
<td>110</td><td>*</td><td>*</td><td>*</td><td>*</td><td>*</td><td>*</td><td>*</td><td>

</td>
<td>*</td><td>

</td>
<td>172</td></tr>
<tr>
<td>120</td><td>*</td><td>*</td><td>

</td>
<td>

</td>
<td>*</td><td>*</td><td>*</td><td>*</td><td>*</td><td>*</td><td>183</td></tr>
</table></div>

<p>Table 3.5. Sample Output from Optimal Selection Program.</p>

<p>The asterisks mark the objects that form the optimal sets
<code>opts</code> for the total weight limits ranging
from 10 to 120.</p>

<p>This backtracking scheme with a limitation factor curtailing the
growth of the potential search tree is also known as <i>branch and
bound algorithm</i>.</p>

<h3 id="3.exe"><a href='#3.exe'>Exercises</a></h3>
<div>
<ol class="noindent" id="l65">
<li data-list-text="3.1.">
<p>(Towers of Hanoi). Given are three rods and <code>n</code>
disks of different sizes. The disks can be stacked up
on the rods, thereby forming towers. Let the <code>n</code>
disks initially be placed on rod <code>A</code> in the order
of decreasing size, as shown in Fig. 3.9
for <code>n = 3</code>. The task is to move the
<code>n</code> disks from rod <code>A</code>
to rod <code>C</code> such that they are ordered in the
original way. This has to be achieved under the constraints
that</p>

<ol class="noindent" id="l66">
<li data-list-text="1.">
<p>In each step exactly one disk is moved from one rod to another
rod.</p>
</li>
<li data-list-text="2.">
<p>A disk may never be placed on top of a smaller disk.</p>
</li>
<li data-list-text="3.">
<p>Rod <code>B</code> may be used as an auxiliary store.</p>

<p>Find an algorithm that performs this task. Note that a tower may
conveniently be considered as consisting of the single disk at the
top, and the tower consisting of the remaining disks. Describe the
algorithm as a recursive program.</p>

<img src="fig/3.9.png" width="500"/>
<p>Fig. 3.9. The towers of Hanoi</p>

</li>
</ol>
</li>
<li data-list-text="3.2.">
<p>Write a procedure that generates all <code>n!</code>
permutations of <code>n</code> elements
<code>a<sub>0</sub>, ..., a<sub>n-1</sub></code> <i>in situ</i>,
i.e., without the aid of another
array. Upon generating the next permutation, a parametric procedure
<code>Q</code> is to be called which may, for instance,
output the generated permutation.</p>

<p><em>Hint:</em> Consider the task of
generating all permutations of the elements
<code>a<sub>0</sub>, ..., a<sub>m-1</sub></code>
as consisting of the m subtasks of generating all permutations
of <code>a<sub>0</sub>, ..., a<sub>m-2</sub></code>
followed by <code>a<sub>m-1</sub></code>,
where in the <code>i</code>-th subtask the two elements
<code>a<sub>i</sub></code> and <code>a<sub>m-1</sub></code>
had initially been interchanged.</p>
</li>
<li data-list-text="3.3.">
<p>Deduce the recursion scheme of Fig. 3.10 which is a superposition
of the four curves <code>W<sub>1</sub></code>,
<code>W<sub>2</sub></code>, <code>W<sub>3</sub></code>,
<code>W<sub>4</sub></code>. The structure is similar to that of the Sierpinski
curves in Fig. 3.6. From the recursion pattern, derive a recursive
program that draws these curves.</p>

<img src="fig/3.10.png"/>
<p>Fig. 3.10. Curves <code>W<sub>1</sub></code> – <code>W<sub>4</sub></code>.</p>

</li>
<li data-list-text="3.4.">
<p>Only 12 of the 92 solutions computed by the Eight Queens algorithm
are essentially different. The other ones can be derived by
reflections about axes or the center point. Devise a program that
determines the 12 principal solutions. Note that, for example, the
search in column 1 may be restricted to positions 1-4.</p>
</li>
<li data-list-text="3.5.">
<p>Change the Stable Marriage program so that it determines the
optimal solution (male or female). It therefore becomes a branch
and bound program of the type represented by the program
<code>Selection</code>.</p>
</li>
<li data-list-text="3.6.">
<p>A certain railway company serves <code>n</code> stations
<code>S<sub>0</sub>, ... , S<sub>n-1</sub></code>. It intends
to improve its customer information service by computerized
information terminals. A customer types in his departure station
<code>SA</code> and his destination <code>SD</code>,
and he is supposed to be (immediately) given the
schedule of the train connections with minimum total time of the
journey. Devise a program to compute the desired information.
Assume that the timetable (which is your data bank) is provided in
a suitable data structure containing departure (= arrival) times of
all available trains. Naturally, not all stations are connected by
direct lines (see also Exercise 1.6).</p>
</li>
<li data-list-text="3.7.">
<p>The Ackermann Function <code>A</code> is defined for all
non-negative integer arguments <code>m</code> and
<code>n</code> as follows:</p>

<code class='large'>A(0, n) = n + 1
A(m, 0) = A(m-1, 1)  (m &gt; 0)
A(m, n) = A(m-1, A(m, n-1))  (m, n &gt; 0)</code>

<p class="s72">
Design a program that computes <code>A(m,n)</code>
without the use of recursion. As a guideline, use the procedure
<code>NonRecursiveQuickSort</code> from sec. 2.3.3.
Devise a set of rules for the transformation of recursive into
iterative programs in general.
</p>

</li>
</ol>

<h3 id="3.ref"><a href='#3.ref'>References</a></h3>
<ol class='page id'>
  <li id="[3.1]">
    D.G. McVitie and L.B. Wilson. The Stable Marriage Problem.
    <em>Comm. ACM</em>, 14, No. 7 (1971), 486-92.
  </li>
  <li id="[3.2]">
    D.G. McVitie and L.B. Wilson. Stable Marriage Assignment for
    Unequal Sets. <em>Bit</em>, 10, (1970), 295-309.
  </li>
  <li id="[3.3]">
    Space Filling Curves, or How to Waste Time on a Plotter.
    <em>Software — Practice and Experience</em>, 1, No.
    4 (1971), 403-40.
  </li>
  <li id="[3.4]">
    N. Wirth. Program Development by Stepwise Refinement.
    <em>Comm. ACM</em>, 14, No. 4 (1971), 221-27.
  </li>
</ol>
</div>

</li>
</ol>

<p class="newpage"></p>

<li data-list-text="4" id="4">
<h2><a href='#4'>Dynamic Information Structures</a></h2>
<ol id="l68" class="page">
<li data-list-text="4.1" id="4.1">
<h3><a href='#4.1' id='4.1'>Recursive Data Types</a></h3>

<p>In Chap. 1 the array, record, and set structures were introduced as
fundamental data structures. They are called fundamental because
they constitute the building blocks out of which more complex
structures are formed, and because in practice they do occur most
frequently. The purpose of defining a data type, and of thereafter
specifying that certain variables be of that type, is that the
range of values assumed by these variables, and therefore their
storage pattern, is fixed once and for all. Hence, variables
declared in this way are said to be <em>static</em>.
However, there are many problems which involve far more complicated
information structures. The characteristic of these problems is
that not only the values but also the structures of variables
change during the computation. They are therefore called
<em>dynamic</em> structures. Naturally, the
components of such structures are — at some level of resolution —
static, i.e., of one of the fundamental data types. This chapter is
devoted to the construction, analysis, and management of dynamic
information structures.</p>

<p>It is noteworthy that there exist some close analogies between the
methods used for structuring algorithms and those for structuring
data. As with all analogies, there remain some differences, but a
comparison of structuring methods for programs and data is
nevertheless illuminating.</p>

<p>The elementary, unstructured statement is the assignment of an
expression's value to a variable. Its corresponding member in the
family of data structures is the scalar, unstructured type. These
two are the atomic building blocks for composite statements and
data types. The simplest structures, obtained through enumeration
or sequencing, are the compound statement and the record structure.
They both consist of a finite (usually small) number of explicitly
enumerated components, which may themselves all be different from
each other. If all components are identical, they need not be
written out individually: we use the <code>for</code>
statement and the <code>array</code> structure to
indicate replication by a known, finite factor. A choice among two
or more elements is expressed by the conditional or the case
statement and by extensions of record types, respectively. And
finally, a repetiton by an initially unknown (and potentially
infinite) factor is expressed by the <code>while</code>
and <code>repeat</code> statements. The corresponding
data structure is the <em>sequence</em> (file), the
simplest kind which allows the construction of types of infinite
cardinality.</p>

<p>The question arises whether or not there exists a data structure
that corresponds in a similar way to the procedure statement.
Naturally, the most interesting and novel property of procedures in
this respect is recursion. Values of such a recursive data type
would contain one or more components belonging to the same type as
itself, in analogy to a procedure containing one or more calls to
itself. Like procedures, data type definitions might be directly or
indirectly recursive.</p>

<p>A simple example of an object that would most appropriately be
represented as a recursively defined type is the arithmetic
expression found in programming languages. Recursion is used to
reflect the possibility of nesting, i.e., of using parenthesized
subexpressions as operands in expressions. Hence, let an expression
here be defined informally as follows:</p>

<p>An expression consists of a term, followed by an operator, followed
by a term. (The two terms constitute the operands of the operator.)
A term is either a variable — represented by an identifier — or an
expression enclosed in parentheses.</p>

<p>A data type whose values represent such expressions can easily be
described by using the tools already available with the addition of
recursion:</p>

<code class='large'>TYPE expression = RECORD op: INTEGER;
                    opd1, opd2: term END

TYPE term =       RECORD
                    IF t: BOOLEAN THEN id: Name ELSE subex: expression END
                  END
</code>

<p>Hence, every variable of type <code>term</code> consists
of two components, namely, the tagfield <code>t</code>
and, if <code>t</code> is true, the field <code>id</code>,
or of the field <code>subex</code>
otherwise. Consider now, for example, the following four
expressions:</p>

<ol id="l69">
<li data-list-text="1.">
<code>x + y</code>
</li>
<li data-list-text="2.">
<code>x - (y * z)</code>
</li>
<li data-list-text="3.">
<code>(x + y) * (z - w)</code>
</li>
<li data-list-text="4.">
<code>(x/(y + z)) * w</code>
</li>
</ol>

<p>These expressions may be visualized by the patterns in Fig. 4.1,
which exhibit their nested, recursive structure, and they determine
the layout or mapping of these expressions onto a store.</p>

<p>A second example of a recursive information structure is the family
pedigree: Let a pedigree be defined by (the name of) a person and
the two pedigrees of the parents. This definition leads inevitably
to an infinite structure. Real pedigrees are bounded because at
some level of ancestry information is missing. Assume that this can
be taken into account by again using a conditional structure:</p>
<code class='large'>TYPE ped = RECORD
             IF known: BOOLEAN THEN name: Name; father, mother: ped END
           END
</code>

<p>Note that every variable of type <code>ped</code> has at
least one component, namely, the tagfield called <code>known</code>.
If its value is <code>TRUE</code>,
then there are three more fields; otherwise there is none. A
particular value is shown here in the forms of a nested expression
and of a diagram that may suggest a possible storage pattern (see
Fig. 4.2).</p>

<code class='large'>(T, Ted, (T, Fred, (T, Adam, (F), (F)), (F)), (T, Mary, (F), (T, Eva, (F), (F)))</code>

<div class='table'><table>
<tr>
  <td>1.</td>
  <td>
  <div class='table'><table>
  <tr>
  <td colspan="2">
  <p class="s61">+</p>
  </td>
  </tr>
  <tr>
  <td>T</td><td>x</td></tr>
  <tr>
  <td>T</td><td>y</td></tr>
  </table></div>
  </td>

  <td></td><td></td>
  
  <td>2.</td>
  
  <td>
  <div class='table'><table>
  <tr>
  <td colspan="3">
  <p class="s61">-</p>
  </td>
  </tr>
  <tr>
  <td>T</td><td colspan="2">
  <p class="s61">x</p>
  </td>
  </tr>
  <tr>
  <td rowspan="3">

  <p class="s61">F</p>
  </td>
  <td colspan="2">
  <p class="s61">*</p>
  </td>
  </tr>
  <tr>
  <td>T</td><td>y</td></tr>
  <tr>
  <td>T</td><td>z</td></tr>
  </table></div>
  </td>
  
</tr><tr><td>&nbsp;</td></tr><tr>

  <td>3.</td>

  <td>
  <div class='table'><table>
  <tr>
  <td colspan="3">
  <p class="s61">*</p>
  </td>
  </tr>
  <tr>
  <td rowspan="3">

  <p class="s61">F</p>
  </td>
  <td colspan="2">
  <p class="s61">+</p>
  </td>
  </tr>
  <tr>
  <td>T</td><td>x</td></tr>
  <tr>
  <td>T</td><td>y</td></tr>
  <tr>
  <td rowspan="3">

  <p class="s61">F</p>
  </td>
  <td colspan="2">
  <p class="s61">-</p>
  </td>
  </tr>
  <tr>
  <td>T</td><td>z</td></tr>
  <tr>
  <td>T</td><td>w</td></tr>
  </table></div>
  </td>

  <td></td><td></td>

  <td>4.</td>

  <td>
  <div class='table'><table>
  <tr>
  <td colspan="4">
  <p class="s61">*</p>
  </td>
  </tr>
  <tr>
  <td rowspan="5">

  <p class="s61">F</p>
  </td>
  <td colspan="3">
  <p class="s61">/</p>
  </td>
  </tr>
  <tr>
  <td>T</td><td colspan="2">
  <p class="s61">x</p>
  </td>
  </tr>
  <tr>
  <td rowspan="3">

  <p class="s61">F</p>
  </td>
  <td colspan="2">
  <p class="s61">+</p>
  </td>
  </tr>
  <tr>
  <td>T</td><td>y</td></tr>
  <tr>
  <td>T</td><td>z</td></tr>
  <tr>
  <td>T</td><td colspan="3">
  <p class="s61">w</p>
  </td>
  </tr>
  </table></div>

  </td>

</tr>
</table></div>

<p>Fig. 4.1. Storage patterns for recursive record structures</p>

<img src="fig/4.2.png" width="280"/>
<p>Fig. 4.2. An example of a recursive data structure</p>

<p>The important role of the variant facility becomes clear; it is the
only means by which a recursive data structure can be bounded, and
it is therefore an inevitable companion of every recursive
definition. The analogy between program and data structuring
concepts is particularly pronounced in this case. A conditional (or
selective) statement must necessarily be part of every recursive
procedure in order that execution of the procedure can terminate.
In practice, dynamic structures involve references or pointers to
its elements, and the concept of an alternative (to terminate the
recursion) is implied in the pointer, as shown in the next
paragraph.</p>

</li>
<li data-list-text="4.2" id="4.2">

<h3><a href='#4.2'>Pointers</a></h3>
<p>The characteristic property of recursive structures which clearly
distinguishes them from the fundamental structures (arrays,
records, sets) is their ability to vary in size. Hence, it is
impossible to assign a fixed amount of storage to a recursively
defined structure, and as a consequence a compiler cannot associate
specific addresses to the components of such variables. The
technique most commonly used to master this problem involves
dynamic allocation of storage, i.e., allocation of store to
individual components at the time when they come into existence
during program execution, instead of at translation time. The
compiler then allocates a fixed amount of storage to hold the
address of the dynamically allocated component instead of the
component itself. For instance, the pedigree illustrated in Fig.
4.2 would be represented by individual — quite possibly
noncontiguous — records, one for each person.
These persons are then linked by their addresses assigned to the
respective <code>father</code> and <code>mother</code>
fields. Graphically, this situation is best
expressed by the use of arrows or pointers (Fig. 4.3).</p>

<img src="fig/4.3.png" width="780"/>
<p>Fig. 4.3. Data structure linked by pointers</p>

<p>It must be emphasized that the use of pointers to implement
recursive structures is merely a technique. The programmer need not
be aware of their existence. Storage may be allocated automatically
the first time a new component is referenced. However, if the
technique of using references or pointers is made explicit, more
general data structures can be constructed than those definable by
purely recursive data definiton. In particular, it is then possible
to define potentially infinite or circular (graph) structures and
to dictate that certain structures are shared. It has therefore
become common in advanced programming languages to make possible
the explicit manipulation of references to data in addition to the
data themeselves. This implies that a clear notational distinction
must exist between data and references to data and that
consequently data types must be introduced whose values are
pointers (references) to other data. The notation we use for this
purpose is the following:</p>
<code>TYPE T = POINTER TO T0</code>
<p>This type declaration expresses that values of type
<code>T</code> are pointers to data of type <code>T0</code>.
It is fundamentally important that the type of
elements pointed to is evident from the declaration of <code>T</code>.
We say that <code>T</code> is <i>bound
to</i> <code>T0</code>. This binding distinguishes
pointers in higher-level languages from addresses in assembly
codes, and it is a most important facility to increase security in
programming through redundancy of the underlying notation.</p>

<img alt="p: POINTER TO T  p^: T" src="fig/4.4.png" width="480"/>

<p>Fig. 4.4. Dynamic allocation of variable <code>p^</code>.</p>

<p>Values of pointer types are generated whenever a data item is
dynamically allocated. We will adhere to the convention that such
an occasion be explicitly mentioned at all times. This is in
contrast to the situation in which the first time that an item is
mentioned it is automatically allocated. For this purpose, we
introduce a procedure <code>NEW</code>. Given a pointer
variable <code>p</code> of type <code>T</code>, the statement <code>NEW(p)</code>
effectively allocates a variable of type <code>T0</code>
and assigns the pointer referencing this new variable to
<code>p</code> (see Fig. 4.4). The pointer value itself
can now be referred to as <code>p</code> (i.e., as the
value of the pointer variable <code>p</code>). In
contrast, the variable which is referenced by <code>p</code>
is denoted by <code>p^</code>. The
referenced structures are typically records. If the referenced
record has, for example, a field <code>x</code>, then it
is denoted by <code>p^.x</code>. Because it is clear
that not the pointer <code>p</code> has any fields, but only the
referenced record <code>p^</code>, we allow the
abbreviated notation <code>p.x</code> in place of
<code>p^.x</code>.</p>

<p>It was mentioned above that a variant component is essential in
every recursive type to ensure finite instances. The example of the
family predigree is of a pattern that exhibits a most frequently
occurring constellation, namely, the case in which one of the two
cases features no further components. This is expressed by the
following declaration schema:</p>
<code class='large'>TYPE T = RECORD
           IF nonterminal: BOOLEAN THEN S(T) END
         END
</code>
<p><code>S(T)</code> denotes a sequence of field definitions which
includes one or more fields of type <code>T</code>,
thereby ensuring recursivity. All structures of a type patterned
after this schema exhibit a tree (or list) structure similar to
that shown in Fig. 4.3. Its peculiar property is that it contains
pointers to data components with a tag field only, i.e., without
further relevant information. The implementation technique using
pointers suggests an easy way of saving storage space by letting
the tag information be included in the pointer value itself. The
common solution is to extend the range of values of all pointer
types by a single value that is pointing to no element at all. We
denote this value by the special symbol <code>NIL</code>,
and we postulate that the value <code>NIL</code> can be
assumed by all pointer typed variables. This extension of the range
of pointer values explains why finite structures may be generated
without the explicit presence of variants (conditions) in their
(recursive) declaration.</p>

<p>The new formulations of the explicitly recursive data types
declared above are reformulated using pointers as shown below. Note
that the field <code>known</code> has vanished, since
<code>~p.known</code> is now expressed as <code>p = NIL</code>.
The renaming of the type <code>ped</code>
to <code>Person</code> reflects the
difference in the viewpoint brought about by the introduction of
explicit pointer values. Instead of first considering the given
structure in its entirety and then investigating its substructure
and its components, attention is focused on the components in the
first place, and their interrelationship (represented by pointers)
is not evident from any fixed declaration.</p>
<code class='large'>TYPE term =           POINTER TO TermDescriptor;
TYPE exp =            POINTER TO ExpDescriptor;
TYPE ExpDescriptor =  RECORD op: INTEGER; opd1, opd2: term END;
TYPE TermDescriptor = RECORD id: ARRAY 32 OF CHAR END
TYPE Person =         POINTER TO RECORD
                        name: ARRAY 32 OF CHAR;
                        father, mother: Person
                      END
</code>

<p><i>Note</i>. The type <code>Person</code> points to
records of an anonymous type (<code>PersonDescriptor</code>).</p>

<p>The data structure representing the pedigree shown in Figs. 4.2 and
4.3 is again shown in Fig. 4.5 in which pointers to unknown persons
are denoted by <code>NIL</code>. The resulting
improvement in storage economy is obvious.</p>

<p>Again referring to Fig. 4.5, assume that
<code>Fred</code> and <code>Mary</code> are siblings,
i.e., have the same father and mother. This situation is easily
expressed by replacing the two <code>NIL</code> values
in the respective fields of the two records. An implementation that
hides the concept of pointers or uses a different technique of
storage handling would force the programmer to represent the
ancestor records of <code>Adam</code> and <code>Eva</code>twice.
Although in accessing their data for
inspection it does not matter whether the two fathers (and the two
mothers) are duplicated or represented by a single record, the
difference is essential when selective updating is permitted.
Treating pointers as explicit data items instead of as hidden
implementation aids allows the programmer to express clearly where
storage sharing is intended and where it is not.</p>

<img src="fig/4.5.png" width="700"/>
<p>Fig. 4.5. Data structure with <code>NIL</code> pointers</p>

<p>A further consequence of the explicitness of pointers is that it is
possible to define and manipulate cyclic data structures. This
additional flexibility yields, of course, not only increased power
but also requires increased care by the programmer, because the
manipulation of cyclic data structures may easily lead to
nonterminating processes.</p>

<p>This phenomenon of power and flexibility being intimately coupled
with the danger of misuse is well known in programming, and it
particularly recalls the <code>GOTO</code> statement.
Indeed, if the analogy between program structures and data
structures is to be extended, the purely recursive data structure
could well be placed at the level corresponding with the procedure,
whereas the introduction of pointers is comparable to the use of
<code>GOTO</code> statements. For, as the <code>GOTO</code>
statement allows the construction of any kind of
program pattern (including loops), so do pointers allow for the
composition of any kind of data structure (including rings). The
parallel development of corresponding program and data structures
is shown in condensed form in Table 4.1.</p>

<div class='table'><table>
<tr>
<th>Construction Pattern</th><th>Program Statement</th><th>Data Type</th></tr>
<tr>
<td>Atomic element</td><td>Assignment</td><td>Scalar type</td></tr>
<tr>
<td>Enumeration</td><td>Compound statement</td><td>Record type</td></tr>
<tr>
<td>Repetition (known factor)</td><td>For statement</td><td>Array type</td></tr>
<tr>
<td>Choice</td><td>Conditional statement</td><td>Type union (Variant record)</td></tr>
<tr>
<td>Repetition</td><td>While or repeat statement</td><td>Sequence type</td></tr>
<tr>
<td>Recursion</td><td>Procedure statement</td><td>Recursive data type</td></tr>
<tr>
<td>General graph</td><td>GO TO statement</td><td>Structure linked by pointers</td></tr>
</table></div>
<p>Table 4.1. Correspondences of Program and Data Structures.</p>

<p>In Chap. 3, we have seen that iteration is a special case of
recursion, and that a call of a recursive procedure
<code>P</code> defined according to the following schema:</p>

<code class='large'>PROCEDURE P;
BEGIN
  IF B THEN P0; P END
END</code>

<p>where <code>P0</code> is a statement not involving
<code>P</code>, is equivalent to and replaceable by the
iterative statement</p>

<code class='large'>WHILE B DO P0 END</code>

<p>The analogies outlined in Table 4.1 reveal that a similar
relationship holds between recursive data types and the sequence.
In fact, a recursive type defined according to the schema</p>

<code class='large'>TYPE T = RECORD
   IF b: BOOLEAN THEN t0: T0; t: T END
  END
</code>
<p>where <code>T0</code> is a type not involving
<code>T</code>, is equivalent and replaceable by a
sequence of <code>T0</code>s.</p>

<p>The remainder of this chapter is devoted to the generation and
manipulation of data structures whose components are linked by
explicit pointers. Structures with specific simple patterns are
emphasized in particular; recipes for handling more complex
structures may be derived from those for manipulating basic
formations. These are the linear list or chained sequence — the
simplest case — and trees. Our preoccupation with these building
blocks of data structuring does not imply that more involved
structures do not occur in practice. In fact, the following story
appeared in a Zürich newspaper in July
1922 and is a proof that irregularity may even occur in cases which
usually serve as examples for regular structures, such as (family)
trees. The story tells of a man who laments the misery of his life
in the following words:</p>

<cite>I married a widow who had a grown-up daughter. My father, who
visited us quite often, fell in love with my step-daughter and
married her. Hence, my father became my son-in-law, and my
stepdaughter became my mother. Some months later, my wife gave
birth to a son, who became the brother-in-law of my father as well
as my uncle. The wife of my father, that is my stepdaughter, also
had a son. Thereby, I got a brother and at the same time a
grandson. My wife is my grandmother, since she is my mother's
mother. Hence, I am my wife's husband and at the same time her
step-grandson; in other words, I am my own grandfather.</cite>
</li>

<li data-list-text="4.3" id="4.3">
<h3><a href='#4.3'>Linear Lists</a></h3>

<ol class="page" id="l70">
<li data-list-text="4.3.1" id="4.3.1">
<h4><a href='#4.3.1'>Basic Operations</a></h4>

<p>The simplest way to interrelate or link a set of elements is to
line them up in a single list or queue. For, in this case, only a
single link is needed for each element to refer to its
successor.</p>

<p>Assume that types <code>Node</code> and <code>NodeDesc</code>
are defined as shown below. Every variable of
type <code>NodeDesc</code> consists of three components,
namely, an identifying key, the pointer to its successor, and
possibly further associated information. For our further
discussion, only <code>key</code> and <code>next</code> will be relevant.</p>
<code class='large'>TYPE Node =     POINTER TO NodeDesc;
TYPE NodeDesc = RECORD key: INTEGER; next: Node; data: ... END;
VAR p, q: Node (*pointer variables*)</code>

<p>A list of nodes, with a pointer to its first component being
assigned to a variable <code>p</code>, is illustrated in
Fig. 4.6. Probably the simplest operation to be performed with a
list as shown in Fig. 4.6 is the insertion of an element at its
head. First, an element of type <code>NodeDesc</code> is
allocated, its reference (pointer) being assigned to an auxiliary
pointer variable, say <code>q</code>. Thereafter, a
simple reassignment of pointers completes the operation. Note that
the order of these three statements is essential.</p>
<code>NEW(q); q.next := p; p := q</code>
<br/><br/>

<img src="fig/4.6.png" width="600"/>
<p>Fig. 4.6. Example of a linked list</p>

<p>The operation of inserting an element at the head of a list
immediately suggests how such a list can be generated: starting
with the empty list, a heading element is added repeatedly. The
process of list generation is expressed in by the following piece
of program; here the number of elements to be linked is
<code>n</code>.</p>

<code class='large'>p := NIL; (*start with empty list*)
WHILE n &gt; 0 DO
  NEW(q); q.next := p; p := q;
  q.key := n; DEC(n)
END</code>

<p>This is the simplest way of forming a list. However, the resulting
order of elements is the inverse of the order of their insertion.
In some applications this is undesirable, and consequently, new
elements must be appended at the end instead of the head of the
list. Although the end can easily be determined by a scan of the
list, this naive approach involves an effort that may as well be
saved by using a second pointer, say <code>q</code>,
always designating the last element. This method is, for example,
applied in the program <code>CrossRef</code> (sec.
4.4.3), which generates cross-references to a given text. Its
disadvantage is that the first element inserted has to be treated
differently from all later ones.</p>

<p>The explicit availability of pointers makes certain operations very
simple which are otherwise cumbersome; among the elementary list
operations are those of inserting and deleting elements (selective
updating of a list), and, of course, the traversal of a list. We
first investigate list <i>insertion</i>.</p>

<p>Assume that an element designated by a pointer (variable)
<code>q</code> is to be inserted in a list <i>after</i>
the element designated by the pointer <code>p</code>.
The necessary pointer assignments are expressed as follows, and
their effect is visualized by Fig. 4.7.</p>

<code class='large'>q.next := p.next; p.next := q</code>
<br/><br/>

<img src="fig/4.7.png" width="750"/>
<p>Fig. 4.7. Insertion after <code>p^</code></p>

<p>If insertion before instead of after the designated element
<code>p^</code> is desired, the unidirectional link
chain seems to cause a problem, because it does not provide any
kind of path to an element's predecessors. However, a simple trick
solves our dilemma. It is illustrated in Fig. 4.8. Assume that the
key of the new element is 8.</p>
<code class='large'>NEW(q); q^ := p^; p.key := k; p.next := q</code>
<br/><br/>

<img src="fig/4.8.png" width="720"/>
<p>Fig. 4.8. Insertion before <code>p^</code>.</p>

<p>The trick evidently consists of actually inserting a new component
after <code>p^</code> and thereafter interchanging the
values of the new element and <code>p^</code>.</p>

<p>Next, we consider the process of <i>list deletion</i>. Deleting the
successor of a <code>p^</code> is straightforward. This
is shown here in combination with the reinsertion of the deleted
element at the head of another list (designated by <code>q</code>).
Figure 4.9 illustrates the situation and shows that
it constitutes a cyclic exchange of three pointers.</p>
<code class='large'>r := p.next; p.next := r.next; r.next := q; q := r</code>
<br/><br/>

<img src="fig/4.9.png" width="800"/>
<p>Fig. 4.9. Deletion and re-insertion</p>

<p>The removal of a designated element itself (instead of its
successor) is more difficult, because we encounter the same problem
as with insertion: tracing backward to the denoted element's
predecessor is impossible. But deleting the successor after moving
its value forward is a relatively obvious and simple solution. It
can be applied whenever <code>p^</code> has a successor,
i.e., is not the last element on the list. However, it must be
assured that there exist no other variables pointing to the now
deleted element.</p>

<p>We now turn to the fundamental operation of list traversal. Let us
assume that an operation <code>P(x)</code> has to be
performed for every element of the list whose first element is
<code>p^</code>. This task is expressible as
follows:</p>
<code class='large'>WHILE <i>list designated by p is not empty</i> DO
  <code class="pseudo">perform operation P; proceed to the successor</code>
END</code>

<p>In detail, this operation is described by the following
statement:</p>
<code class='large'>WHILE p # NIL DO
  P(p); p := p.next
END</code>

<p>It follows from the definitions of the while statement and of the
linking structure that <code>P</code> is applied to all
elements of the list and to no other ones.</p>

<p>A very frequent operation performed is list <i>searching</i> for an
element with a given key <code>x</code>. Unlike for
arrays, the search must here be purely sequential. The search
terminates either if an element is found or if the end of the list
is reached. This is reflected by a logical conjunction consisting
of two terms. Again, we assume that the head of the list is
designated by a pointer <code>p</code>.</p>

<code class='large'>WHILE (p # NIL) &amp; (p.key # x) DO p := p.next END</code>

<p><code>p = NIL</code> implies that <code>p^</code> does
not exist, and hence that the expression <code>p.key # x</code>
is undefined. The order of the two terms is therefore essential.</p>
</li>

<li data-list-text="4.3.2" id="4.3.2">
<h4><a href='#4.3.2'>Ordered Lists and Reorganizing Lists</a></h4>
<p>The given linear list search strongly resembles the search routines
for scanning an array or a sequence. In fact, a sequence is
precisely a linear list for which the technique of linkage to the
successor is left unspecified or implicit. Since the primitive
sequence operators do not allow insertion of new elements (except
at the end) or deletion (except removal of all elements), the
choice of representation is left wide open to the implementor, and
he may well use sequential allocation, leaving successive
components in contiguous storage areas. Linear lists with explicit
pointers provide more flexibility, and therefore they should be
used whenever this additional flexibility is needed.</p>

<p>To exemplify, we will now consider a problem that will occur
throughout this chapter in order to illustate alternative solutions
and techniques. It is the problem of reading a text, collecting all
its words, and counting the frequency of their occurrence. It is
called the construction of a <i>concordance</i> or the generation
of a <i>cross-reference list</i>.</p>

<p>An obvious solution is to construct a list of words found in the
text. The list is scanned for each word. If the word is found, its
frequency count is incremented; otherwise the word is added to the
list. We shall simply call this process search, although it may
actually also include an insertion. In order to be able to
concentrate our attention on the essential part of list handling,
we assume that the words have already been extracted from the text
under investigation, have been encoded as integers, and are
available in the from of an input sequence.</p>

<p>The formulation of the procedure called <code>search</code>
follows in a straightforward manner. The
variable <code>root</code> refers to the head of the
list in which new words are inserted accordingly. The complete
algorithm is listed below; it includes a routine for tabulating the
constructed cross-reference list. The tabulation process is an
example in which an action is executed once for each element of the
list.</p>

<code class='large'>TYPE Word = POINTER TO <span>(* ADenS432_List *)</span>
  RECORD key, count: INTEGER; next: Word END;

PROCEDURE search (x: INTEGER; VAR root: Word);
  VAR w: Word;
BEGIN
  w := root;
  WHILE (w # NIL) &amp; (w.key # x) DO
    w := w.next
  END; (* (w = NIL) OR (w.key = x) *)

  IF w = NIL THEN (*new entry*)
    w := root;
    NEW(root); root.key := x; root.count := 1; root.next := w
  ELSE
    INC(w.count)
  END
END search;

PROCEDURE PrintList (w: Word);
BEGIN (*uses global writer W*)
  WHILE w # NIL DO
    Texts.WriteInt(W, w.key, 8); Texts.WriteInt(W, w.count, 8);
    Texts.WriteLn(W);
    w := w.next
  END
END PrintList;</code>

<p>The linear scan algorithm resembles the search procedure for
arrays, and reminds us of a simple technique used to simplify the
loop termination condition: the use of a sentinel. A sentinel may
as well be used in list search; it is represented by a dummy
element at the end of the list. The new procedure is listed below.
We must assume that a global variable <code>sentinel</code>
is added and that the initialization of
<code>root := NIL</code> is replaced by the
statements</p>

<code>NEW(sentinel); root := sentinel</code>

<p>which generate the element to be used as sentinel.</p>
<code class='large'>PROCEDURE search (x: INTEGER; VAR root: Word); <span>(* ADenS432_List2 *)</span>
  VAR w: Word;
BEGIN
  w := root; sentinel.key := x;
  WHILE w.key # x DO w := w.next END;
  IF w = sentinel THEN (*new entry*)
    w := root;
    NEW(root); root.key := x; root.count := 1; root.next := w
  ELSE
    INC(w.count)
  END
END search</code>

<p>Obviously, the power and flexibility of the linked list are ill
used in this example, and the linear scan of the entire list can
only be accepted in cases in which the number of elements is
limited. An easy improvement, however, is readily at hand: the
ordered list search. If the list is ordered (say by increasing
keys), then the search may be terminated at the latest upon
encountering the first key that is larger than the new one.
Ordering of the list is achieved by inserting new elements at the
appropriate place instead of at the head. In effect, ordering is
practically obtained free of charge. This is because of the ease by
which insertion in a linked list is achieved, i.e., by making full
use of its flexibility. It is a possibility not provided by the
array and sequence structures. (Note, however, that even in ordered
lists no equivalent to the binary search of arrays is
available).</p>

<p>Ordered list search is a typical example of the situation, where an
element must be inserted <i>ahead</i> of a given item, here in
front of the first one whose key is too large. The technique shown
here, however, differs from the one used shown earlier. Instead of
copying values, two pointers are carried along in the list
traversal; <code>w2</code> lags one step behind
<code>w1</code> and thus identifies the proper insertion
place when <code>w1</code> has found too large a key.
The general insertion step is shown in Fig. 4.10. The pointer to
the new element (<code>w3</code>) is to be assigned to
<code>w2.next</code>, except when the list is still
empty. For reasons of simplicity and effectiveness, we prefer to
avoid this distinction by using a conditional statement. The only
way to avoid this is to introduce a dummy element at the list head.
The initializing statement <code>root := NIL</code> is
accordingly replaced by</p>
<code>NEW(root); root.next := NIL</code>
<br/><br/>

<img src="fig/4.10.png" width="700"/>
<p>Fig. 4.10. Insertion in ordered list</p>

<p>Referring to Fig. 4.10, we determine the condition under which the
scan continues to proceed to the next element; it consists of two
factors, namely,</p>
<code>(w1 # NIL) &amp; (w1.key &lt; x)</code>

<p>The resulting search procedure is:</p>
<code class='large'>PROCEDURE search (x: INTEGER; VAR root: Word); <span>(* ADenS432_List3 *)</span>
  VAR w1, w2, w3: Word;
BEGIN
  (*w2 # NIL*)
  w2 := root; w1 := w2.next;
  WHILE (w1 # NIL) &amp; (w1.key &lt; x) DO
    w2 := w1; w1 := w2.next
  END;
  (* (w1 = NIL) OR (w1.key &gt;= x) *)
  IF (w1 = NIL) OR (w1.key &gt; x) THEN (*new entry*)
    NEW(w3);
    w2.next := w3;
    w3.key := x; w3.count := 1; w3.next := w1
  ELSE
    INC(w1.count)
  END
END search</code>

<p>In order to speed up the search, the continuation condition of the
while statement can once again be simplified by using a sentinel.
This requires the initial presence of a dummy header as well as a
sentinel at the tail.</p>

<p>It is now high time to ask what gain can be expected from ordered
list search. Remembering that the additional complexity incurred is
small, one should not expect an overwhelming improvement.</p>

<p>Assume that all words in the text occur with equal frequency. In
this case the gain through lexicographical ordering is indeed also
nil, once all words are listed, because the position of a word does
not matter if only the total of all access steps is significant and
if all words have the same frequency of occurrence. However, a gain
is obtained whenever a new word is to be inserted. Instead of first
scanning the entire list, on the average only half the list is
scanned. Hence, ordered list insertion pays off only if a
concordance is to be generated with many distinct words compared to
their frequency of occurrence. The preceding examples are therefore
suitable primarily as programming exercises rather than for
practical applications.</p>

<p>The arrangement of data in a linked list is recommended when the
number of elements is relatively small (&lt; 50), varies, and,
moreover, when no information is given
about their frequencies of access. A typical example is the symbol
table in compilers of programming languages. Each declaration
causes the addition of a new symbol, and upon exit from its scope
of validity, it is deleted from the list. The use of simple linked
lists is appropriate for applications with relatively short
programs. Even in this case a considerable improvement in access
method can be achieved by a very simple technique which is
mentioned here again primarily because it constitutes a pretty
example for demonstrating the flexibilities of the linked list
structure.</p>

<p>A characteristic property of programs is that occurrences of the
same identifier are very often clustered, that is, one occurrence
is often followed by one or more reoccurrences of the same word.
This information is an invitation to reorganize the list after each
access by moving the word that was found to the top of the list,
thereby minimizing the length of the search path the next time it
is sought. This method of access is called <i>list search with
reordering</i>, or — somewhat pompously — <i>self-organizing
list</i> search. In presenting the corresponding algorithm in the
form of a procedure, we take advantage of our experience made so
far and introduce a sentinel right from the start. In fact, a
sentinel not only speeds up the search, but in this case it also
simplifies the program. The list must initially not be empty, but
contains the sentinel element already. The initialization
statements are</p>

<code>NEW(sentinel); root := sentinel</code>

<p>Note that the main difference between the new algorithm and the
straight list search is the action of reordering when an element
has been found. It is then detached or deleted from its old
position and inserted at the top. This deletion again requires the
use of two chasing pointers, such that the predecessor
<code>w2</code> of an identified element <code>w1</code>
is still locatable. This, in turn, calls for the special treatment
of the first element (i.e., the empty list). To conceive the
linking process, we refer to Fig. 4.11. It shows the two pointers
when <code>w1</code> was identified as the desired
element. The configuration after correct reordering is represented
in Fig. 4.12, and the complete new search procedure is listed
below.</p>

<img src="fig/4.11.png" width="700"/>
<p>Fig. 4.11. List before re-ordering</p>

<img src="fig/4.12.png" width="700"/>
<p>Fig. 4.12. List after re-ordering</p>

<code class='large'>PROCEDURE search (x: INTEGER; VAR root: Word); <span>(* ADenS432_List4 *)</span>
  VAR w1, w2: Word;
BEGIN
  w1 := root; sentinel.key := x;
  IF w1 = sentinel THEN (*first element*)
    NEW(root); root.key := x; root.count := 1; root.next := sentinel
  ELSIF w1.key = x THEN
    INC(w1.count)
  ELSE (*search*)
    REPEAT w2 := w1; w1 := w2.next UNTIL w1.key = x;
    IF w1 = sentinel THEN (*new entry*)
      w2 := root;
      NEW(root); root.key := x; root.count := 1; root.next := w2
    ELSE (*found, now reorder*)
      INC(w1.count);
      w2.next := w1.next; w1.next := root; root := w1
    END
  END
END search</code>

<p>The improvement in this search method strongly depends on the
degree of clustering in the input data. For a given factor of
clustering, the improvement will be more pronounced for large
lists. To provide an idea of how much gain can be expected, an
empirical measurement was made by applying the above
cross-reference program to a short and a relatively long text and
then comparing the methods of linear list ordering and of list
reorganization. The measured data are condensed into Table 4.2.
Unfortunately, the improvement is greatest when a different data
organization is needed anyway. We will return to this example in
Sect. 4.4.</p>

<div class='table'><table>
<tr>
<td></td>
<td>Test 1</td><td>Test 2</td></tr>
<tr>
<td>Number of distinct keys</td><td>53</td><td>582</td></tr>
<tr>
<td>Number of occurrences of keys</td><td>315</td><td>14341</td></tr>
<tr>
<td>Time for search with ordering</td><td>6207</td><td>3200622</td></tr>
<tr>
<td>Time for search with reordering</td><td>4529</td><td>681584</td></tr>
<tr>
<td>Improvement factor</td><td>1.37</td><td>4.70</td></tr>
<tr>
<td>Table 4.2. Comparsion of List Search Methods.</td>
<td></td><td></td>
</tr>
</table></div>

</li>

<li data-list-text="4.3.3" id="4.3.3">
<h4><a href='#4.3.3'>An Application: Partial Ordering (Topological Sorting)</a></h4>
<p>An appropriate example of the use of a flexible, dynamic data
structure is the process of topological sorting. This is a sorting
process of items over which a partial ordering is defined, i.e.,
where an ordering is given over some pairs of items but not between
all of them. The following are examples of partial orderings:</p>

<ol id="l71">
<li data-list-text="1.">
<p>In a dictionary or glossary, words are defined in
terms of other words. If a word <code>v</code>
is defined in terms of a word <code>w</code>, we denote this
by <code>v 〈 w</code>.
Topological sorting of the words in a dictionary means arranging
them in an order such that there will be no forward
references.</p>
</li>
<li data-list-text="2.">
<p>A task (e.g., an engineering project) is broken up
into subtasks. Completion of certain subtasks must usually precede
the execution of other subtasks. If a subtask <code>v</code>
must precede a subtask <code>w</code>, we
write <code>v 〈 w</code>.
Topological sorting means their arrangement in an order such that
upon initiation of each subtask all its prerequisite subtasks have
been completed.</p>
</li>
<li data-list-text="3.">
<p>In a university curriculum, certain courses must be
taken before others since they rely on the material presented in
their prerequisites. If a course <code>v</code> is a
prerequisite for course <code>w</code>,
we write <code>v 〈 w</code>. Topological sorting
means arranging the courses in such an order that no course lists a
later course as prerequisite.</p>
</li>

<li data-list-text="4.">
<p>In a program, some procedures may contain calls of
other procedures. If a procedure <code>v</code> is called
by a procedure <code>w</code>, we write <code>v 〈 w</code>.
Topological sorting implies the arrangement of
procedure declarations in such a way
that there are no forward references.</p>
</li>
</ol>

<p>In general, a partial ordering of a set <code>S</code>
is a relation between the elements of <code>S</code>. It
is denoted by the symbol "〈", verbalized
by <i>precedes</i>, and satisfies the following three properties
(axioms) for any distinct elements <code>x</code>,
<code>y</code>, <code>z</code> of <code>S</code>:</p>
<ol id="l72">
<li data-list-text="1.">
if <code>x 〈 y</code> and <code>y 〈 z</code>, then <code>x 〈 z</code> (transitivity)
</li>

<li data-list-text="2.">
if <code>x 〈 y</code>, then not <code>y 〈 x</code> (asymmetry)
</li>

<li data-list-text="3.">
not <code>z 〈 z</code> (irreflexivity)</p>
</li>
</ol>

<p>For evident reasons, we will assume that the sets
<code>S</code> to be topologically sorted by an algorithm are
finite. Hence, a partial ordering can be illustrated by drawing a
diagram or graph in which the vertices denote the elements of
<code>S</code> and the directed edges represent ordering
relationships. An example is shown in Fig. 4.13.</p>

<img src="fig/4.13.png" width="360"/>
<p>Fig. 4.13. Partially ordered set</p>

<p>The problem of topological sorting is to embed the partial order in
a linear order. Graphically, this implies the arrangement of the
vertices of the graph in a row, such that all arrows point to the
right, as shown in Fig. 4.14. Properties (1) and (2) of partial
orderings ensure that the graph contains no loops. This is exactly
the prerequisite condition under which such an embedding in a
linear order is possible.</p>

<img src="fig/4.14.png" width="600"/>
<p>Fig. 4.14. Linear arrangement of the partially ordered set of Fig. 4.13.</p>

<p>How do we proceed to find one of the possible linear orderings? The
recipe is quite simple. We start by choosing any item that is not
preceded by another item (there must be at least one; otherwise a
loop would exist). This object is placed at the head of the
resulting list and removed from the set <code>S</code>.
The remaining set is still partially ordered, and so the same
algorithm can be applied again until the set is empty.</p>

<p>In order to describe this algorithm more rigorously, we must settle
on a data structure and representation of <code>S</code>
and its ordering. The choice of this representation is determined
by the operations to be performed, particularly the operation of
selecting elements with zero predecessors. Every item should
therefore be represented by three characteristics: its
identification key, its set of successors, and a count of its
predecessors. Since the number <code>n</code> of
elements in <code>S</code> is not given a priori, the
set is conveniently organized as a linked list. Consequently, an
additional entry in the description of each item contains the link
to the next item in the list. We will assume that the keys are
integers (but not necessarily the consecutive integers from 1 to
<code>n</code>). Analogously, the set of each item's
successors is conveniently represented as a linked list. Each
element of the successor list is described by an identification and
a link to the next item on this list. If we call the descriptors of
the main list, in which each item of <code>S</code>
occurs exactly once, leaders, and the descriptors of elements on
the successor chains trailers, we obtain the following declarations
of data types:</p>
<code class='large'>TYPE Leader   =    POINTER TO LeaderDesc;
     Trailer  =    POINTER TO TrailerDesc;
     LeaderDesc =  RECORD key, count: INTEGER;
                     trail: Trailer; next: Leader
                   END;
     TrailerDesc = RECORD id: Leader; next: Trailer
                   END</code>

<p>Assume that the set <code>S</code> and its ordering
relations are initially represented as a sequence of pairs of keys
in the input file. The input data for the example in Fig. 4.13 are
shown below, in which the symbols 〈 are
added for the sake of clarity, symbolizing partial order:</p>
<code class='large'>1 〈 2  2 〈 4  4 〈 6  2 〈 10  4 〈 8  6 〈 3  1 〈 3
3 〈 5  5 〈 8  7 〈 5  7 〈 9   9 〈 4  9 〈 10</code>
<p>
The first part of the topological sort program must read the input
and transform the data into a list structure. This is performed by
successively reading a pair of keys <code>x</code> and
<code>y</code> (<code>x</code> <span class=
"s45">〈</span> <code>y</code>). Let us denote the
pointers to their representations on the linked list of leaders by
<code>p</code> and <code>q</code>. These
records must be located by a list search and, if not yet present,
be inserted in the list. This task is perfomed by a function
procedure called <code>find</code>. Subsequently, a new
entry is added in the list of trailers of <code>x</code>, along with
an identification of <code>q</code>; the count of predecessors of
<code>y</code> is incremented by 1. This algorithm is called
<i>input phase</i>. Figure 4.15 illustrates the data structure
generated during processing the given input data. The function
<code>find(w)</code> yields the pointer to the list
element with key <code>w</code>.</p>
<p>
In the following piece of program we make use of text scanning, a
feature of the Oberon system's text concept. Instead of considering
a text (file) as a sequence of characters, a text is considered as
a sequence of tokens, which are identifiers, numbers, strings, and
special characters (such as +, *, &lt;, etc. The procedure
<code>Texts.Scan(S)</code> scans the text, reading the
next token. The scanner <code>S</code> plays the role of
a text rider.</p>
<code class='large'>(*input phase*)
NEW(head); tail := head; Texts.Scan(S);
WHILE S.class = Texts.Int DO
  x := S.i; Texts.Scan(S); y := S.i; p := find(x); q := find(y);
  NEW(t); t.id := q; t.next := p.trail;
  p.trail := t; INC(q.count); Texts.Scan(S)
END
</code>
<br/><br/>

<img width="700" src="fig/4.15.png"/>
<p>Fig. 4.15. List structure generated by <code>TopSort</code> program</p>

<p>After the data structure of Fig. 4.15 has been constructed in this
input phase, the actual process of topological sorting can be taken
up as described above. But since it consists of repeatedly
selecting an element with a zero count of predecessors, it seems
sensible to first gather all such elements in a linked chain. Since
we note that the original chain of leaders will afterwards no
longer be needed, the same field called <code>next</code>
may be used again to link the zero predecessor
leaders. This operation of replacing one chain by another chain
occurs frequently in list processing. It is expressed in detail
here, and for reasons of convenience it constructs the new chain in
reverse order.</p>
<code class='large'>(*search for leaders without predecessors*)
p := head; head := NIL;
WHILE p # tail DO
  q := p; p := q.next;
  IF q.count = 0 THEN (*insert q^ in new chain*)
    q.next := head; head := q
  END
END
</code>

<p>Referring to Fig. 4.15, we see that the
<code>next</code> chain of leaders is replaced by the one of
Fig. 4.16 in which the pointers not depicted are left unchanged.</p>

<img src="fig/4.16.png" width="400"/>
<p>Fig. 4.16. List of Leaders with zero count</p>

<p>After all this preparatory establishing of a convenient
representation of the partially ordered set <code>S</code>,
we can finally proceed to the actual task of
topological sorting, i.e., of generating the output sequence. In a
first rough version it can be described as follows:</p>
<code class='large'>q := head;
WHILE q # NIL DO (*output this element, then delete it*)
  Texts.WriteInt(W, q.key, 8); DEC(n);
  t := q.trail; q := q.next;
  <code class="pseudo">decrement the predecessor count of all its successors on trailer list t;
  if any count becomes 0,
  insert this element in the leader list q</code>
END</code>

<p>The statement that is to be still further refined constitutes one
more scan of a list. In each step, the auxiliary variable
<code>p</code> designates the leader element whose count
has to be decremented and tested.</p>
<code class='large'>WHILE t # NIL DO
  p := t.id; DEC(p.count);
  IF p.count = 0 THEN (*insert p^ in leader list*)
    p.next := q; q := p
  END;
  t := t.next
END
</code>

<p>This completes the program for topological sorting. Note that a
counter <code>n</code> was introduced to count the
leaders generated in the input phase. This count is decremented
each time a leader element is output in the output phase. It should
therefore return to zero at the end of the program. Its failure to
return to zero is an indication that there are elements left in the
structure when none is without predecessor. In this case the set
<code>S</code> is evidently not partially ordered. The
output phase programmed above is an example of a process that
maintains a list that pulsates, i.e., in which elements are
inserted and removed in an unpredictable order. It is therefore an
example of a process which utilizes the full flexibility offered by
the explicitly linked list.</p>

<code class='large'>VAR head, tail: Leader; n: INTEGER; <span>(* ADenS433_TopSort *)</span>
PROCEDURE find (w: INTEGER): Leader;
  VAR h: Leader;
BEGIN
  h := head; tail.key := w; (*sentinel*)
  WHILE h.key # w DO h := h.next END;
  IF h = tail THEN
    NEW(tail); INC(n);
    h.count := 0; h.trail := NIL; h.next := tail
  END;
  RETURN h
END find;

PROCEDURE TopSort (VAR R: Texts.Reader);
  VAR p, q: Leader; t: Trailer; (*uses global writer W*)
    x, y: INTEGER;
BEGIN
  (*initialize list of leaders with a dummy acting as sentinel*)
  NEW(head); tail := head; n := 0;

  (*input phase*)
  Texts.Scan(S);
  WHILE S.class = Texts.Int DO
    x := S.i; Texts.Scan(S); y := S.i; p := find(x); q := find(y);
    NEW(t); t.id := q; t.next := p.trail;
    p.trail := t; INC(q.count); Texts.Scan(S)
  END;

  (*search for leaders without predecessors*)
  p := head; head := NIL;
  WHILE p # tail DO
    q := p; p := q.next;
    IF q.count = 0 THEN (*insert q in new chain*)
      q.next := head; head := q
    END
  END;

  (*output phase*) q := head;
  WHILE q # NIL DO
    Texts.WriteLn(W); Texts.WriteInt(W, q.key, 8); DEC(n);
    t := q.trail; q := q.next;
    WHILE t # NIL DO
      p := t.id; DEC(p.count);
      IF p.count = 0 THEN (*insert p in leader list*)
        p.next := q; q := p
      END;
      t := t.next
    END
  END;

  IF n # 0 THEN
    Texts.WriteString(W, "This set is not partially ordered")
  END;
  Texts.WriteLn(W)
END TopSort.
</code>

</li>
</ol>
</li>

<li data-list-text="4.4" id="4.4">
<h3><a href='#4.4'>Tree Structures</a></h3>
<ol class="page" id="l73">
<li data-list-text="4.4.1" id="4.4.1">
<h4><a href='#4.4.1'>Basic Concepts and Definitions</a></h4>

<p>We have seen that sequences and lists may conveniently be defined
in the following way: A sequence (list) with base type <code>T</code> is either</p>
<ol id="l74">
<li data-list-text="1.">
<p>The empty sequence (list).</p>
</li>
<li data-list-text="2.">
<p>The concatenation (chain) of a <code>T</code> and a
sequence with base type <code>T</code>.</p>
</li>
</ol>

<p>Hereby recursion is used as an aid in defining a structuring
principle, namely, sequencing or iteration. Sequences and
iterations are so common that they are usually considered as
fundamental patterns of structure and behaviour. But it should be
kept in mind that they can be defined in terms of recursion,
whereas the reverse is not true, for recursion may be effectively
and elegantly used to define much more sophisticated structures.
Trees are a well-known example. Let a tree structure be defined as
follows: A tree structure with base type <code>T</code>
is either</p>
<ol id="l75">
<li data-list-text="1.">
<p>The empty structure.</p>
</li>
<li data-list-text="2.">
<p>A node of type <code>T</code> with a finite number of
associated disjoint tree structures of base type <code>T</code>, called subtrees.</p>
</li>
</ol>
<p>From the similarity of the recursive definitions of sequences and
tree structures it is evident that the sequence (list) is a tree
structure in which each node has at most one subtree. The list is
therefore also called a degenerate tree.</p>

a) <img src="fig/4.17.a.png" width="550"/>

<p class="s24">b) (A(B(D(I),E(J,K,L)),C(F(O),G(M,N),H(P))))</p>

<p class="s24">c) <img src="fig/4.17.c.png" width="190"/></p>

<p class="s24">d) <img src="fig/4.17.d.png" width="700"/></p>

<p>Fig. 4.17. Representation of tree structure by (a) nested sets,
(b) nested parentheses, (c) indented text, and (d) graph</p>

<p></p>

<p>There are several ways to represent a tree structure. For example,
a tree structure with its base type <code>T</code>
ranging over the letters is shown in various ways in Fig. 4.17.
These representations all show the same structure and are therefore
equivalent. It is the graph structure that explicitly illustrates
the branching relationships which, for obvious reasons, led to the
generally used name tree. Strangely enough, it is customary to
depict trees upside down, or — if one prefers to express this fact
differently — to show the roots of trees. The latter formulation,
however, is misleading, since the top node (A) is commonly called
the root.</p>

<p>An ordered tree is a tree in which the branches of each node are
ordered. Hence the two ordered trees in Fig. 4.18 are distinct,
different objects. A node <code>y</code> that is
directly below node <code>x</code> is called a
(direct) <i>descendant</i> of <code>x</code>;
if <code>x</code> is at level <code>i</code>, then
<code>y</code> is said to be at level <code>i+1</code>.
Conversely, node <code>x</code> is said
to be the (direct) <i>ancestor</i> of y. The root of a tree is
defined to be at level 0. The maximum level of any element of a
tree is said to be its depth or <i>height</i>.</p>

<img src="fig/4.18.png" width="360"/>
<p>Fig. 4.18. Two distinct trees</p>

<p>If an element has no descendants, it is called a <i>terminal</i>
node or a <i>leaf</i>; and an element that is not terminal is an
interior node. The number of (direct) descendants of an interior
node is called its <i>degree</i>. The maximum degree over all nodes
is the degree of the tree. The number of branches or edges that
have to be traversed in order to proceed from the root to a node
<code>x</code> is called the <i>path length of</i>
<code>x</code>. The root has path length 0, its direct
descendants have path length 1, etc. In general, a node at level
<code>i</code> has path length <code>i</code>.
The path length of a tree is defined as the sum of
the path lengths of all its components. It is also called its
<i>internal path length</i>. The internal path length of the tree
shown in Fig. 4.17, for instance, is 36. Evidently, the average
path length is</p>

<code>P<sub>int</sub> = (<b>S</b>i: 1 ≤ i ≤ n: n <sub>i</sub> × i) / n</code>

<p>where <code>n</code> <sub>i</sub> is the number
of nodes at level <code>i</code>. In order to
define what is called the <i>external path length</i>, we extend
the tree by a special node wherever a subtree was missing in the
original tree. In doing so, we assume that all nodes are to have
the same degree, namely the degree of the tree. Extending the tree
in this way therefore amounts to filling up empty branches, whereby
the special nodes, of course, have no further descendants. The tree
of Fig. 4.17 extended with special nodes is shown in Fig. 4.19 in
which the special nodes are represented by squares. The external
path length is now defined as the sum of the path lengths over all
special nodes. If the number of special nodes at level
<code>i</code> is <code>m<sub>i</sub></code>,
then the average external path length is</p>

<code>P<sub>ext</sub> = (<b>S</b>i: 1 ≤ i ≤ m<sub>i</sub> × i) / m</code>

<p>In the tree shown in Fig. 4.19 the external path length is 120.</p>

<p>The number of special nodes <code>m</code>
to be added in a tree of degree <code>d</code>
directly depends on the number <code>n</code> of
original nodes. Note that every node has exactly one edge pointing
to it. Thus, there are <code>m+n</code> edges in the
extended tree. On the other hand, <code>d</code> edges
are emanating from each original node, none from the special nodes.
Therefore, there exist <code>d*n +1</code> edges, the 1
resulting from the edge pointing to the root. The two results yield
the following equation between the number <code>m</code>
of special nodes and <code>n</code> of original
nodes: <code>d × n +1 = m +n</code>, or </p>
<code>m = (d-1) × n + 1</code>
<p>The maximum number of nodes in a tree of a given height
<code>h</code> is reached if all nodes have <code>d</code>
subtrees, except those at level <code>h</code>,
all of which have none. For a tree of degree
<code>d</code>, level 0 then contains 1 node (namely,
the root), level 1 contains its <code>d</code>
descendants, level 2 contains the
<code>d<sup>2</sup></code> descendants of the
<code>d</code> nodes at level 2, etc. This yields</p>
<code>N<sub>d</sub>(h) = <b>S</b>i: 0 ≤ i &lt; h: d <sup>i</sup></code>
<p>as the maximum number of nodes for a tree with height
<code>h</code> and degree <code>d</code>. For
<code>d = 2</code>, we obtain</p>
<code>N<sub>2</sub>(h) = 2<sup>h</sup> - 1</code>
<p></p>

<img src="fig/4.19.png" width="700"/>
<p>Fig. 4.19. Ternary tree extended with special nodes</p>

<p>Of particular importance are the ordered trees of degree 2. They
are called <i>binary</i> trees. We define an ordered binary tree as
a finite set of elements (nodes) which either is empty or consists
of a root (node) with two disjoint binary trees called the
<i>left</i> and the <i>right subtree</i> of the root. In the
following sections we shall exclusively deal with binary trees, and
we therefore shall use the word tree to mean <i>ordered binary
tree</i>. Trees with degree greater than 2 are called <i>multiway
trees</i> and are discussed in sect. 4.7.1.</p>

<p>Familiar examples of binary trees are the family tree (pedigree)
with a person's father and mother as descendants (!), the history
of a tennis tournament with each game being a node denoted by its
winner and the two previous games of the combatants as its
descendants, or an arithmetic expression with dyadic operators,
with each operator denoting a branch node with its operands as
subtrees (see Fig. 4.20).</p>

<img src="fig/4.20.png" width="500"/>
<p>Fig. 4.20. Tree representation of expression <code>(a + b/c) * (d – e*f)</code></p>

<p>We now turn to the problem of representation of trees. It is plain
that the illustration of such recursive structures in terms of
branching structures immediately suggests the use of our pointer
facility. There is evidently no use in declaring variables with a
fixed tree structure; instead, we define the nodes as variables
with a fixed structure, i.e., of a fixed type, in which the degree
of the tree determines the number of pointer components referring
to the node's subtrees. Evidently, the reference to the empty tree
is denoted by <code>NIL</code>. Hence, the tree of Fig.
4.20 consists of components of a type defined as follows and may
then be constructed as shown in Fig. 4.21.</p>
<code class='large'>TYPE Node =  POINTER TO NodeDesc;
TYPE NodeDesc =  RECORD op: CHAR; left, right: Node END
</code>
<br/>

<img src="fig/4.21.png" width="750"/>
<p>Fig. 4.21. Tree of Fig. 4.21 represented as linked data structure</p>

<p>Before investigating how trees might be used advantageously and how
to perform operations on trees, we give an example of how a tree
may be constructed by a program. Assume that a tree is to be
generated containing nodes with the values of the nodes being
<code>n</code> numbers read from an input file. In order
to make the problem more challenging, let the task be the
construction of a tree with <code>n</code> nodes and
minimal height. In order to obtain a minimal height for a given
number of nodes, one has to allocate the maximum possible number of
nodes of all levels except the lowest one. This can clearly be
achieved by distributing incoming nodes equally to the left and
right at each node. This implies that we structure the tree for
given <code>n</code> as shown in Fig. 4.22, for
<code>n = 1, ... , 7</code>.</p>

<img src="fig/4.22.png" width="600"/>
<p>Fig. 4.22. Perfectly balanced trees</p>

<p>The rule of equal distribution under a known number
<code>n</code> of nodes is best formulated recursively:</p>
<ol id="l76">
<li data-list-text="1.">
<p>Use one node for the root.</p>
</li>
<li data-list-text="2.">
<p>Generate the left subtree with <code>nl = n DIV 2</code>
nodes in this way.</p>
</li>
<li data-list-text="3.">
<p>Generate the right subtree with <code>nr = n - nl - 1</code> nodes in this way.</p>
</li>
</ol>
<p>The rule is expressed as a recursive procedure which reads the
input file and constructs the perfectly balanced tree. We note the
following definition: A tree is perfectly balanced, if for each
node the numbers of nodes in its left and right subtrees differ by
at most 1.</p>

<code class='large'>TYPE Node = POINTER TO RECORD <span>(* ADenS441_BalancedTree *)</span>
    key: INTEGER; left, right: Node
  END;

VAR R: Texts.Reader; W: Texts.Writer; root: Node;

PROCEDURE tree (n: INTEGER): Node;
  VAR new: Node;
    x, nl, nr: INTEGER;
BEGIN (*construct perfectly balanced tree with n nodes*)
  IF n = 0 THEN new := NIL
  ELSE nl := n DIV 2; nr := n-nl-1;
    NEW(new); Texts.ReadInt(R, new.key);
    new.key := x; new.left := tree(nl); new.right := tree(nr)
  END;
  RETURN new
END tree;

PROCEDURE PrintTree (t: Node; h: INTEGER);
  VAR i: INTEGER;
BEGIN (*print tree t with indentation h*)
  IF t # NIL THEN
    PrintTree(t.left, h+1);
    FOR i := 1 TO h DO Texts.Write(W, TAB) END;
    Texts.WriteInt(W, t.key, 6); Texts.WriteLn(W); PrintTree(t.right, h+1)
  END
END PrintTree;
</code>

<p>Assume, for example, the following input data for a tree with 21
nodes:</p>
<code class='large'>8 9 11 15 19 20 21 7 3 2 1 5 6 4 13 14 10 12 17 16 18</code>
<p>The call <code>root := tree(21)</code> reads the input
dara while constructing the perfectly balanced tree shown in Fig.
4.23.</p>

<img src="fig/4.23.png" width="700"/>
<p>Fig. 4.23. Tree generated by preceding program</p>

<p>Note the simplicity and transparency of this program that is
obtained through the use of recursive procedures. It is obvious
that recursive algorithms are particularly suitable when a program
is to manipulate information whose structure is itself defined
recursively. This is again manifested in the procedure which
prints the resulting tree: The empty tree results in no printing,
the subtree at level <code>L</code> in first printing
its own left subtree, then the node, properly indented by preceding
it with <code>L</code> tabs, and finally in printing its
right subtree.</p>
</li>

<li data-list-text="4.4.2" id="4.4.2">
<h4><a href='#4.4.2'>Basic Operations on Binary Trees</a></h4>
<p>There are many tasks that may have to be perfomed on a tree
structure; a common one is that of executing a given operation
<code>P</code> on each element of the tree. <code>P</code>
is then understood to be a parameter of the more
general task of visting all nodes or, as it is usually called, of
tree traversal. If we consider the task as a single sequential
process, then the individual nodes are visited in some specific
order and may be considered as being laid out in a linear
arrangement. In fact, the description of many algorithms is
considerably facilitated if we can talk about processing the next
element in the tree based in an underlying order. There are three
principal orderings that emerge naturally from the structure of
trees. Like the tree structure itself, they are conveniently
expressed in recursive terms. Referring to the binary tree in Fig.
4.24 in which <code>R</code> denotes the root and
<code>A</code> and <code>B</code> denote the
left and right subtrees, the three orderings are</p>

<ol id="l77">
<li data-list-text="1.">
<p>Preorder: <code>               R, A, B</code> (visit root before the subtrees)</p>
</li>
<li data-list-text="2.">
<p>Inorder: <code>                A, R, B</code></p>
</li>
<li data-list-text="3.">
<p>Postorder: <code>              A, B, R</code> (visit root after the subtrees)</p>
</li>
</ol>

<img src="fig/4.24.png" width="160"/>
<p>Fig. 4.24. Binary tree</p>

<p>Traversing the tree of Fig. 4.20 and recording the characters seen
at the nodes in the sequence of encounter, we obtain the following
orderings:</p>
<div class='table'><table>
  <tr><td>1. Preorder:</td><td><code>                  </code></td><td><code>* + a / b c - d * e f</code></td></tr>
  <tr><td>2. Inorder:</td><td></td><td><code>a + b / c * d - e * f</code></td></tr>
  <tr><td>3. Postorder:</td><td></td><td><code>a b c / + d e f * - *</code></td></tr>
</table></div>

<p>We recognize the three forms of expressions: <i>preorder</i>
traversal of the expression tree yields <i>prefix</i> notation;
<i>postorder</i> traversal generates <i>postfix</i> notation; and
<i>inorder</i> traversal yields conventional <i>infix</i> notation,
although without the parentheses necessary to clarify operator
precedences.</p>

<p>Let us now formulate the three methods of traversal by three
concrete programs with the explicit parameter <code>t</code>
denoting the tree to be operated upon and with the
implicit parameter <code>P</code> denoting the operation
to be performed on each node. Assume the following definitions:</p>

<code class='large'>TYPE Node = POINTER TO RECORD ... left, right: Node END</code>

<p>The three methods are now readily formulated as recursive
procedures; they demonstrate again the fact that operations on
recursively defined data structures are most conveniently defined
as recursive algorithms.</p>

<code class='large'>PROCEDURE preorder (t: Node);
BEGIN
  IF t # NIL THEN
    P(t); preorder(t.left); preorder(t.right)
  END
END preorder

PROCEDURE inorder (t: Node);
BEGIN
  IF t # NIL THEN
    inorder(t.left); P(t); inorder(t.right)
  END
END inorder

PROCEDURE postorder (t: Node);
BEGIN
  IF t # NIL THEN
    postorder(t.left); postorder(t.right); P(t)
  END
END postorder
</code>

<p>Note that the pointer <code>t</code> is passed as a
value parameter. This expresses the fact that the relevant entity
is the reference to the considered subtree and not the variable
whose value is the pointer, and which could be changed in case
<code>t</code> were passed as a variable parameter.</p>

<p>An example of a tree traversal routine is that of printing a tree,
with appropriate indentation indicating each node's level.</p>

<p>Binary trees are frequently used to represent a set of data whose
elements are to be retrievable through a unique key. If a tree is
organized in such a way that for each node <code>t<sub>i</sub></code>,
all keys in the left subtree of <code>t<sub>i</sub></code> are
less than the key of <code>t<sub>i</sub></code>, and those in
the right subtree are greater than the
key of <code>t<sub>i</sub></code>, then
this tree is called a search tree. In a search tree it is possible
to locate an arbitrary key by starting at the root and proceeding
along a search path switching to a node's left or right subtree by
a decision based on inspection of that node's key only. As we have
seen, <code>n</code> elements may be organized in a
binary tree of a height as little as <code>log(n)</code>.
Therefore, a search among <code>n</code> items may be performed
with as few as <code>log(n)</code> comparsions if the tree is perfectly balanced.
Obviously, the tree is a much more suitable form for organizing
such a set of data than the linear list used in the previous
section. As this search follows a single path from the root to the
desired node, it can readily be programmed by iteration:</p>
<code class='large'>PROCEDURE locate (x: INTEGER; t: Node): Node;
BEGIN
  WHILE (t # NIL) &amp; (t.key # x) DO
    IF t.key &lt; x THEN t := t.right ELSE t := t.left END
  END;
  RETURN t
END locate
</code>

<p>The function <code>locate(x, t)</code> yields the value
<code>NIL</code>, if no key with value
<code>x</code> is found in the tree with root <code>t</code>.
As in the case of searching a list, the complexity
of the termination condition suggests that a better solution may
exist, namely the use of a sentinel. This technique is equally
applicable in the case of a tree. The use of pointers makes it
possible for all branches of the tree to terminate with the same
sentinel. The resulting structure is no longer a tree, but rather a
tree with all leaves tied down by strings to a single anchor
point (Fig. 4.25). The sentinel may be considered as a common, shared
representative of all external nodes by which the original tree was
extended (see Fig. 4.19):</p>
<code class='large'>PROCEDURE locate (x: INTEGER; t: Node): Node;
BEGIN
  s.key := x; (*sentinel*)
  WHILE t.key # x DO
    IF t.key &lt; x THEN t := t.right ELSE t := t.left END
  END;
  RETURN t
END locate
</code>

<p>Note that in this case <code>locate(x, t)</code> yields
the value <code>s</code> instead of <code>NIL</code>,
i.e., the pointer to the sentinel, if no key with
value <code>x</code> is found in the tree with root
<code>t</code>.</p>

<img src="fig/4.25.png" width="700"/>
<p>Fig. 4.25. Search tree with sentinel</p>

</li>

<li data-list-text="4.4.3" id="4.4.3">
<h4><a href='#4.4.3'>Tree Search and Insertion</a></h4>

<p>The full power of the dynamic allocation technique with access
through pointers is hardly displayed by those examples in which a
given set of data is built, and thereafter kept unchanged. More
suitable examples are those applications in which the structure of
the tree itself varies, i.e., grows and/or shrinks during the
execution of the program. This is also the case in which other data
representations, such as the array, fail and in which the tree with
elements linked by pointers emerges as the most appropriate
solution.</p>

<p>We shall first consider only the case of a steadily growing but
never shrinking tree. A typical example is the concordance problem
which was already investigated in connection with linked lists. It
is now to be revisited. In this problem a sequence of words is
given, and the number of occurrences of each word has to be
determined. This means that, starting with an empty tree, each word
is searched in the tree. If it is found, its occurrence count is
incremented; otherwise it is inserted as a new word (with a count
initialized to 1). We call the underlying task <i>tree search with
insertion</i>. The following data type definitions are assumed:</p>

<code class='large'>TYPE Node = POINTER TO RECORD
              key, count: INTEGER;
              left, right: Node
            END
</code>

<p>Finding the search path is again straightforward. However, if it
leads to a dead end (i.e., to an empty subtree designated by a
pointer value <code>NIL</code>), then the given word
must be inserted in the tree at the place of
the empty subtree. Consider, for example, the binary tree shown in
Fig. 4.26 and the insertion of the name</p>

<img src="fig/4.26.png" width="700"/>
<p>Fig. 4.26. Insertion in ordered binary tree</p>

<p>The search process is formulated as a recursive procedure. Note
that its parameter <code>p</code> is a variable
parameter and not a value parameter. This is essential because in
the case of insertion a new pointer value must be assigned to the
variable which previously held the value <code>NIL</code>.
Using the input sequence of 21 numbers that had
been used above to construct the tree of Fig. 4.23, the search and
insertion procedure yields the binary tree shown in Fig. 4.27, with
a call <code>search(k, root)</code> for each key
<code>k</code>, where <code>root</code> is a
variable of type <code>Node</code>.</p>

<img src="fig/4.27.png" width="700"/>
<p>Fig. 4.27. Search tree generated by preceding program</p>

<code class='large'>PROCEDURE PrintTree (t: Node; h: INTEGER); <span>(* ADenS443_Tree *)</span>
  VAR i: INTEGER;
BEGIN (*print tree t with indentation h*)
  IF t # NIL THEN
    PrintTree(t.left, h+1);
    FOR i := 1 TO h DO Texts.Write(W, TAB) END;
    Texts.WriteInt(W, t.key, 6); Texts.WriteLn(W); PrintTree(t.right, h+1)
  END
END PrintTree;

PROCEDURE search (x: INTEGER; VAR p: Node);
BEGIN
  IF p = NIL THEN (*x not in tree; insert*)
    NEW(p); p.key := x; p.count := 1; p.left := NIL; p.right := NIL
  ELSIF x &lt; p.key THEN search(x, p.left)
  ELSIF x &gt; p.key THEN search(x, p.right)
  ELSE INC(p.count)
  END
END search
</code>

<p>The use of a sentinel again simplifies the task somewhat. Clearly,
at the start of the program the variable <code>root</code>
must be initialized by the pointer to the sentinel
instead of the value <code>NIL</code>, and before each
search the specified value <code>x</code> must be
assigned to the <code>key</code> field of the
sentinel.</p>
<code class='large'>PROCEDURE search (x: INTEGER; VAR p: Node);
BEGIN
  IF x &lt; p.key THEN search(x, p.left)
  ELSIF x &gt; p.key THEN search(x, p.right)
  ELSIF p # s THEN INC(p.count)
  ELSE (*insert*)
    NEW(p); p.key := x; p.left := s; p.right := s; p.count := 1
  END
END search
</code>

<p>Although the purpose of this algorithm is searching, it can be used
for sorting as well. In fact, it resembles the sorting by insertion
method quite strongly, and because of the use of a tree structure
instead of an array, the need for relocation of the components
above the insertion point vanishes. Tree sorting can be programmed
to be almost as efficient as the best array sorting methods known.
But a few precautions must be taken. After encountering a match,
the new element must also be inserted.
If the case <code>x = p.key</code> is handled identically to the case
<code>x &gt; p.key</code>, then the algorithm represents
a stable sorting method, i.e., items with identical keys turn up in
the same sequence when scanning the tree in normal order as when
they were inserted.</p>

<p>In general, there are better ways to sort, but in applications in
which searching and sorting are both needed, the tree search and
insertion algorithm is strongly recommended. It is, in fact, very
often applied in compilers and in data banks to organize the
objects to be stored and retrieved. An appropriate example is the
construction of a cross-reference index for a given text, an
example that we had already used to illustrate list generation.</p>

<p>Our task is to construct a program that (while reading a text and
printing it after supplying consecutive line numbers) collects all
words of this text, thereby retaining the numbers of the lines in
which each word occurred. When this scan is terminated, a table is
to be generated containing all collected words in alphabetical
order with lists of their occurrences.</p>

<p>Obviously, the search tree (also called a <i>lexicographic
tree</i>) is a most suitable candidate for representing the words
encountered in the text. Each node now not only contains a word as
key value, but it is also the head of a list of line numbers. We
shall call each recording of an occurrence an item. Hence, we
encounter both trees and linear lists in this example. The program
consists of two main parts, namely, the scanning phase and the
table printing phase. The latter is a straightforward application
of a tree traversal routine in which visiting each node implies the
printing of the key value (word) and the scanning of its associated
list of line numbers (items). The following are further
clarifications regarding the program listed below. Table 4.3 shows
the results of processing the text of the preceding procedure
<code>search</code>.</p>

<ol class="noindent" id="l79">
<li data-list-text="1.">
<p>A word is considered as any sequence of letters and digits starting
with a letter.</p>
</li>
<li data-list-text="2.">
<p>Since words may be of widely different lengths, the actual
characters are stored in an array buffer, and the tree nodes
contain the index of the key's first character.</p>
</li>
<li data-list-text="3.">
<p>It is desirable that the line numbers be printed in ascending order
in the cross-reference index.</p>
</li>
</ol>

<p>Therefore, the item lists must be generated in the same order as
they are scanned upon printing. This requirement suggests the use
of two pointers in each word node, one referring to the first, and
one referring to the last item on the list. We assume the existence
of global writer <code>W</code>, and a variable
representing the current line number in the text.</p>

<code class='large'>CONST WordLen = 32; <span>(* ADenS443_CrossRef *)</span>
TYPE Word = ARRAY WordLen OF CHAR;

  Item = POINTER TO RECORD
    lno: INTEGER; next: Item
  END;
  Node = POINTER TO RECORD
    key: Word;
    first, last: Item; (*list*)
    left, right: Node (*tree*)
  END;

VAR line: INTEGER;

PROCEDURE search (VAR w: Node; VAR a: Word);
  VAR q: Item;
BEGIN
  IF w = NIL THEN (*word not in tree; new entry, insert*)
    NEW(w); NEW(q); q.lno := line;
    COPY(a, w.key); w.first := q; w.last := q; w.left := NIL; w.right := NIL
  ELSIF w.key &lt; a THEN search(w.right, a)
  ELSIF w.key &gt; a THEN search(w.left, a)
  ELSE (*old entry*)
    NEW(q); q.lno := line; w.last.next := q; w.last := q
  END
END search;

PROCEDURE Tabulate (w: Node);
  VAR m: INTEGER; item: Item;
BEGIN
  IF w # NIL THEN
    Tabulate(w.left);
    Texts.WriteString(W, w.key); Texts.Write(W, TAB); item := w.first; m := 0;
    REPEAT
      IF m = 10 THEN
        Texts.WriteLn(W); Texts.Write(W, TAB); m := 0
      END;
      INC(m); Texts.WriteInt(W, item.lno, 6); item := item.next
    UNTIL item = NIL;
    Texts.WriteLn(W); Tabulate(w.right)
  END
END Tabulate;

PROCEDURE CrossRef (VAR R: Texts.Reader);
  VAR root: Node; (*uses global writer W*)
    i: INTEGER; ch: CHAR; w: Word;
BEGIN
  root := NIL; line := 0;
  Texts.WriteInt(W, 0, 6); Texts.Write(W, TAB); Texts.Read(R, ch);
  WHILE ~R.eot DO
    IF ch = 0DX THEN (*line end*) Texts.WriteLn(W); INC(line);
      Texts.WriteInt(W, line, 6); Texts.Write(W, 9X); Texts.Read(R, ch)
    ELSIF ("A" &lt;= ch) &amp; (ch &lt;= "Z") OR ("a" &lt;= ch) &amp; (ch &lt;= "z") THEN
      i := 0;
      REPEAT
        IF i &lt; WordLen-1 THEN w[i] := ch; INC(i) END;
        Texts.Write(W, ch); Texts.Read(R, ch)
      UNTIL (i = WordLen-1) OR ~(("A" &lt;= ch) &amp; (ch &lt;= "Z")) &amp;
        ~(("a" &lt;= ch) &amp; (ch &lt;= "z")) &amp; ~(("0" &lt;= ch) &amp;
        (ch &lt;= "9"));
      w[i] := 0X; (*string terminator*)
      search(root, w)
    ELSE
      Texts.Write(W, ch); Texts.Read(R, ch)
    END;
  END;
  Texts.WriteLn(W); Texts.WriteLn(W); Tabulate(root)
END CrossRef;
</code>
<br/>

<div class='table'>
<ol id="l80">
<li data-list-text="0"><code>PROCEDURE search (x: INTEGER; VAR p: Node);</code></li>
<li data-list-text="1"><code>BEGIN</code></li>
<li data-list-text="2"><code>  IF x &lt; p.key THEN search(x, p.left)</code></li>
<li data-list-text="3"><code>  ELSIF x &gt; p^key THEN search(x, p.right)</code></li>
<li data-list-text="4"><code>  ELSIF p # s THEN INC(p.count)</code></li>
<li data-list-text="5"><code>  ELSE (*insert*) NEW(p);</code></li>
<li data-list-text="6"><code>    p.key := x; p.left := s; p.right := s; p.count := 1</code></li>
<li data-list-text="7"><code>  END</code></li>
<li data-list-text="8"><code>END</code></li>
</ol></div>

<br/>

<div class='table'><table>
<caption>Table 4.3. Sample output of cross reference generator</caption>
<tr><td>BEGIN</td><td>1</td></tr>
<tr><td>ELSE</td><td>5</td></tr>
<tr><td>ELSIF</td><td>3</td><td>4</td><td></td><td></td></tr>
<tr><td>END</td><td>7</td><td>8</td><td></td></tr>
<tr><td>IF</td><td>2</td><td></td><td></td></tr>
<tr><td>INC</td><td>4</td><td></td><td></td></tr>
<tr><td>INTEGER</td><td>0</td><td></td><td></td></tr>
<tr><td>NEW</td><td>5</td><td></td><td></td></tr>
<tr><td>Node</td><td>0</td><td></td><td></td></tr>
<tr><td>PROCEDURE</td><td>0</td><td></td><td></td></tr>
<tr><td>THEN</td><td>2</td><td>3</td><td>4</td></tr>
<tr><td>VAR</td><td>0</td><td></td><td></td></tr>
<tr><td>count</td><td>4</td><td>6</td><td></td></tr>
<tr><td>insert</td><td>5</td><td></td><td></td></tr>
<tr><td>key</td><td>2</td><td>3</td><td>6</td></tr>
<tr><td>left</td><td>2</td><td>6</td><td></td></tr>
<tr><td>p</td><td>0</td><td>2</td><td>2</td><td>3</td><td>3</td><td>4</td><td>4</td><td>5</td><td>6</td><td>6</td><td>6</td><td>6</td></tr>
<tr><td>right</td><td>3</td><td>6 </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>s</td><td>4</td><td>6</td><td>6</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>search</td><td>0</td><td>2</td><td>3</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>x</td><td>0</td><td>2</td><td>2</td><td>3</td><td>3</td><td>6</td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
</table></div>

</li>
<li data-list-text="4.4.4" id="4.4.4">
<h4><a href='#4.4.4'>Tree Deletion</a></h4>

<p>We now turn to the inverse problem of insertion: deletion. Our task
is to define an algorithm for deleting, i.e., removing the node
with key <code>x</code> in a tree with ordered keys.
Unfortunately, removal of an element is not generally as simple as
insertion. It is straightforward if the element to be deleted is a
terminal node or one with a single descendant. The difficulty lies
in removing an element with two descendants, for we cannot point in
two directions with a single pointer. In this situation, the
deleted element is to be replaced by either the rightmost element
of its left subtree or by the leftmost node of its right subtree,
both of which have at most one descendant. The details are shown in
the recursive procedure <code>delete</code>.
This procedure distinguishes among three cases:</p>

<ol id="l81">
<li data-list-text="1.">
<p>There is no component with a key equal to <code>x</code>.</p>
</li>
<li data-list-text="2.">
<p>The component with key <code>x</code> has at most one
descendant.</p>
</li>
<li data-list-text="3.">
<p>The component with key <code>x</code> has two descendants.</p>
</li>
</ol>

<code class='large'>PROCEDURE delete (x: INTEGER; VAR p: Node); <span>(* ADenS444_Deletion *)</span>

  PROCEDURE del (VAR r: Node);
  BEGIN
    IF r.right # NIL THEN del(r.right)
    ELSE p.key := r.key; p.count := r.count; r := r.left
    END
  END del;

BEGIN (*delete*)
  IF p = NIL THEN (*word is not in tree*)
  ELSIF x &lt; p.key THEN delete(x, p.left)
  ELSIF x &gt; p.key THEN delete(x, p.right)
  ELSE (*delete p^:*)
    IF p.right = NIL THEN p := p.left
    ELSIF p.left = NIL THEN p := p.right
    ELSE del(p.left)
    END
  END
END delete
</code>

<p>The auxiliary, recursive procedure <code>del</code> is
activated in case 3 only. It descends along the rightmost branch of
the left subtree of the element <code>p^</code> to be
deleted, and then it replaces the relevant information (key and
count) in <code>p^</code> by the corresponding values of
the rightmost component <code>r^</code> of that left
subtree, whereafter <code>r^</code> may be disposed.</p>

<p>We note that we do not mention a procedure that would be the
inverse of <code>NEW</code>, indicating that storage is
no longer needed and therefore disposable and reusable. It is
generally assumed that a computer system recognizes a disposable
variable through the circumstance that no other variables are
pointing to it, and that it therefore can no longer be referenced.
Such a system is called a <i>garbage collector</i>. It is not a
feature of a programming language, but rather of its
implementations.</p>

<p>In order to illustrate the functioning of procedure
<code>delete</code>, we refer to Fig. 4.28. Consider the tree (a);
then delete successively the nodes with keys 13, 15, 5, 10. The
resulting trees are shown in Fig. 4.28 (be).</p>

<img src="fig/4.28.png" width="600"/>
<p>Fig. 4.28. Tree deletion</p>

</li>
<li data-list-text="4.4.5" id="4.4.5">
<h4><a href='#4.4.5'>Analysis of Tree Search and Insertion</a></h4>
<p>It is a natural reaction to be suspicious of the algorithm of tree
search and insertion. At least one should retain some skepticism
until having been given a few more details about its behaviour.
What worries many programmers at first is the peculiar fact that
generally we do not know how the tree will grow; we have no idea
about the shape that it will assume. We can only guess that it will
most probably not be the perfectly balanced tree. Since the average
number of comparisons needed to locate a key in a perfectly
balanced tree with <code>n</code> nodes is approximately
<code>log(n)</code>, the number of comparisons in a tree
generated by this algorithm will be greater. But how much
greater?</p>

<p>First of all, it is easy to find the worst case. Assume that all
keys arrive in already strictly ascending (or descending) order.
Then each key is appended immediately to the right (left) of its
predecessor, and the resulting tree becomes completely degenerate,
i.e., it turns out to be a linear list. The average search effort
is then <code>n/2</code> comparisons. This worst case
evidently leads to a very poor performance of the search algorithm,
and it seems to fully justify our skepticism. The remaining
question is, of course, how likely this case will be. More
precisely, we should like to know the length
<code>a<sub>n</sub></code> of the search path averaged
over all <code>n</code> keys and averaged over all
<code>n!</code> trees that are generated from the
<code>n!</code> permutations of the original
<code>n</code> distinct keys. This problem of
algorithmic analysis turns out to be fairly straightforward, and it
is presented here as a typical example of analyzing an algorithm as
well as for the practical importance of its result.</p>

<p>Given are <code>n</code> distinct keys
with values <code>1, 2, ... , n</code>. Assume that they
arrive in a random order. The probability of the first key — which
notably becomes the root node — having the value <code>i</code>
is <code>1/n</code>. Its left subtree
will eventually contain <code>i-1</code> nodes,
and its right subtree <code>n-i</code> nodes (see Fig. 4.29). Let the
average path length in the left subtree be denoted by
<code>a<sub>i-1</sub></code>, and the one in the
right subtree is <code>a<sub>n-i</sub></code>,
again assuming that all possible permutations of the
remaining <code>n-1</code> keys
are equally likely. The average path length in a tree with <code>n</code>
nodes is the sum of the products of each node's
level and its probability of access. If all nodes are assumed to be
searched with equal likelihood, then</p>
<code>a<sub>n</sub> = (<b>S</b>i: 1 ≤ i ≤ n: p<sub>i</sub>) / n</code>
<p>where <code>p<sub>i</sub></code> is the
path length of node <code>i</code>.</p>

<img src="fig/4.29.png" width="160"/>
<p>Fig. 4.29. Weight distribution of branches</p>

<p>In the tree in Fig. 4.29 we divide the nodes into three
classes:</p>
<ol id="l82">
  <li data-list-text="1.">
  <p>The <code>i-1</code> nodes in the left subtree have an
  average path length <code>a<sub>i-1</sub></code>.</p>
  </li>
  <li data-list-text="2.">
  <p>The root has a path length of 0.</p>
  </li>
  <li data-list-text="3.">
  <p>The <code>n-i</code> nodes in the right subtree have an
  average path length <code>a<sub>n-i</sub></code>. </p>
  </li>
</ol>

<p>Hence, the equation above can be expressed as a
  sum of two terms 1) and 3)</p>
<code class='large'>a<sub>n</sub><sup>(i)</sup> = ((i-1) * a<sub>i-1</sub> + (n-i) * a<sub>n-i</sub>) / n</code>
<p>The desired quantity <code>a<sub>n</sub></code>
is the average of <code>a<sub>n(i)</sub></code>
over all <code>i = 1 ... n</code>, i.e., over all trees
with the key <code>1, 2, ..., n</code>
at the root.</p>
<code class='large'>a<sub>n</sub>  = (<b>S</b>i: 1 ≤ i ≤ n: (i-1) a<sub>i-1</sub> + (n-i) a<sub>n-i</sub>) / n<sup>2</sup>
    = 2 * (<b>S</b>i: 1 ≤ i ≤ n: (i-1) a<sub>i-1</sub>) / n<sup>2</sup>
    = 2 * (<b>S</b>i: 1 ≤ i &lt; n: i * a<sub>i</sub>) / n<sup>2</sup>
</code>

<p>This equation is a recurrence relation of the form
<code class='large'>a<sub>n</sub> =f<sub>1</sub>(a<sub>1</sub>, a<sub>2</sub>, ... , a<sub>n-1</sub>)</code>.
From this we derive a simpler recurrence relation of the
form <code>a<sub>n</sub> = f<sub>2</sub>(a<sub>n-1</sub>)</code>. We
derive directly (1) by splitting off the last term, and (2) by
substituting <code>n-1</code> for <code>n</code>:</p>
<ol id="l83">
  <li data-list-text="(1)">
  <code class='large'>a<sub>n</sub> = 2*(n-1) * a<sub>n-1</sub> /n<sup>2</sup> + 2 * (<b>S</b>i: 1 ≤ i &lt; n-1: i * a<sub>i</sub>) / n<sup>2</sup></code>
  </li>
  <li data-list-text="(2)">
  <code class='large'>a<sub>n-1</sub> = 2 * (<b>S</b>i: 1 ≤ i &lt; n-1: i * a<sub>i</sub>) / (n-1)<sup>2</sup></code>
  <p>Multiplying (2) by <code>n-1)<sup>2</sup>/n<sup>2</sup></code> yields</p>
  </li>
  <li data-list-text="(3)">
  <code class='large'>2 * (<b>S</b>i: 1 ≤ i &lt; n-1: i * a<sub>i</sub>) / n<sup>2</sup> = a<sub>n-1</sub> * (n-1)<sup>2</sup>/n<sup>2</sup></code>
  </li>
</ol>

<p>and substituting the right part of (3) in (1), we find</p>
<code class='large'>a<sub>n</sub> = 2 * (n-1) * a<sub>n-1</sub> / n<sup>2</sup> + a<sub>n-1</sub> * (n-1)<sup>2</sup> / n<sup>2</sup> = a<sub>n-1</sub> * (n-1)<sup>2</sup> / n<sup>2</sup></code>

<p>It turns out that <code>a<sub>n</sub></code>
can be expressed in non-recursive, closed form in
terms of the harmonic sum</p>
<code class='large'>H<sub>n</sub> = 1 + 1/2 + 1/3 + … + 1/n a<sub>n</sub> = 2 * (H<sub>n</sub> * (n+1)/n – 1)</code>
<p>From Euler's formula (using Euler's constant <code>g = 0.577...</code>),</p>
<code>H<sub>n</sub> = g + ln n + 1/12n<sup>2</sup> + ...</code>
<p>we derive, for large <code>n</code>, the approximate value</p>
<code>a<sub>n</sub> = 2 * (ln n + g - 1)</code>
<p>Since the average path length in the perfectly balanced tree is
approximately</p>
<code>a<sub>n</sub>' = log n - 1</code>
<p>we obtain, neglecting the constant terms which
become insignificant for large <code>n</code>,</p>
<code class='large'>lim(a<sub>n</sub>/a<sub>n</sub>’) = 2 * ln(n) / log(n) = 2 ln(2) = 1.386...</code>

<p>What does this result teach us? It tells us that by taking the
pains of always constructing a perfectly balanced tree instead of
the random tree, we could - always provided that all keys are
looked up with equal probability - expect an average improvement in the search
path length of at most 39%. Emphasis is to be put on the word
average, for the improvement may of course be very much greater in
the unhappy case in which the generated tree had completely
degenerated into a list, which, however, is very unlikely to occur.
In this connection it is noteworthy that the expected average path
length of the random tree grows also strictly logarithmically with
the number of its nodes, even though the worst case path length
grows linearly.</p>

<p>The figure of 39% imposes a limit on the amount of additional
effort that may be spent profitably on any kind of reorganization
of the tree's structure upon insertion of keys. Naturally, the
ratio between the frequencies of access (retrieval) of nodes
(information) and of insertion (update) significantly influences
the payoff limits of any such undertaking. The higher this ratio,
the higher is the payoff of a reorganization procedure. The 39%
figure is low enough that in most applications improvements of the
straight tree insertion algorithm do not pay off unless the number
of nodes and the access vs. insertion ratio are large.</p>

</li>
</ol>

</li>

<li data-list-text="4.5" id="4.5">
<h3><a href='#4.5'>Balanced Trees</a></h3>
<p>From the preceding discussion it is clear that an insertion
procedure that always restores the trees' structure to perfect
balance has hardly any chance of being profitable, because the
restoration of perfect balance after a random insertion is a fairly
intricate operation. Possible improvements lie in the formulation
of less strict definitions of balance. Such imperfect balance
criteria should lead to simpler tree reorganization procedures at
the cost of only a slight deterioration of average search
performance. One such definition of balance has been postulated by
Adelson-Velskii and Landis [4-1]. The balance criterion is the
following:</p>

<p>A tree is <i>balanced</i> if and only if for every node the heights
of its two subtrees differ by at most 1.</p>

<p>Trees satisfying this condition are often called AVL-trees (after
their inventors). We shall simply call them balanced trees because
this balance criterion appears a most suitable one. (Note that all
perfectly balanced trees are also AVL-balanced.)</p>

<p>The definition is not only simple, but it also leads to a
manageable rebalancing procedure and an average search path length
practically identical to that of the perfectly balanced tree. The
following operations can be performed on balanced trees in
<code>O(log n)</code> units of time, even in the worst
case:</p>

<ol id="l84">
<li data-list-text="1.">
<p>Locate a node with a given key.</p>
</li>
<li data-list-text="2.">
<p>Insert a node with a given key.</p>
</li>
<li data-list-text="3.">
<p>Delete the node with a given key.</p>
</li>
</ol>

<p>These statements are direct consequences of a
theorem proved by Adelson-Velskii and Landis, which guarantees that
a balanced tree will never be more than 45% higher than its
perfectly balanced counterpart, no matter how many nodes there are.
If we denote the height of a balanced tree with <code>n</code>
nodes by <code>h<sub>b</sub>(n)</code>, then</p>
<code class='large'>log(n+1) &lt; h<sub>b</sub>(n) &lt; 1.4404*log(n+2) - 0.328</code>
<p>The optimum is of course reached if the tree is
perfectly balanced for <code>n = 2k-1</code>. But which
is the structure of the worst AVL-balanced tree? In order to find
the maximum height <code>h</code> of all balanced trees
with <code>n</code> nodes, let us consider a fixed
height <code>h</code> and try to construct the balanced
tree with the minimum number of nodes. This strategy is recommended
because, as in the case of the minimal height, the value can be
attained only for certain specific values of <code>n</code>.
Let this tree of height <code>h</code> be denoted
by <code>T<sub>h</sub></code>.
Clearly, <code>T<sub>0</sub></code> is the
empty tree, and <code>T<sub>1</sub></code>
is the tree with a single node. In order to construct the
tree <code>T<sub>h</sub></code> for
<code>h &gt; 1</code>, we will provide the root with two
subtrees which again have a minimal number of nodes. Hence, the
subtrees are also <code>T</code>. Evidently, one subtree
must have height <code>h-1</code><span class="p">, and the other is then
allowed to have a height of one less, i.e.</span> h-2<span class=
"p">. Figure 4.30 shows the trees with height 2, 3, and 4. Since
their composition principle very strongly resembles
that of Fibonacci numbers, they are called
<i>Fibonacci-trees</i> (see Fig. 4.30). They are defined as
follows:</p>
<ol id="l85">
<li data-list-text="1.">
<p>The empty tree is the Fibonacci-tree of height 0.</p>
</li>
<li data-list-text="2.">
<p>A single node is the Fibonacci-tree of height 1.</p>
</li>
<li data-list-text="3.">
<p>If <code>T<sub>h-1</sub></code>
and <code>T<sub>h-2</sub></code>
are Fibonacci-trees of heights <code>h-1</code>
and <code>h-2</code>, then
<code class='large'>T<sub>h</sub> = &lt;T<sub>h-1</sub>, x, T<sub>h-2</sub></code>&gt;
is a Fibonacci-tree.</p>
</li>
<li data-list-text="4.">
<p>No other trees are Fibonacci-trees.</p>
</li>
</ol>

<img src="fig/4.30.png" width="600"/>
<p>Fig. 4.30. Fibonacci-trees of height 2, 3, and 4</p>

<p>The number of nodes of <code>T<sub>h</sub></code> is defined by the following simple recurrence
relation:</p>
<code class='large'>N<sub>0</sub> = 0, N<sub>1</sub> = 1
N<sub>h</sub> = N<sub>h-1</sub> + 1 + N<sub>h-2</sub></code>

<p>The <code>N<sub>h</sub></code> are those
numbers of nodes for which the worst case (upper limit of
<code>h</code>) can be attained, and they are called
<i>Leonardo numbers</i>.</p>

<ol class="page" id="l86">

<li data-list-text="4.5.1" id="4.5.1">
<h4><a href='#4.5.1'>Balanced Tree Insertion</a></h4>

<p>Let us now consider what may happen when a new node is inserted in
a balanced tree. Given a root <code>r</code> with the
left and right subtrees <code>L</code> and <code>R</code>,
three cases must be distinguished. Assume that the
new node is inserted in <code>L</code> causing its
height to increase by 1:</p>
<ol id="l87">
<li data-list-text="1.">
<code>= h<sub>R</sub><span class="p">:</span> L</code>
and <code>R</code> become of unequal
height, but the balance criterion is not violated.</p>
</li>
<li data-list-text="2.">
<p><code>&lt; h<sub>R</sub></code>: <code>L</code> and <code>R</code>
obtain equal height,
i.e., the balance has even been improved.</p>
</li>
<li data-list-text="3.">
<p><code>&gt; h<sub>R</sub></code>: the balance
criterion is violated, and the tree must be
restructured.</p>
</li>
</ol>

<p>Consider the tree in Fig. 4.31. Nodes with keys 9 and 11 may be
inserted without rebalancing; the tree with root 10 will become
one-sided (case 1); the one with root 8 will improve its balance
(case 2). Insertion of nodes 1, 3, 5, or 7, however, requires
subsequent rebalancing.</p>

<img src="fig/4.31.png" width="200"/>
<p>Fig. 4.31. Balanced tree</p>

<p>Some careful scrutiny of the situation reveals that there are only
two essentially different constellations needing individual treatment.
The remaining ones can be derived by
symmetry considerations from those two. Case 1 is characterized by
inserting keys 1 or 3 in the tree of Fig. 4.31, case 2 by inserting
nodes 5 or 7.</p>

<p>The two cases are generalized in Fig. 4.32 in which rectangular
boxes denote subtrees, and the height added by the insertion is
indicated by crosses. Simple transformations of the two structures
restore the desired balance. Their result is shown in Fig. 4.33;
note that the only movements allowed are those occurring in the
vertical direction, whereas the relative horizontal positions of
the shown nodes and subtrees must remain unchanged.</p>

<img src="fig/4.32.png" width="700"/>
<p>Fig. 4.32. Imbalance resulting from insertion</p>


<img src="fig/4.33.png" width="700"/>
<p>Fig. 4.33. Restoring the balance</p>

<p>An algorithm for insertion and rebalancing critically depends on
the way information about the tree's balance is stored. An extreme
solution lies in keeping balance information entirely implicit in
the tree structure itself. In this case, however, a node's balance
factor must be rediscovered each time it is affected by an
insertion, resulting in an excessively high overhead. The other
extreme is to attribute an explicitly stored balance factor to
every node. The definition of the type <code>Node</code>
is then extended into</p>
<code class='large'>TYPE Node = POINTER TO RECORD
              key, count, bal: INTEGER; (*bal = -1, 0, +1*)
              left, right: Node
            END</code>

<p>We shall subsequently interpret a node's balance factor as the
height of its right subtree minus the height of its left subtree,
and we shall base the resulting algorithm on this node type. The
process of node insertion consists essentially of the following
three consecutive parts:</p>
<ol id="l88">
<li data-list-text="1.">
<p>Follow the search path until it is verified that the key is not
already in the tree.</p>
</li>
<li data-list-text="2.">
<p>Insert the new node and determine the resulting balance factor.</p>
</li>
<li data-list-text="3.">
<p>Retreat along the search path and check the balance factor at each
node. Rebalance if necessary. </p>
</li>
</ol>

<p>Although this method involves some
redundant checking (once balance is established, it need not be
checked on that node's ancestors), we shall first adhere to this
evidently correct schema because it can be implemented through a
pure extension of the already established search and insertion
procedures. This procedure describes the search operation needed at
each single node, and because of its recursive formulation it can
easily accommodate an additional operation on the way back along
the search path. At each step, information must be passed as to
whether or not the height of the subtree (in which the insertion
had been performed) had increased. We therefore extend the
procedure's parameter list by the Boolean <code>h</code>
with the meaning the subtree height has increased. Clearly,
<code>h</code> must denote a variable parameter since it
is used to transmit a result.</p>

<p>Assume now that the process is returning to a node
<code>p^</code> from the left branch (see Fig. 4.32), with the
indication that it has increased its height. We now must
distinguish between the three conditions involving the subtree
heights prior to insertion:</p>

<ol id="l89">
<li data-list-text="1.">
<p><code>h<sub>L</sub> &lt; h<sub>R</sub></code>,
<code>p.bal = +1</code>;
the previous imbalance at <code>p</code> has
been equilibrated.</p>
</li>
<li data-list-text="2.">
<p><code>h<sub>L</sub> = h<sub>R</sub></code>,
<code>p.bal = 0</code>;
the weight is now slanted to the left.</p>
</li>
<li data-list-text="3.">
<p><code>h<sub>L</sub> &gt; h<sub>R</sub></code>,
<code>p.bal = -1</code>; rebalancing is necessary.</p>
</li>
</ol>

<p>In the third case, inspection of the balance factor of the root of
the left subtree (say, <code>p1.bal</code>) determines
whether case 1 or case 2 of Fig. 4.32 is present. If that node has
also a higher left than right subtree, then we have to deal with
case 1, otherwise with case 2. (Convince yourself that a left
subtree with a balance factor equal to 0 at its root cannot occur
in this case.) The rebalancing operations necessary are entirely
expressed as sequences of pointer reassignments. In fact, pointers
are cyclically exchanged, resulting in either a single or a double
rotation of the two or three nodes involved. In addition to pointer
rotation, the respective node balance factors have to be updated.
The details are shown in the search, insertion, and rebalancing
procedures.</p>

<img src="fig/4.34.png" width="700"/>
<p>Fig. 4.34. Insertions in balanced tree</p>

<p>The working principle is shown by Fig. 4.34. Consider the binary
tree (a) which consists of two nodes only. Insertion of key 7 first
results in an unbalanced tree (i.e., a linear list). Its balancing
involves a RR single rotation, resulting in the perfectly balanced
tree (b). Further insertion of nodes 2 and 1 result in an imbalance
of the subtree with root 4. This subtree is balanced by an LL
single rotation (d). The subsequent insertion of key 3 immediately
offsets the balance criterion at the root node 5. Balance is
thereafter reestablished by the more complicated LR double
rotation; the outcome is tree (e). The only candidate for losing
balance after a next insertion is node 5. Indeed, insertion of node
6 must invoke the fourth case of rebalancing outlined below, the RL
double rotation. The final tree is shown in Fig.4.34 (f).</p>

<code class='large'>PROCEDURE search (x: INTEGER; VAR p: Node; VAR h: BOOLEAN);
  VAR p1, p2: Node; <span >(* ADenS45_AVLtrees *)</span>
BEGIN
  (*~h*)
  IF p = NIL THEN (*insert*)
    NEW(p); p.key := x; p.count := 1; p.left := NIL; p.right := NIL;
    p.bal := 0 h := TRUE;
  ELSIF p.key &gt; x THEN
    search(x, p.left, h);
    IF h THEN (*left branch has grown*)
      IF p.bal = 1 THEN p.bal := 0; h := FALSE
      ELSIF p.bal = 0 THEN p.bal := -1
      ELSE (*bal = -1, rebalance*) p1 := p.left;
        IF p1.bal = -1 THEN (*single LL rotation*) p.left := p1.right;
          p1.right := p;
          p.bal := 0; p := p1
        ELSE (*double LR rotation*) p2 := p1.right;
          p1.right := p2.left;
          p2.left := p1;
          p.left := p2.right; p2.right := p;
          IF p2.bal = -1 THEN p.bal := 1 ELSE p.bal := 0 END;
          IF p2.bal = +1 THEN p1.bal := -1 ELSE p1.bal := 0 END;
          p := p2
        END;
        p.bal := 0;
        h := FALSE
      END
    END
  ELSIF p.key &lt; x THEN
    search(x, p.right, h);
    IF h THEN (*right branch has grown*)
      IF p.bal = -1 THEN p.bal := 0; h := FALSE
      ELSIF p.bal = 0 THEN p.bal := 1
      ELSE (*bal = +1, rebalance*) p1 := p.right;
        IF p1.bal = 1 THEN (*single RR rotation*)
          p.right := p1.left; p1.left := p; p.bal := 0; p := p1
        ELSE (*double RL rotation*)
          p2 := p1.left; p1.left := p2.right;
          p2.right := p1; p.right := p2.left; p2.left := p;
          IF p2.bal = +1 THEN p.bal := -1 ELSE p.bal := 0 END;
          IF p2.bal = -1 THEN p1.bal := 1 ELSE p1.bal := 0 END;
          p := p2
        END;
        p.bal := 0; h := FALSE
      END
    END
  ELSE INC(p.count)
  END
END search</code>

<p>Two particularly interesting questions concerning the performance
of the balanced tree insertion algorithm are the following:</p>
<ol id="l91">
<li data-list-text="1.">
<p>If all <code>n!</code> permutations of <code>n</code>
keys occur with equal probability, what is the
expected height of the constructed balanced tree?
</p>
</li>

<li data-list-text="2.">
<p>What is the probability that an insertion requires rebalancing?</p>
</li>
</ol>

<p>Mathematical analysis of this complicated algorithm
is still an open problem. Empirical tests support the conjecture
that the expected height of the balanced tree thus generated
is <code>h = log(n)+c</code>, where <code>c</code>
is a small constant (<code>c ≈ 0.25</code>).
This means that in practice the AVL-balanced
tree behaves as well as the perfectly balanced tree, although it is
much simpler to maintain. Empirical evidence also suggests that, on
the average, rebalancing is necessary once for approximately every
two insertions. Here single and double rotations are equally
probable. The example of Fig. 4.34 has evidently been carefully
chosen to demonstrate as many rotations as possible in a minimum
number of insertions.</p>

<p>The complexity of the balancing operations suggests that balanced
trees should be used only if information retrievals are
considerably more frequent than insertions. This is particularly
true because the nodes of such search trees are usually implemented
as densely packed records in order to economize storage. The speed
of access and of updating the balance factors — each requiring two
bits only — is therefore often a decisive factor to the efficiency
of the rebalancing operation. Empirical evaluations show that
balanced trees lose much of their appeal if tight record packing is
mandatory. It is indeed difficult to beat the straightforward,
simple tree insertion algorithm.</p>
</li>

<li data-list-text="4.5.2" id="4.5.2">
<h4><a href='#4.5.2'>Balanced Tree Deletion</a></h4>

<p>Our experience with tree deletion suggests that in the case of
balanced trees deletion will also be more complicated than
insertion. This is indeed true, although the rebalancing operation
remains essentially the same as for insertion. In particular,
rebalancing consists again of either single or a double rotations
of nodes.</p>

<p>The basis for balanced tree deletion is the ordinary tree deletion
algorithm. The easy cases are terminal nodes and nodes with only a
single descendant. If the node to be deleted has two subtrees, we
will again replace it by the rightmost node of its left subtree. As
in the case of insertion, a Boolean variable parameter <code>h</code>
is added with the meaning "the height of the subtree
has been reduced". Rebalancing has to be considered only when
<code>h</code> is true. <code>h</code> is
made true upon finding and deleting a node, or if rebalancing
itself reduces the height of a subtree. We now introduce the two
(symmetric) balancing operations in the form of procedures, because
they have to be invoked from more than one point in the deletion
algorithm. Note that <code>balanceL</code> is applied
when the left, <code>balanceR</code> after the right
branch had been reduced in height.</p>

<p>The operation of the procedure is illustrated in Fig. 4.35. Given
the balanced tree (a), successive deletion of the nodes with keys
4, 8, 6, 5, 2, 1, and 7 results in the trees (b) ... (h). Deletion
of key 4 is simple in itself, because it represents a terminal
node. However, it results in an unbalanced node 3. Its rebalancing
operation invoves an LL single rotation. Rebalancing becomes again
necessary after the deletion of node 6. This time the right subtree
of the root (7) is rebalanced by an RR single rotation. Deletion of
node 2, although in itself straightforward since it has only a
single descendant, calls for a complicated RL double rotation. The
fourth case, an LR double rotation, is finally invoked after the
removal of node 7, which at first was replaced by the rightmost
element of its left subtree, i.e., by the node with key 3.</p>

<img src="fig/4.35.png" width="700"/>
<p>Fig. 4.35. Deletions in balanced tree</p>

<code class='large'>PROCEDURE balanceL (VAR p: Node; VAR h: BOOLEAN); <span>(* ADenS45_AVLtrees *)</span>
  VAR p1, p2: Node;
BEGIN
  (*h; left branch has shrunk*)
  IF p.bal = -1 THEN p.bal := 0
  ELSIF p.bal = 0 THEN p.bal := 1; h := FALSE
  ELSE (*bal = 1, rebalance*) p1 := p.right;
    IF p1.bal &gt;= 0 THEN (*single RR rotation*)
      p.right := p1.left;
      p1.left := p;
      IF p1.bal = 0 THEN p.bal := 1; p1.bal := -1; h := FALSE
      ELSE p.bal := 0; p1.bal := 0
      END;
      p := p1
    ELSE (*double RL rotation*) p2 := p1.left;
      p1.left := p2.right; p2.right := p1;>
      p.right := p2.left; p2.left := p;
      IF p2.bal = +1 THEN p.bal := -1 ELSE p.bal := 0 END;
      IF p2.bal = -1 THEN p1.bal := 1 ELSE p1.bal := 0 END;
      p := p2; p2.bal := 0
    END
  END
END balanceL;

PROCEDURE balanceR (VAR p: Node; VAR h: BOOLEAN);
  VAR p1, p2: Node;
BEGIN
  (*h; right branch has shrunk*)
  IF p.bal = 1 THEN p.bal := 0
  ELSIF p.bal = 0 THEN p.bal := -1; h := FALSE
  ELSE (*bal = -1, rebalance*) p1 := p.left;
    IF p1.bal &lt;= 0 THEN
      (*single LL rotation*)
      p.left := p1.right; p1.right := p;
      IF p1.bal = 0 THEN p.bal := -1; p1.bal := 1; h := FALSE
      ELSE p.bal := 0; p1.bal := 0
      END;
      p := p1
    ELSE (*double LR rotation*)
      p2 := p1.right;
      p1.right := p2.left; p2.left := p1;
      p.left := p2.right; p2.right := p;
      IF p2.bal = -1 THEN p.bal := 1 ELSE p.bal := 0 END;
      IF p2.bal = +1 THEN p1.bal := -1 ELSE p1.bal := 0 END;
      p := p2; p2.bal := 0
    END
  END
END balanceR;

PROCEDURE delete (x: INTEGER; VAR p: Node; VAR h: BOOLEAN);
  VAR q: Node;

  PROCEDURE del (VAR r: Node; VAR h: BOOLEAN);
  BEGIN (*~h*)
    IF r.right # NIL THEN
      del(r.right, h);
      IF h THEN balanceR(r, h) END
    ELSE
      q.key := r.key; q.count := r.count;
      q := r; r := r.left; h := TRUE
    END
  END del;

BEGIN (*~h*)
  IF p = NIL THEN (*key not in tree*)
  ELSIF p.key &gt; x THEN
    delete(x, p.left, h);
    IF h THEN balanceL(p, h) END
  ELSIF p.key &lt; x THEN
    delete(x, p.right, h);
    IF h THEN balanceR(p, h) END
  ELSE (*delete p^*)
    q := p;
    IF q.right = NIL THEN p := q.left; h := TRUE
    ELSIF q.left = NIL THEN p := q.right; h := TRUE
    ELSE
      del(q.left, h);
      IF h THEN balanceL(p, h) END
    END
  END
END delete</code>

<p>Fortunately, deletion of an element in a balanced tree can also be
performed with — in the worst case —
<code>O(log n)</code> operations. An essential
difference between the behaviour of the insertion and deletion
procedures must not be overlooked, however. Whereas insertion of a
single key may result in at most one rotation (of two or three
nodes), deletion may require a rotation at every node along the
search path. Consider, for instance, deletion of the rightmost node
of a Fibonacci-tree. In this case the deletion of any single node
leads to a reduction of the height of the tree; in addition,
deletion of its rightmost node requires the maximum number of
rotations. This therefore represents the worst choice of node in
the worst case of a balanced tree, a rather unlucky combination of
chances. How probable are rotations, then, in general?</p>

<p>The surprising result of empirical tests is that whereas one
rotation is invoked for approximately every two insertions, one is
required for every five deletions only. Deletion in balanced trees
is therefore about as easy — or as complicated — as insertion.</p>

</li>
</ol>
</li>

<li data-list-text="4.6" id="4.6">
<h3><a href='#4.6'>Optimal Search Trees</a></h3>

<p>So far our consideration of organizing search trees has been based
on the assumption that the frequency of access is equal for all
nodes, that is, that all keys are equally probable to occur as a
search argument. This is probably the best assumption if one has no
idea of access distribution. However, there are cases (they are the
exception rather than the rule) in which information about the
probabilities of access to individual keys is available. These
cases usually have the characteristic that the keys always remain
the same, i.e., the search tree is subjected neither to insertion
nor deletion, but retains a constant structure. A typical example
is the scanner of a compiler which determines for each word
(identifier) whether or not it is a keyword (reserved word).
Statistical measurements over hundreds of compiled programs may in
this case yield accurate information on the relative frequencies of
occurrence, and thereby of access, of individual keys.</p>

<p>Assume that in a search tree the probability with which node
<code>i</code> is accessed is</p>
<code>Pr {x = k<sub>i</sub>} = p<sub>i</sub></code>,
<code>(</span><b>S</b>i: 1 ≤ i ≤ n : p<sub>i</sub>) = 1</code>
<p>We now wish to organize the search tree in a way that the total
number of search steps - counted over sufficiently many trials -
becomes minimal. For this purpose the definition of path length is
modified by (1) attributing a certain weight to each node and by
(2) assuming the root to be at level 1 (instead of 0), because it
accounts for the first comparison along the search path. Nodes that
are frequently accessed become heavy nodes; those that are rarely
visited become light nodes. The (internal) weighted path length is
then the sum of all paths from the root to each node weighted by
that node's probability of access.</p>
<code>P = <b>S</b>i: 1 ≤ i ≤ n : p<sub>i</sub> * h<sub>i</sub></code>
<p><code>h<sub>i</sub></code> is the level of
node <code>i</code>. The goal is now to minimize the
weighted path length for a given probability distribution. As an
example, consider the set of keys 1, 2, 3, with probabilities of
access <code>p<sub>1</sub> = 1/7</code>,
<code>p<sub>2</sub> = 2/7</code>
and <code>p<sub>3</sub> = 4/7</code>.
These three keys can be arranged in five different ways as search
trees (see Fig. 4.36).</p>

<img src="fig/4.36.png" width="700"/>
<p>Fig. 4.36. The search trees with 3 nodes</p>

<p>The weighted path lengths of trees (a) to (e) are computed
according to their definition as</p>
<code class='large'>P(a) = 11/7, P(b) = 12/7, P(c) = 12/7, P(d) = 15/7, P(e) = 17/7</code>

<p>Hence, in this example, not the perfectly balanced tree (c), but
the degenerate tree (a) turns out to be optimal.</p>

<p>The example of the compiler scanner immediately suggests that this
problem should be viewed under a slightly more general condition:
words occurring in the source text are not always keywords; as a
matter of fact, their being keywords is rather the exception.
Finding that a given word <code>k</code> is not a key in
the search tree can be considered as an access to a hypothetical
"special node" inserted between the next lower and next higher key
(see Fig. 4.19) with an associated external path length. If the
probability <code>q<sub>i</sub></code> of
a search argument <code>x</code> lying between the two
keys <code>k<sub>i</sub></code> and
<code>k<sub>i+1</sub></code> is also
known, this information may considerably change the structure of
the optimal search tree. Hence, we generalize the problem by also
considering unsuccessful searches. The overall average weighted
path length is now</p>
<code class='large'>P = (<b>S</b>i: 1 ≤ i ≤ n : p<sub>i</sub>*h<sub>i</sub>) + (<b>S</b>i: 1 ≤ i ≤ m : q<sub>i</sub>*h'<sub>i</sub>)</code>
<p>where</p>
<code class='large'>(<b>S</b>i: 1 ≤ i ≤ n : p<sub>i</sub>) + (<b>S</b>i: 1 ≤ i ≤ m : q<sub>i</sub>) = 1</code>
<p>and where, <code>h<sub>i</sub></code> is
the level of the (internal) node <code>i</code> and
<code>h'<sub>j</sub></code> is the level
of the external node <code>j</code>. The average
weighted path length may be called the cost of the search tree,
since it represents a measure for the expected amount of effort to
be spent for searching. The search tree that requires the minimal
cost among all trees with a given set of keys
<code>k<sub>i</sub></code> and probabilities
<code>p<sub>i</sub></code> and
<code>q<sub>i</sub></code> is called the
<i>optimal tree</i>.</p>

<img src="fig/4.37.png" width="500"/>
<p>Fig. 4.37. Search tree with associated access frequencies</p>

<p>For finding the optimal tree, there is no need to require that the
<code>p</code>'s and <code>q</code>'s sum up
to 1. In fact, these probabilities are commonly determined by
experiments in which the accesses to nodes are counted.
Instead of using the probabilities <code>p<sub>i</sub></code>
and <code>q<sub>j</sub></code>, we will subsequently use
such frequency counts and denote them by</p>
<p><code>a<sub>i</sub></code>= number of times the
search argument <code>x</code> equals <code>k<sub>i</sub></code></p>
<code>b<sub>j</sub></code>= number of times the
search argument <code>x</code> lies between
<code>k<sub>j</sub></code> and <code>k<sub>j+1</sub></code></p>
<p>By convention, <code>b<sub>0</sub></code>
is the number of times that <code>x</code>
is less than <code>k<sub>1</sub></code>, and
<code>b<sub>n</sub></code> is the
frequency of <code>x</code> being greater than
<code>k<sub>n</sub></code> (see Fig. 4.37). We
will subsequently use <code>P</code> to denote the
accumulated weighted path length instead of the average path
length:</p>
<code class='large'>P = (<b>S</b>i: 1 ≤ i ≤ n : a<sub>i</sub>*h<sub>i</sub>) + (<b>S</b>i: 1 ≤ i ≤ m : b<sub>i</sub>*h'<sub>i</sub>)</code>

<p>Thus, apart from avoiding the computation of the probabilities from
measured frequency counts, we gain the further advantage of being
able to use integers instead of fractions in our search for the
optimal tree.</p>
<p>
Considering the fact that the number of possible configurations of
<code>n</code> nodes grows exponentially with
<code>n</code>, the task of finding the optimum seems
rather hopeless for large <code>n</code>. Optimal trees,
however, have one significant property that helps to find them: all
their subtrees are optimal too. For instance, if the tree in
Fig.4.37 is optimal, then the subtree with keys
<code>k<sub>3</sub></code> and
<code>k<sub>4</sub></code> is also optimal as
shown. This property suggests an algorithm that systematically
finds larger and larger trees, starting with individual nodes as
smallest possible subtrees. The tree thus grows from the leaves to
the root, which is, since we are used to drawing trees upside-down,
the bottom-up direction [4-6].</p>

<p>The equation that is the key to this algorithm is derived as
follows: Let <code>P</code> be the weighted path length
of a tree, and let <code>P<sub>L</sub></code> and
<code>P<sub>R</sub></code> be those of the left and
right subtrees of its root.
Clearly, <code>P</code> is the sum of
<code>P<sub>L</sub></code> and
<code>P<sub>R</sub></code>, and the number of times a
search travels on the leg to the root, which is simply the total
number <code>W</code> of search trials. We call
<code>W</code> the weight of the tree. Its average path
length is then <code>P/W</code>:
</p>

<div class='table'><table>
  <tr><td><code>P </code></td><td><code>= P<sub>L</sub> + W + P<sub>R</sub></code></td></tr>
  <tr><td><code>W </code></td>
    <td><code>= (<b>S</b>i: 1 ≤ i ≤ n : a<sub>i</sub>) + (<b>S</b>i: 1 ≤ i ≤ m : b<sub>i</sub>)</code></td>
  </tr>
</table></div>

<p>These considerations show the need for a denotation of the weights
and the path lengths of any subtree consisting of a number of
adjacent keys. Let <code>T<sub>ij</sub></code>
be the optimal subtree consisting of nodes with
keys <code>k<sub>i+1</sub></code>,
<code>k<sub>i+2</sub>, ... , k<sub>j</sub></code>. T
hen let
<code>w<sub>ij</sub></code> denote the
weight and let <code>p<sub>ij</sub></code>
denote the path length of <code>T<sub>ij</sub></code>. Clearly
<code>P = p<sub>0,n</sub></code> and <code>W = w<sub>0,n</sub></code>.
These quantities are defined by the following recurrence relations:
</p>

<div class='table'><table>
  <tr><td><code>w<sub>ii</sub> = b<sub>i</sub></code></td><td><code>(0 ≤ i ≤ n)</code></td></tr>
  <tr><td><code>w<sub>ij</sub> = w<sub>i,j-1</sub> + a<sub>j</sub> + b<sub>j</sub></code></td>
    <td><code>(0 ≤ i &lt; j ≤ n)</code></td>
  </tr>
  <tr><td><code>p<sub>ii</sub> = w<sub>ii</sub></code></td><td><code>(0 ≤ i ≤ n)</code></td></tr>
  <tr><td><code>p<sub>ij</sub> = w<sub>ij</sub> + MIN k: i &lt; k ≤ j : (p<sub>i,k-1</sub> + p<sub>kj</sub>)</code></td>
    <td><code>(0 ≤ i &lt; j ≤ n)</code></td>
  </tr>
</table></div>

<p>The last equation follows immediately from the
definitions of <code>P</code> and of optimality. Since
there are approximately <code>n<sup>2</sup>/2</code>
values <code>p<sub>ij</sub></code>, and because its definition calls
for a choice among all cases such that
<code>0 &lt; j-i ≤ n</code>, the minimization
operation will involve approximately <code>n<sup>3</sup>/6</code>
operations. Knuth pointed out that
a factor <code>n</code> can be saved by the following
consideration, which alone makes this algorithm usable for
practical purposes.</p>

<p>Let <code>r<sub>ij</sub></code> be a value
of <code>k</code> which achieves the minimum for It is
possible to limit the search for <code>r<sub>ij</sub></code>
to a much smaller interval, i.e., to reduce the number of
the <code>j-i</code> evaluation steps. The key is the observation that
if we have found the root <code>r<sub>ij</sub></code>
of the optimal subtree <code>T<sub>ij</sub></code>, then neither extending
the tree by adding a node at the right, nor shrinking the tree by
removing its leftmost node ever can cause the optimal root to move
to the left. This is expressed by the relation</p>

<code>r<sub>i,j-1</sub> ≤ r<sub>ij</sub> ≤ r<sub>i+1,j</sub></code>

<p>which limits the search for possible solutions
for <code>r<sub>ij</sub></code> to the
range <code>r<sub>i,j-1</sub> ... r<sub>i+1,j</sub></code>.
This results in a total number of elementary steps
in the order of <code>n<sup>2</sup></code>.</p>

<p>We are now ready to construct the optimization
algorithm in detail. We recall the following definitions, which are
based on optimal trees <code>T<sub>ij</sub></code>
consisting of nodes with keys
<code>k<sub>i+1</sub> ... k<sub>j</sub></code>:</p>

<ol id="l92">
<li data-list-text="1.">
<p><code>a<sub>i</sub></code>: the frequency of a
search for <code>k<sub>i</sub></code>.</p>
</li>
<li data-list-text="2.">
<p><code>b<sub>j</sub></code>: the frequency of a
search argument <code>x</code> between
<code>k<sub>j</sub></code> and
<code>k<sub>j+1</sub></code>.</p>
</li>
<li data-list-text="3.">
<p><code>w<sub>ij</sub></code>: the weight of
<code>T<sub>ij</sub></code>.</p>
</li>
<li data-list-text="4.">
<p><code>p<sub>ij</sub></code>: the weighted path
length of <code>T<sub>ij</sub></code>.</p>
</li>
<li data-list-text="5.">
<p><code>r<sub>ij</sub></code>: the index of the root
of <code>T<sub>ij</sub></code>. We declare
the following arrays:</p>
</li>
</ol>
<code class='large'>a:      ARRAY n+1 OF INTEGER; (*a[0] not used*)
b:      ARRAY n+1 OF INTEGER;
p,w,r:  ARRAY n+1, n+1 OF INTEGER;</code>

<p>Assume that the weights
<code>w<sub>ij</sub></code> have been computed from <code>a</code>
and <code>b</code> in a straightforward way. Now
consider <code>w</code> as the argument of the procedure
<code>OptTree</code> to be developed and consider
<code>r</code> as its result, because <code>r</code>
describes the tree structure completely.
<code>p</code> may be considered an intermediate result. Starting
out by considering the smallest possible subtrees, namely those
consisting of no nodes at all, we proceed to larger and larger
trees. Let us denote the width <code>j-i</code> of the
subtree <code>T<sub>ij</sub></code> by
<code>h</code>. Then we can trivially determine the
values <code>p<sub>ii</sub></code> for all
trees with <code>h = 0</code> according to the
definition of <code>p<sub>ij</sub></code>:</p>

<code>FOR i := 0 TO n DO p[i,i] := b[i] END</code>

<p>In the case <code>h = 1</code> we deal with trees
consisting of a single node, which plainly is also the root (see
Fig. 4.38).</p>

<code class='large'>FOR i := 0 TO n-1 DO
  j := i+1; p[i,j] := w[i,j] + p[i,i] + p[j,j]; r[i,j] := j
END</code>
<br/>

<img src="fig/4.38.png" width="200"/>
<p>Fig. 4.38. Optimal search tree with single node</p>

<p>Note that <code>i</code> denotes the left index limit
and <code>j</code> the right index limit in the
considered tree <code>T<sub>ij</sub></code>.
For the cases <code>h &gt; 1</code> we
use a repetitive statement with <code>h</code> ranging
from 2 to <code>n</code>, the case <code>h = n</code>
spanning the entire tree <code>T<sub>0,n</sub></code>.
In each case the minimal
path length <code>p<sub>ij</sub></code>
and the associated root index <code>r<sub>ij</sub></code>
are determined by a simple repetitive statement
with an index <code>k</code> ranging over the interval
given for <code>r<sub>ij</sub></code>:</p>
<code class='large'>FOR h := 2 TO n DO
  FOR i := 0 TO n-h DO
    j := i+h;
    <code class='pseudo'>find k and min = MIN k: i &lt; k &lt; j : (p<sub>i,k-1</sub> + p<sub>kj</sub>) such that r<sub>i,j-1</sub> &lt; k &lt; r<sub>i+1,j</sub>;</code>
    p[i,j] := min + w[i,j]; r[i,j] := k
  END
END</code>

<p>The details of the refinement of the statement in
italics can be found in the program presented below. The average
path length of <code>T<sub>0,n</sub></code>
is now given by the quotient <code>p<sub>0,n</sub>/w<sub>0,n</sub></code>,
and its root is the node with index <code>r<sub>0,n</sub></code>.</p>

<p>Let us now describe the structure of the program to be designed.
Its two main components are the procedures to find the optimal
search tree, given a weight distribution <code>w</code>,
and to display the tree given the indices <code>r</code>.
First, the counts <code>a</code> and
<code>b</code> and the keys are read from an input
source. The keys are actually not involved in the computation of
the tree structure; they are merely used in the subsequent display
of the tree. After printing the frequency statistics, the program
proceeds to compute the path length of the perfectly balanced tree,
in passing also determining the roots of its subtrees. Thereafter,
the average weighted path length is printed and the tree is
displayed.</p>

<p>In the third part, procedure <code>OptTree</code> is
activated in order to compute the optimal search tree; thereafter,
the tree is displayed. And finally, the same procedures are used to
compute and display the optimal tree considering the key
frequencies only, ignoring the frequencies of non-keys. To
summarize, the following are the global constants and
variables:</p>

<code class='large'>CONST N = 100; (*max no. of keywords*) <span>(* ADenS46_OptTree *)</span>
  WordLen = 16; (*max keyword length*)

VAR key: ARRAY N+1, WordLen OF CHAR;
  a, b: ARRAY N+1 OF INTEGER;
  p, w, r: ARRAY N+1, N+1 OF INTEGER;

PROCEDURE BalTree (i, j: INTEGER): INTEGER;
  VAR k, res:INTEGER;
BEGIN
  k := (i+j+1) DIV 2; r[i, j] := k;
  IF i &gt;= j THEN res := 0
  ELSE res := BalTree(i, k-1) + BalTree(k, j) + w[i, j]
  END;
  RETURN res
END BalTree;

PROCEDURE ComputeOptTree (n: INTEGER);
  VAR x, min, tmp: INTEGER;
    i, j, k, h, m: INTEGER;
BEGIN
  (*argument: w, results: p, r*)
  FOR i := 0 TO n DO p[i, i] := 0 END;
  FOR i := 0 TO n-1 DO
    j := i+1; p[i, j] := w[i, j]; r[i, j] := j
  END;
  FOR h := 2 TO n DO
    FOR i := 0 TO n-h DO
      j := i+h; m := r[i, j-1]; min := p[i, m-1] + p[m, j];
      FOR k := m+1 TO r[i+1, j] DO
        tmp := p[i, k-1]; x := p[k, j] + tmp;
        IF x &lt; min THEN m := k; min := x END
      END;
      p[i, j] := min + w[i, j]; r[i, j] := m
    END
  END
END ComputeOptTree;

PROCEDURE WriteTree (i, j, level: INTEGER);
  VAR k: INTEGER; (*uses global writer W*)
BEGIN
  IF i &lt; j THEN
    WriteTree(i, r[i, j]-1, level+1);
    FOR k := 1 TO level DO Texts.Write(W, TAB) END;
    Texts.WriteString(W, key[r[i, j]]); Texts.WriteLn(W);
    WriteTree(r[i, j], j, level+1)
  END
END WriteTree;

PROCEDURE Find (VAR S: Texts.Scanner);
  VAR i, j, n: INTEGER; (*uses global writer W*)
BEGIN
  Texts.Scan(S); b[0] := SHORT(S.i);
  n := 0; Texts.Scan(S); (*input: a, key, b*)
  WHILE S.class = Texts.Int DO
    INC(n); a[n] := SHORT(S.i); Texts.Scan(S); COPY(S.s, key[n]);
    Texts.Scan(S); b[n] := SHORT(S.i); Texts.Scan(S)
  END;
  (*compute w from a and b*)
  FOR i := 0 TO n DO
    w[i, i] := b[i];
    FOR j := i+1 TO n DO
      w[i, j] := w[i, j-1] + a[j] + b[j]
    END
  END;
  Texts.WriteString(W, "Total weight = ");
  Texts.WriteInt(W, w[0, n], 6); Texts.WriteLn(W);
  Texts.WriteString(W, "Path length of balanced tree = ");
  Texts.WriteInt(W, BalTree(0, n), 6); Texts.WriteLn(W);
  WriteTree(0, n, 0); Texts.WriteLn(W);

  ComputeOptTree(n);

  Texts.WriteString(W, "Path length of optimal tree = ");
  Texts.WriteInt(W, p[0, n], 6); Texts.WriteLn(W);
  WriteTree(0, n, 0); Texts.WriteLn(W);
  FOR i := 0 TO n DO w[i, i] := 0;
    FOR j := i+1 TO n DO w[i, j] := w[i, j-1] + a[j] END
  END;

  ComputeOptTree(n);

  Texts.WriteString(W, "optimal tree not considering b");
  Texts.WriteLn(W); WriteTree(0, n, 0); Texts.WriteLn(W)
END Find;</code>

<p>As an example, let us consider the following input data of a tree
with 3 keys:</p>
<code class='large'>20  1 Albert  10  2 Ernst   1   5 Peter 1
b<sub>0</sub> = 20
a<sub>1</sub> = 1 key<sub>1</sub> = Albert b<sub>1</sub> = 10
a<sub>2</sub> = 2 key<sub>2</sub> = Ernst b<sub>2</sub> = 1
a<sub>3</sub> = 4 key<sub>3</sub> = Peter b<sub>3</sub> = 1</code>

<p>The results of procedure <code>Find</code> are shown in
Fig. 4.39 and demonstrate that the structures obtained for the
three cases may differ significantly. The total weight is 40, the
path length of the balanced tree is 78, and that of the optimal
tree is 66.</p>

<img src="fig/4.39.png" width="750"/>
<p>Fig. 4.39. The 3 trees generated by the Optimal Tree procedure</p>

<p>It is evident from this algorithm that the effort to determine the
optimal structure is of the order of <code>n<sup>2</sup></code>; also, the amount of
required storage is of the order <code>n<sup>2</sup></code>. This is unacceptable if
<code>n</code> is very large. Algorithms with greater
efficiency are therefore highly desirable. One of them is the
algorithm developed by Hu and Tucker [4-5] which requires only
<code>O(n)</code> storage and <code>O(n*log(n))</code> computations. However, it considers only
the case in which the key frequencies are zero, i.e., where only
the unsuccessful search trials are registered. Another algorithm,
also requiring <code>O(n)</code> storage elements and
<code>O(n*log(n))</code> computations was described by
Walker and Gotlieb [4-7]. Instead of trying to find the optimum,
this algorithm merely promises to yield a nearly optimal tree. It
can therefore be based on heuristic principles. The basic idea is
the following.</p>

<p>Consider the nodes (genuine and special nodes) being distributed on
a linear scale, weighted by their frequencies (or probabilities) of
access. Then find the node which is closest to the center of
gravity. This node is called the <i>centroid</i>, and its index
is</p>

<code class='large'>(<strong>S</strong>i: 1 ≤ i ≤ n : i*a<sub>i</sub>) + (<strong>S</strong>i: 1 ≤ i ≤ m : i*b<sub>i</sub>) / W</code>

<p>rounded to the nearest integer. If all nodes have equal weight,
then the root of the desired optimal tree evidently coincides with
the centroid Otherwise - so the reasoning goes - it will in most
cases be in the close neighborhood of the centroid. A limited
search is then used to find the local optimum, whereafter this
procedure is applied to the resulting two subtrees. The likelihood
of the root lying very close to the centroid grows with the size
<code>n</code> of the tree. As soon as the subtrees have
reached a manageable size, their optimum can be determined by the
above exact algorithm.</p>

</li>

<li data-list-text="4.7" id="4.7">
<h3><a href='#4.7'>B-Trees</a></h3>

<p>So far, we have restricted our discussion to trees in which every
node has at most two descendants, i.e., to binary trees. This is
entirely satisfactory if, for instance, we wish to represent family
relationships with a preference to the pedigree view, in which
every person is associated with his parents. After all, no one has
more than two parents. But what about someone who prefers the
posterity view? He has to cope with the fact that some people have
more than two children, and his trees will contain nodes with many
branches. For lack of a better term, we shall call them
<i>multiway</i> trees.</p>

<p>Of course, there is nothing special about such structures, and we
have already encountered all the programming and data definition
facilities to cope with such situations. If, for instance, an
absolute upper limit on the number of children is given (which is
admittedly a somewhat futuristic assumption), then one may
represent the children as an array component of the record
representing a person. If the number of children varies strongly
among different persons, however, this may result in a poor
utilization of available storage. In this case it will be much more
appropriate to arrange the offspring as a linear list, with a
pointer to the youngest (or eldest) offspring assigned to the parent. A
possible type definition for this case is the following, and a
possible data structure is shown in Fig. 4.40.</p>
<code class='large'>TYPE Person =POINTER TO RECORD
               name: alfa;
               sibling, offspring: Person
             END</code>
<p></p>

<img src="fig/4.40.png" width="740"/>
<p>Fig. 4.40. Multiway tree represented as binary tree</p>

<p>We now realize that by tilting this picture by 45 degrees it will
look like a perfect binary tree. But this view is misleading
because functionally the two references have entirely different
meanings. One usually dosen't treat a sibling as an offspring and
get away unpunished, and hence one should not do so even in
constructing data definitions. This example could also be easily
extended into an even more complicated data structure by
introducing more components in each person's record, thus being
able to represent further family relationships. A likely candidate
that cannot generally be derived from the sibling and offspring
references is that of husband and wife, or even the inverse
relationship of father and mother. Such a structure quickly grows
into a complex relational data bank, and it may be possible to map
serveral trees into it. The algorithms operating on such structures
are intimately tied to their data definitions, and it does not make
sense to specify any general rules or widely applicable
techniques.</p>

<p>However, there is a very practical area of application of multiway
trees which is of general interest. This is the construction and
maintenance of large-scale search trees in which insertions and
deletions are necessary, but in which the primary store of a
computer is not large enough or is too costly to be used for
long-time storage.</p>

<p>Assume, then, that the nodes of a tree are to be stored on a
secondary storage medium such as a disk store. Dynamic data
structures introduced in this chapter are particularly suitable for
incorporation of secondary storage media. The principal innovation
is merely that pointers are represented by disk store addresses
instead of main store addresses. Using a binary tree for a data set
of, say, a million items, requires on the average approximately
<code>log 10</code><span class="s89">6</span> (i.e.
about 20) search steps. Since each step now involves a disk access
(with inherent latency time), a storage organization using fewer
accesses will be highly desirable. The multiway tree is a perfect
solution to this problem. If an item located on a secondary store
is accessed, an entire group of items may also be accessed without
much additional cost. This suggests that a tree be subdivided into
subtrees, and that the subtrees are represented as units that are
accessed all together. We shall call these subtrees <i>pages</i>.
Figure 4.41 shows a binary tree subdivided into pages, each page
consisting of 7 nodes.</p>

<img src="fig/4.41.png" width="740"/>
<p>Fig. 4.41. Binary tree subdivided into pages</p>

<p>The saving in the number of disk accesses — each
page access now involves a disk access — can be considerable.
Assume that we choose to place 100 nodes on a page (this is a
reasonable figure); then the million item search tree will on the
average require only <code>log<sub>100</sub>(10<sup>6</sup>)</code>
(i.e. about 3) page accesses instead of 20.
But, of course, if the tree is left to grow at random, then the
worst case may still be as large as <code>10<sup>4</sup></code>.
It is plain that a scheme
for controlled growth is almost mandatory in the case of multiway
trees.</p>

<ol class="page" id="l93">
<li data-list-text="4.7.1" id="4.7.1">
<h4><a href='#4.7.1'>Multiway B-Trees</a></h4>

<p>If one is looking for a controlled growth
criterion, the one requiring a perfect balance is quickly
eliminated because it involves too much balancing overhead. The
rules must clearly be somewhat relaxed. A very sensible criterion
was postulated by R. Bayer and E.M. McCreight [4.2] in 1970: every
page (except one) contains between <code>n</code> and
<code>2n</code> nodes for a given constant
<code>n</code>. Hence, in a tree with <code>N</code>
items and a maximum page size of <code>2n</code>
nodes per page, the worst case requires
<code>log<sub>n</sub>N</code> page accesses; and page accesses
clearly dominate the entire search effort. Moreover, the important
factor of store utilization is at least 50% since pages are always
at least half full. With all these advantages, the scheme involves
comparatively simple algorithms for search, insertion, and
deletion. We will subsequently study them in detail.
</p>

<p>The underlying data structures are called B-trees, and have the
following characteristics; <code>n</code> is said to be
the <i>order</i> of the B-tree.</p>

<ol>
<li>Every page contains at most <code>2n</code> items
(keys).</li>
<li>Every page, except the root page, contains at least <code>n</code> items.</li>
<li>3. Every page is either a leaf page, i.e. has no descendants, or it
has <code>m+1</code> descendants, where <code>m</code> is its number of keys on this page.</li>
<li>4. All leaf pages appear at the same level.</li>
</ol>

<img src="fig/4.42.png" width="700"/>
<p>Fig. 4.42. B-tree of order 2</p>

<p>Figure 4.42 shows a B-tree of order 2 with 3 levels. All pages
contain 2, 3, or 4 items; the exception is the root which is
allowed to contain a single item only. All leaf pages appear at
level 3. The keys appear in increasing order from left to right if the B-tree
is squeezed into a single level by inserting the descendants in
between the keys of their ancestor page. This arrangement
represents a natural extension of binary search trees, and it
determines the method of searching an item with given key. Consider
a page of the form shown in Fig. 4.43 and a given search
argument <code>x</code>. Assuming that the page has been
moved into the primary store, we may use conventional search
methods among the keys <code>k<sub>0</sub> ... k<sub>m-1</sub></code>.
If</span> m is sufficiently large, one may use binary search;
if it is rather small, an ordinary sequential search will do. (Note
that the time required for a search in main store is probably
negligible compared to the time it takes to move the page from
secondary into primary store.) If the search is unsuccessful, we
are in one of the following situations:</p>

<ol id="l94">
<li data-list-text="1.">
<code>k<sub>i</sub> &lt; x &lt; k<sub>i+1</sub></code>
for <code>0 &lt; i &lt; m-1</code>
The search continues on page <code>p<sub>i</sub>^</code>
</li>

<li data-list-text="2.">
<code>k<sub>m-1</sub> &lt; x</code>
The search continues on page <code>p<sub>m-1</sub>^</code>.
</li>
<li data-list-text="3.">
<code>x &lt; k<sub>0</sub></code>
The search continues on page <code>p<sub>-1</sub>^</code>.
</li>
</ol>

<img src="fig/4.43.png" width="360"/>
<p>Fig. 4.43. B-tree page with <code>m</code> keys</p>
<p>
If in some case the designated pointer is <code>NIL</code>,
i.e., if there is no descendant page, then there
is no item with key <code>x</code> in the whole tree,
and the search is terminated.</p>
<p>
Surprisingly, insertion in a B-tree is comparatively simple too. If
an item is to be inserted in a page with <code>m &lt; 2n</code>
items, the insertion process remains constrained to that
page. It is only insertion into an already full page that has
consequences upon the tree structure and may cause the allocation
of new pages. To understand what happens in this case, refer to
Fig. 4.44, which illustrates the insertion of key 22 in a B-tree of
order 2. It proceeds in the following steps:
</p>

<ol id="l95">
<li data-list-text="1.">
<p>
Key 22 is found to be missing; insertion in page
<code>C</code> is impossible because <code>C</code> is
already full.</p>
</li>
<li data-list-text="2.">
<p>
Page <code>C</code> is split into two pages (i.e., a new
page <code>D</code> is allocated).</p>
</li>
<li data-list-text="3.">
<p>
The <code>2n+1</code> keys are equally distributed onto
<code>C</code> and <code>D</code>, and the
middle key is moved up one level into the ancestor page
<code>A</code>.</p>
</li>

</ol>

<img src="fig/4.44.png" width="700"/>
<p>Fig. 4.44. Insertion of key 22 in B-tree</p>

<p>This very elegant scheme preserves all the characteristic
properties of B-trees. In particular, the split pages contain
exactly <code>n</code> items. Of course, the insertion
of an item in the ancestor page may again cause that page to
overflow, thereby causing the splitting to propagate. In the
extreme case it may propagate up to the root. This is, in fact, the
only way that the B-tree may increase its height. The B-tree has
thus a strange manner of growing: it grows from its leaves upward
to the root.</p>

<p>We shall now develop a detailed program from these sketchy
descriptions. It is already apparent that a recursive formulation
will be most convenient because of the property of the splitting
process to propagate
back along the search path. The general structure of the program
will therefore be similar to balanced tree insertion, although the
details are different. First of all, a definition of the page
structure has to be formulated. We choose to represent the items in
the form of an array.</p>

<code class='large'>TYPE Page = POINTER TO PageDescriptor;

  Item = RECORD key: INTEGER;
    p: Page;
    count: INTEGER (*data*)
  END;

  PageDescriptor = RECORD m: INTEGER; (* 0 .. 2n *)
                     p0: Page;
                     e: ARRAY 2*n OF Item
                   END</code>

<p>Again, the item component <code>count</code>
stands for all kinds of other information that
may be associated with each item, but it plays no role in the
actual search process. Note that each page offers space for
<code>2n</code> items. The field m indicates the actual number
of items on the page. As <code>m ≥ n</code>
(except for the root page), a storage utilization
of a least 50% is guaranteed.</p>

<p>The algorithm of B-tree search and insertion is formulated below as
a procedure called <code>search</code>. Its main
structure is straightforward and similar to that for the balanced
binary tree search, with the exception that the branching decision
is not a binary choice. Instead, the "within-page search" is
represented as a binary search on the array <code>e</code> of elements.</p>

<p>The insertion algorithm is formulated as a separate procedure
merely for clarity. It is activated after search has indicated that
an item is to be passed up on the tree (in the direction toward the
root). This fact is indicated by the Boolean result parameter
<code>h</code>; it assumes a similar role as in the
algorithm for balanced tree insertion, where
<code>h</code> indicates that the subtree had grown.
If <code>h</code> is true, the second result parameter,
<code>u</code>, represents the item being passed up. Note that
insertions start in hypothetical pages, namely, the "special nodes"
of Fig. 4.19; the new item is immediately handed up via the
parameter <code>u</code> to the leaf page for actual
insertion. The scheme is sketched here:</p>
<code class='large long'>PROCEDURE search (x: INTEGER; a: Page; VAR h: BOOLEAN; VAR u: Item);
BEGIN
  IF a = NIL THEN (*x not in tree, insert*)
    <code class='pseudo'>assign x to item u, set h to TRUE, indicating that an item u is passed up in the tree</code>
  ELSE
    <code class='pseudo'>binary search for x in array a.e;</code>
    IF <code class='pseudo'>found</code> THEN
      <code class='pseudo'>process data</code>
    ELSE
      search(x, descendant, h, u);
      IF h THEN (*an item was passed up*)
        IF <code class='pseudo'>no. of items on page a^ &lt; 2n</code> THEN
          <code class='pseudo'>insert u on page a^ and set h to FALSE</code>
        ELSE
          <code class='pseudo'>split page and pass middle item up </code>
        END
      END
    END
  END
END search</code>

<p>If the parameter <code>h</code> is true after the call
of <code>search</code> in the main program, a split of
the root page is requested. Since the root page plays an
exceptional role, this process has to be programmed separately. It
consists merely of the allocation of a new root page and the
insertion of the single item given by the paramerter <code>u</code>.</p>

<p>As a consequence, the new root page contains a single item only.
The details can be gathered from the program presented below, and
Fig. 4.45 shows the result of using the program to construct a
B-tree with the following insertion sequence of keys:</p>
<code class='large'>20; 40 10 30 15; 35 7 26 18 22; 5; 42 13 46 27 8 32; 38 24 45 25;</code>
<p>The semicolons designate the positions of the snapshots taken upon
each page allocation. Insertion of the last key causes two splits
and the allocation of three new pages.</p>

<img src="fig/4.45.png" width="640"/>
<p class="s72">Fig.4.45. Growth of B-tree of order 2</p>

<p>Since each activation of search implies one page
transfer to main store, <code>k = log<sub>n</sub>(N)</code>
recursive calls are necessary at most, if the
tree contains <code>N</code> items. Hence, we must be
capable of accommodating <code>k</code> pages in main
store. This is one limiting factor on the page size
<code>2n</code>. In fact, we need to accommodate even more
than <code>k</code> pages, because insertion may cause
page splitting to occur. A corollary is that the root page is best
allocated permanently in the primary store, because each query
proceeds necessarily through the root page.</p>

<p>Another positive quality of the B-tree organization is its
suitability and economy in the case of purely sequential updating
of the entire data base. Every page is fetched into primary store
exactly once.</p>

<p>Deletion of items from a B-tree is fairly straight-forward in
principle, but it is complicated in the details.</p>

<p>We may distinguish two different circumstances:</p>
<ol id="l96">
<li data-list-text="1.">
<p>The item to be deleted is on a leaf page; here its removal
algorithm is plain and simple.</p>
</li>
<li data-list-text="2.">
<p>The item is not on a leaf page; it must be replaced by one of the
two lexicographically adjacent items, which happen to be on leaf
pages and can easily be deleted.</p>
</li>
</ol>
<p>In case 2 finding the adjacent key is analogous to finding the one
used in binary tree deletion. We descend along the rightmost
pointers down to the leaf page <code>P</code>, replace
the item to be deleted by the rightmost item on
<code>P</code>, and then reduce the size of
<code>P</code> by <code>1</code>. In any case, reduction
of size must be followed by a check of the
number of items <code>m</code> on the reduced page,
because, if <code>m</code> &lt; <code>n</code>,
the primary characteristic of B-trees would be
violated. Some additional action has to be taken; this underflow
condition is indicated by the Boolean variable parameter
<code>h</code>.</p>

<p>The only recourse is to borrow or annect an item from one of the
neighboring pages, say from <code>Q</code>. Since this
involves fetching page <code>Q</code> into main store —
a relatively costly operation — one is tempted to make the best of
this undesirable situation and to annect more than a single item at
once. The usual strategy is to distribute the items on pages
<code>P</code> and <code>Q</code> evenly on
both pages. This is called <i>page balancing</i>.</p>

<p>Of course, it may happen that there is no item left to be annected
since <code>Q</code> has already reached its minimal
size <code>n</code>. In this case the total number of
items on pages <code>P</code> and <code>Q</code> is
<code>2n-1</code>; we may merge the two
pages into one, adding the middle item from the ancestor page of
<code>P</code> and <code>Q</code>, and then
entirely dispose of page <code>Q</code>. This is exactly
the inverse process of page splitting. The process may be
visualized by considering the deletion of key 22 in Fig. 4.45. Once
again, the removal of the middle key in the ancestor page may cause
its size to drop below the permissible limit <code>n</code>,
thereby requiring that further special action
(either balancing or merging) be undertaken at the next level. In
the extreme case page merging may propagate all the way up to the
root. If the root is reduced to size 0, it is itself deleted,
thereby causing a reduction in the height of the B-tree. This is,
in fact, the only way that a B-tree may shrink in height. Figure
4.46 shows the gradual decay of the B-tree of Fig. 4.45 upon the
sequential deletion of the keys</p>
<code class='large'>25 45 24; 38 32; 8 27 46 13 42; 5 22 18 26; 7 35 15;</code>

<p>The semicolons again mark the places where the snapshots are taken,
namely where pages are being eliminated. The similarity of its
structure to that of balanced tree deletion is particularly
noteworthy.</p>

<img src="fig/4.46.png" width="600"/>
<p>Fig. 4.46. Decay of B-tree of order 2</p>

<code class='large'>TYPE Page = POINTER TO PageRec; <span >(* ADenS471_Btrees *)</span>

  Entry = RECORD
    key: INTEGER; p: Page
  END;

  PageRec = RECORD
    m: INTEGER; (*no. of entries on page*)
    p0: Page;
    e: ARRAY 2*N OF Entry
  END;

  VAR root: Page; W: Texts.Writer;

PROCEDURE search (x: INTEGER; VAR p: Page; VAR k: INTEGER);
  VAR i, L, R: INTEGER; found: BOOLEAN; a: Page;
BEGIN
  a := root; found := FALSE;
  WHILE (a # NIL) &amp; ~found DO
    L := 0; R := a.m; (*binary search*)
    WHILE L &lt; R DO
      i := (L+R) DIV 2;
      IF x &lt;= a.e[i].key THEN R := i ELSE L := i+1 END
    END;
    IF (R &lt; a.m) &amp; (a.e[R].key = x) THEN found := TRUE
    ELSIF R = 0 THEN a := a.p0
    ELSE a := a.e[R-1].p
    END
  END;
  p := a; k := R
END search;

PROCEDURE insert (x: INTEGER; a: Page; VAR h: BOOLEAN; VAR v: Entry);
  (*a # NIL. Search key x in B-tree with root a;
    insert new item with key x.
    If an entry is to be passed up, assign it to v.
    h := "tree has become higher"*)
  VAR i, L, R: INTEGER;
    b: Page; u: Entry;
BEGIN
  (* ~h *)
  IF a = NIL THEN
    v.key := x; v.p := NIL; h := TRUE
  ELSE
    L := 0; R := a.m; (*binary search*)
    WHILE L &lt; R DO
      i := (L+R) DIV 2;
      IF x &lt;= a.e[i].key THEN R := i ELSE L := i+1 END
    END;
    IF (R &lt; a.m) &amp; (a.e[R].key = x) THEN (*found, do nothing*)
    ELSE (*item not on this page*)
      IF R = 0 THEN b := a.p0 ELSE b := a.e[R-1].p END;
      insert(x, b, h, u);
      IF h THEN (*insert u to the left of a.e[R]*)
        IF a.m &lt; 2*N THEN
          h := FALSE;
          FOR i := a.m TO R+1 BY -1 DO a.e[i] := a.e[i-1] END;
          a.e[R] := u;
          INC(a.m)
        ELSE (*overflow; split a into a, b and assign the middle entry to v*) NEW(b);
          IF R &lt; N THEN (*insert in left pate a*)
            v := a.e[N-1];
            FOR i := N-1 TO R+1 BY -1 DO a.e[i] := a.e[i-1] END;
            a.e[R] := u;
            FOR i := 0 TO N-1 DO b.e[i] := a.e[i+N] END
          ELSE (*insert in right page b*)
            DEC(R, N);
            IF R = 0 THEN
              v := u
            ELSE
              v := a.e[N];
              FOR i := 0 TO R-2 DO b.e[i] := a.e[i+N+1] END;
              b.e[R-1] := u
            END;
            FOR i := R TO N-1 DO b.e[i] := a.e[i+N] END
          END;
          a.m := N; b.m := N; b.p0 := v.p; v.p := b
        END
      END
    END
  END
END insert;

PROCEDURE underflow (c, a: Page; s: INTEGER; VAR h: BOOLEAN);
  (*a = underflow page, c = ancestor page,
    s = index of deleted entry in c*)
  VAR b: Page; i, k: INTEGER;
BEGIN
  (*h &amp; (a.m = N-1) &amp; (c.e[s-1].p = a) *)
  IF s &lt; c.m THEN (*b := page to the right of a*)
    b := c.e[s].p;
    k := (b.m-N+1) DIV 2; (*k = nof items available on page b*)
    a.e[N-1] := c.e[s]; a.e[N-1].p := b.p0;
    IF k &gt; 0 THEN (*balance by moving k-1 items from b to a*)
      FOR i := 0 TO k-2 DO a.e[i+N] := b.e[i] END;
      c.e[s] := b.e[k-1]; b.p0 := c.e[s].p;
      c.e[s].p := b; DEC(b.m, k);
      FOR i := 0 TO b.m-1 DO b.e[i] := b.e[i+k] END;
      a.m := N-1+k; h := FALSE
    ELSE (*merge pages a and b, discard b*)
      FOR i := 0 TO N-1 DO a.e[i+N] := b.e[i] END;
      DEC(c.m);
      FOR i := s TO c.m-1 DO c.e[i] := c.e[i+1] END;
      a.m := 2*N; h := c.m &lt; N
    END
  ELSE (*b := page to the left of a*)
    DEC(s);
    IF s = 0 THEN b := c.p0 ELSE b := c.e[s-1].p END;
    k := (b.m-N+1) DIV 2; (*k = nof items available on page b*)
    IF k &gt; 0 THEN
      FOR i := N-2 TO 0 BY -1 DO a.e[i+k] := a.e[i] END;
      a.e[k-1] := c.e[s]; a.e[k-1].p := a.p0;
      (*move k-1 items from b to a, one to c*)
      DEC(b.m, k);
      FOR i := k-2 TO 0 BY -1 DO a.e[i] := b.e[i+b.m+1] END;
      c.e[s] := b.e[b.m]; a.p0 := c.e[s].p;
      c.e[s].p := a; a.m := N-1+k; h := FALSE
    ELSE (*merge pages a and b, discard a*)
      c.e[s].p := a.p0; b.e[N] := c.e[s];
      FOR i := 0 TO N-2 DO b.e[i+N+1] := a.e[i] END;
      b.m := 2*N; DEC(c.m); h := c.m &lt; N
    END
  END
END underflow;

PROCEDURE delete (x: INTEGER; a: Page; VAR h: BOOLEAN);
  (*search and delete key x in B-tree a;
    if a page underflow arises,
    balance with adjacent page or merge;
    h := "page a is undersize"*)

  VAR i, L, R: INTEGER; q: Page;

  PROCEDURE del (p: Page; VAR h: BOOLEAN);
    VAR k: INTEGER; q: Page; (*global a, R*)
  BEGIN k := p.m-1; q := p.e[k].p;
    IF q # NIL THEN del(q, h);
      IF h THEN underflow(p, q, p.m, h) END
    ELSE p.e[k].p := a.e[R].p; a.e[R] := p.e[k];
      DEC(p.m); h := p.m &lt; N
    END
  END del;

BEGIN
  IF a # NIL THEN
    L := 0; R := a.m; (*binary search*)
    WHILE L &lt; R DO
      i := (L+R) DIV 2;
      IF x &lt;= a.e[i].key THEN R := i ELSE L := i+1 END
    END;
    IF R = 0 THEN q := a.p0 ELSE q := a.e[R-1].p END;
    IF (R &lt; a.m) &amp; (a.e[R].key = x) THEN (*found*)
      IF q = NIL THEN (*a is leaf page*)
        DEC(a.m); h := a.m &lt; N;
        FOR i := R TO a.m-1 DO a.e[i] := a.e[i+1] END
      ELSE
        del(q, h);
        IF h THEN underflow(a, q, R, h) END
      END
    ELSE
      delete(x, q, h);
      IF h THEN underflow(a, q, R, h) END
    END
  END
END delete;

PROCEDURE ShowTree (VAR W: Texts.Writer; p: Page; level: INTEGER);
  VAR i: INTEGER;
BEGIN
  IF p # NIL THEN
    FOR i := 1 TO level DO Texts.Write(W, 9X) END;
    FOR i := 0 TO p.m-1 DO Texts.WriteInt(W, p.e[i].key, 4) END;
    Texts.WriteLn(W);
    IF p.m &gt; 0 THEN ShowTree(W, p.p0, level+1) END;
    FOR i := 0 TO p.m-1 DO ShowTree(W, p.e[i].p, level+1) END
  END
END ShowTree;</code>

<p>Extensive analysis of B-tree performance has been undertaken and is
reported in the referenced article (Bayer and McCreight). In
particular, it includes a treatment of the question of optimal page
size, which strongly depends on the characteristics of the storage
and computing system available.</p>

<p>Variations of the B-tree scheme are discussed in Knuth, Vol. 3, pp.
476-479. The one notable observation is that page splitting should
be delayed in the same way that page merging is delayed, by first
attempting to balance neighboring pages. Apart from this, the
suggested improvements seem to yield marginal gains. A
comprehensive survey of B-trees may be found in [4-8].</p>
</li>

<li data-list-text="4.7.2" id="4.7.2">
<h4><a href='4.7.2'>Binary B-Trees</a></h4>

<p>The species of B-trees that seems to be least interesting is the
first order B-tree (<code>n = 1</code>). But sometimes
it is worthwhile to pay attention to the exceptional case. It is
plain, however, that first-order B-trees are not useful in
representing large, ordered, indexed data sets involving secondary
stores; approximately 50% of all pages will contain a single item
only. Therefore, we shall forget secondary stores and again
consider the problem of search trees involving a one-level store
only.</p>

<p>A <i>binary B-tree</i> (BB-tree) consists of nodes (pages) with
either one or two items. Hence, a page contains either two or three
pointers to descendants; this suggested the term <i>2-3 tree</i>.
According to the definition of B-trees, all leaf pages appear at
the same level, and all non-leaf pages of BB-trees have either two
or three descendants (including the root). Since we now are dealing
with primary store only, an optimal economy of storage space is
mandatory, and the representation of the items inside a node in the
form of an array appears unsuitable. An alternative is the dynamic,
linked allocation; that is, inside each node there exists a linked
list of items of length 1 or 2. Since each node has at most three
descendants and thus needs to harbor only up to three pointers, one
is tempted to combine the pointers for descendants and pointers in
the item list as shown in Fig. 4.47. The B-tree node thereby loses
its actual identity, and the items assume the role of nodes in a
regular binary tree. It remains necessary, however, to distinguish
between pointers to descendants (vertical) and pointers to siblings
on the same page (horizontal). Since only the pointers to the right
may be horizontal, a single bit is sufficient to record this
distiction. We therefore introduce the Boolean field
<code>h</code> with the meaning <i>horizontal</i>. The definition of
a tree node based on this representation is given below. It was
suggested and investigated by R. Bayer [4-3] in 1971 and represents
a search tree organization guaranteeing
<code>p = 2*log(N)</code> as maximum path length.</p>
<code class='large'>TYPE Node = POINTER TO RECORD
                key: INTEGER;
                ...........
                left, right: Node;
                h: BOOLEAN (*right branch horizontal*)
              END</code>
<br/>

<img src="fig/4.47.png" width="500">
<p>Fig. 4.47. Representation of BB-tree nodes</p>

<p>Considering the problem of key insertion, one must distinguish four
possible situations that arise from growth of the left or right
subtrees. The four cases are illustrated in Fig. 4.48.</p>

<img src="fig/4.48-1.png" width="700"/>
<img src="fig/4.48-3.png" width="700"/>
<p>Fig. 4.48. Node insertion in BB-tree</p>

<p>Remember that B-trees have the characteristic of growing from the
bottom toward the root and that the property of all leafs being at
the same level must be maintained. The simplest case (1) is when
the right subtree of a node A grows and when A is the only key on
its (hypothetical) page. Then, the descendant B merely becomes the
sibling of A, i.e., the vertical pointer becomes a horizontal
pointer. This simple raising of the right arm is not possible if A
already has a sibling. Then we would obtain a page with 3 nodes,
and we have to split it (case 2). Its middle node B is passed up to
the next higher level.</p>

<p>Now assume that the left subtree of a node B has grown in height.
If B is again alone on a page (case 3), i.e., its right pointer
refers to a descendant, then the left subtree (A) is allowed to
become B's sibling. (A simple rotation of pointers is necessary
since the left pointer cannot be horizontal). If, however, B
already has a sibling, the raising of A yields a page with three
members, requiring a split. This split is realized in a very
straightforward manner: C becomes a descendant of B, which is
raised to the next higher level (case 4).</p>

<p>It should be noted that upon searching a key, it makes no effective
difference whether we proceed along a horizontal or a vertical
pointer. It therefore appears artificial to worry about a left
pointer in case 3 becoming horizontal, although its page still
contains not more than two members. Indeed, the insertion algorithm
reveals a strange asymmetry in handling the growth of left and
right subtrees, and it lets the BB-tree organization appear rather
artificial. There is no proof of strangeness of this organization;
yet a healthy intuition tells us that something is fishy, and that
we should remove this asymmetry. It leads to the notion of the
<i>symmetric binary B-tree</i> (SBB-tree) which was also
investigated by Bayer <a href='#[4.4]'>[4.4]</a> in 1972.
On the average it leads to
slightly more efficient search trees, but the algorithms for
insertion and deletion are also slightly more complex. Furthermore,
each node now requires two bits (Boolean variable
<code>lh</code> and <code>rh</code>) to indicate the
nature of its two pointers.</p>

<p>Since we will restrict our detail considerations to the problem of
insertion, we have once again to distinguish among four cases of
grown subtrees. They are illustrated in Fig. 4.49, which makes the
gained symmetry evident. Note that whenever a subtree of node A
without siblings grows, the root of the subtree becomes the sibling
of A. This case need not be considered any further.</p>

<p>The four cases considered in Fig. 4.49 all reflect the occurrence
of a page overflow and the subsequent page split. They are labelled
according to the directions of the horizontal pointers linking the
three siblings in the middle figures. The initial situation is
shown in the left column; the middle column illustrates the fact
that the lower node has been raised as its subtree has grown; the
figures in the right column show the result of node
rearrangement.</p>

<img src="fig/4.49.png" width="700"/>
<p>Fig. 4.49. Insertion in SBB-trees</p>

<p>It is advisable to stick no longer to the notion of pages out of
which this organization had developed, for we are only interested
in bounding the maximum path length to <code>2*log(N)</code>.
For this we need only ensure that two
horizontal pointers may never occur in succession on any search
path. However, there is no reason to forbid nodes with horizontal
pointers to the left <i>and</i> right, i.e. to treat the left and
right sides differently. We therefore define the symmetric binary
B-tree as a tree that has the following properties:</p>

<ol id="l97">
<li data-list-text="1.">
<p>Every node contains one key and at most two (pointers to)
subtrees.</p>
</li>
<li data-list-text="2.">
<p>Every pointer is either horizontal or vertical. There are no two
consecutive horizontal pointers on any search path.</p>
</li>
<li data-list-text="3.">
<p>All terminal nodes (nodes without descendants) appear at the same
(terminal) level.</p>
</li>
</ol>

<p>From this definition it follows that the longest search path is no
longer than twice the height of the tree. Since no SBB-tree with
<code>N</code> nodes can have a height larger than
<code>log(N)</code>, it follows immediately that
<code>2*log(N)</code> is an upper bound on the search
path length. In order to visualize how these trees grow, we refer
to Fig. 4.50. The lines represent snapshots taken during the insertion of
the following sequences of keys, where every semicolon marks a
snapshot.</p>

<div class='table'><table>
<tr>
<td>(1)</td><td>1</td><td>2;</td><td>3;</td><td>4</td><td>5 6;</td><td>7;</td></tr>
<tr>
<td>(2)</td><td>5</td><td>4;</td><td>3;</td><td>1</td><td>2 7</td><td>6;</td></tr>
<tr>
<td>(3)</td><td>6</td><td>2;</td><td>4;</td><td>1</td><td>7 3</td><td>5;</td></tr>
<tr>
<td>(4)</td><td>4</td><td>2</td><td>6;</td><td>1</td><td>7; 3</td><td>5;</td></tr>
</table></div>

<img src="fig/4.50.png" width="700"/>
<p>Fig. 4.50. Insertion of keys 1 to 7</p>

<p>These pictures make the third property of B-trees particularly
obvious: all terminal nodes appear on the same level. One is
therefore inclined to compare these structures with garden hedges
that have been recently trimmed with hedge scissors.</p>

<p>The algorithm for the construction of SBB-trees is show below. It
is based on a definition of the type <code>Node</code>
with the two components <code>lh</code> and <code>rh</code>
indicating whether or not the left
and right pointers are horizontal.</p>
<code class='large'>TYPE Node = RECORD
       key, count: INTEGER;
       left, right: POINTER TO Node;
       lh, rh: BOOLEAN
     END</code>
<p>
The recursive procedure <code>search</code> again
follows the pattern of the basic binary tree insertion algorithm. A
third parameter <code>h</code> is added; it indicates
whether or not the subtree with root <code>p</code> has
changed, and it corresponds directly to the parameter
<code>h</code> of the B-tree search program. We must note, however,
the consequence of representing pages as linked lists: a page is
traversed by either one or two calls of the search procedure. We
must distinguish between the case of a subtree (indicated by a
vertical pointer) that has grown and a sibling node (indicated by a
horizontal pointer) that has obtained another sibling and hence
requires a page split. The problem is easily solved by introducing
a three-valued <code>h</code> with the following
meanings:</p>

<ol id="l98">
<li data-list-text="1.">
<p><code>h = 0</code>: the subtree <code>p</code>
requires no changes of the tree structure.</p>
</li>
<li data-list-text="2.">
<p><code>h = 1</code>: node <code>p</code> has obtained a
sibling.</p>
</li>
<li data-list-text="3.">
<p><code>h = 2</code>: the subtree <code>p</code> has
increased in height.</p>
</li>
</ol>

<code class='large'>PROCEDURE search (VAR p: Node; x: INTEGER; VAR h: INTEGER);
  VAR q, r: Node; <span>(* ADenS472_BBtrees *)</span>
BEGIN
  (*h=0*)
  IF p = NIL THEN (*insert new node*)
    NEW(p); p.key := x; p.L := NIL; p.R := NIL; p.lh := FALSE; p.rh := FALSE;
    h := 2
  ELSIF x &lt; p.key THEN search(p.L, x, h);
    IF h &gt; 0 THEN (*left branch has grown or received sibling*)
      q := p.L;
      IF p.lh THEN
        h := 2; p.lh := FALSE;
        IF q.lh THEN (*LL*)
          p.L := q.R; q.lh := FALSE; q.R := p; p := q
        ELSE (*q.rh, LR*)
          r := q.R; q.R := r.L; q.rh := FALSE; r.L := p.L; p.L := r.R; r.R := p; p := r
        END
      ELSE
        DEC(h);
        IF h = 1 THEN p.lh := TRUE END
      END
    END
  ELSIF x &gt; p.key THEN
    search(p.R, x, h);
    IF h &gt; 0 THEN (*right branch has grown or received sibling*)
      q := p.R;
      IF p.rh THEN
        h := 2; p.rh := FALSE;
        IF q.rh THEN (*RR*)
          p.R := q.L; q.rh := FALSE; q.L := p; p := q
        ELSE (*q.lh, RL*)
          r := q.L; q.L := r.R; q.lh := FALSE; r.R := p.R; p.R := r.L; r.L := p; p := r
        END
      ELSE
        DEC(h);
        IF h = 1 THEN p.rh := TRUE END
      END
    END
  END
END search;</code>

<p>Note that the actions to be taken for node rearrangement very
strongly resemble those developed in the AVL-balanced tree search
algorithm. It is evident that all four cases can be implemented by
simple pointer rotations: single rotations in the LL and RR cases,
double rotations in the LR and RL cases. In fact, procedure
<code>search</code> appears here slightly simpler than
in the AVL case. Clearly, the SBB-tree scheme
emerges as an alternative to the AVL-balancing criterion. A
performance comparison is therefore both possible and
desirable.</p>

<p>We refrain from involved mathematical analysis and concentrate on
some basic differences. It can be proven that the AVL-balanced
trees are a subset of the SBB-trees. Hence, the class of the latter
is larger. It follows that their path length is on the average
larger than in the AVL case. Note in this connection the worst-case
tree (4) in Fig. 4.50. On the other hand, node rearrangement is
called for less frequently. The balanced tree is therefore
preferred in those applications in which key retrievals are much
more frequent than insertions (or deletions); if this quotient is
moderate, the SBB-tree scheme may be preferred. It is very
difficult to say where the borderline lies. It strongly depends not
only on the quotient between the frequencies of retrieval and
structural change, but also on the characteristics of an
implementation. This is particularly the case if the node records
have a densely packed representation, and if therefore access to
fields involves part-word selection.</p>

<p>The SBB-tree has later found a rebirth under the name of red-black
tree. The difference is that whereas in the case of the symmetric,
binary B-tree every node contains two <code>h</code>-fields
indicating whether the emanating pointers are
horizontal, every node of the red-black tree contains a single
<code>h</code>-field, indicating whether the incoming
pointer is horizontal. The name stems from the idea to color nodes
with incoming down-pointer black, and those with incoming
horizontal pointer red. No two red nodes can immediately follow
each other on any path. Therefore, like in the cases of the BB- and
SBB-trees, every search path is at most twice as long as the height
of the tree. There exists a canonical mapping from binary B-trees
to red-black trees.</p>

</li>
</ol>
</li>

<li data-list-text="4.8" id="4.8">
<h3><a href='#4.8'>Priority Search Trees</a></h3>

<p>Trees, and in particular binary trees, constitute very effective
organisations for data that can be ordered on a linear scale. The
preceding chapters have exposed the most frequently used ingenious
schemes for efficient searching and maintenance (insertion,
deletion). Trees, however, do not seem to be helpful in problems
where the data are located not in a one-dimensional, but in a
multi-dimensional space. In fact, efficient searching in
multi-dimensional spaces is still one of the more elusive problems
in computer science, the case of two dimensions being of particular
importance to many practical applications.</p>

<p>Upon closer inspection of the subject, trees might still be applied
usefully at least in the two-dimensional case. After all, we draw
trees on paper in a two-dimensional space. Let us therefore briefly
review the characteristics of the two major kinds of trees so far
encountered.</p>

<ol id="l99">
<li data-list-text="1.">
<p>A search tree is governed by the invariants</p>
<p><code>p.left ≠ NIL  </code> implies <code> p.left.x &lt; p.x</code>, </p>
<p><code>p.right ≠ NIL </code> implies <code> p.x &lt; p.right.x</code>,</p>
<p>holding for all nodes <code>p</code> with key
<code>x</code>. It is apparent that only the horizontal
position of nodes is at all constrained by the invariant, and that
the vertical positions of nodes can be arbitrarily chosen such that
access times in searching, (i.e. path lengths) are minimized.</p>
</li>
<li data-list-text="2.">
<p>A heap, also called <i>priority tree</i>, is governed by the
invariants</p>
<p><code>p.left ≠ NIL  </code> implies <code> p.y ≤ p.left.y</code>,</p>
<p><code>p.right ≠ NIL </code> implies <code> p.y ≤ p.right.y</code>,</p>
<p>holding for all nodes <code>p</code> with key
<code>y</code>. Here evidently only the vertical
positions are constrained by the invariants.</p>
</li>
</ol>


<p>It seems straightforward to combine these two conditions in a
definition of a tree organization in a two-dimensional space, with
each node having two keys <code>x</code> and
<code>y</code> which can be regarded as coordinates of
the node. Such a tree represents a point set in a plane, i.e. in a
two-dimensional Cartesian space; it is therefore
called <i>Cartesian tree</i> [4-9]. We prefer the term <i>priority
search tree</i>, because it exhibits that this structure emerged
from a combination of the priority tree and the search tree. It is
characterized by the following invariants holding for each node
<code>p</code>:</p>

<div class='table'><table>
<tr>
<td><code>p.left ≠ NIL</code></td><td>implies</td><td>
<code>(p.left.x &lt; p.x) &amp; (p.y ≤ p.left.y)</code>
</td>
</tr>
<tr>
<td><code>p.right ≠ NIL</code></td><td>implies</td>
<td><code>(p.x &lt; p.right.x) &amp; (p.y ≤ p.right.y)</code></td>
</tr>
</table></div>

<p>It should come as no big surprise, however, that the search
properties of such trees are not particularly wonderful. After all,
a considerable degree of freedom in positioning nodes has been
taken away and is no longer available for choosing arrangements
yielding short path lengths. Indeed, no logarithmic bounds on
efforts involved in searching, inserting, or deleting elements can
be assured. Although this had already been the case for the
ordinary, unbalanced search tree, the chances for good average
behaviour are slim. Even worse, maintenance operations can become
rather unwieldy. Consider, for example, the tree of Fig. 4.51 (a).
Insertion of a new node C whose coordinates force it to be
inserted above and between A and B requires a considerable effort
transforming (a) into (b).</p>

<img src="fig/4.51.png" width="700"/>
<p>Fig. 4.51. Insertion into a priority search tree</p>

<p>McCreight discovered a scheme, similar to balancing, that, at the
expense of a more complicated insertion and deletion operation,
guarantees logarithmic time bounds for these operations. He calls
that structure a priority search tree [4-10]; in terms of our
classification, however, it should be called a balanced priority
search tree. We refrain from discussing that structure, because the
scheme is very intricate and in practice hardly used. By
considering a somewhat more restricted, but in practice no less
relevant problem, McCreight arrived at yet another tree structure,
which shall be presented here in detail. Instead of assuming that
the search space be unbounded, he considered the data space to be
delimited by a rectangle with two sides open. We denote the
limiting values of the <code>x</code>-coordinate by
<code>x<sub>min</sub></code> and
<code>x<sub>max</sub></code>.</p>

<p>In the scheme of the (unbalanced) priority search tree outlined
above, each node <code>p</code> divides the plane into
two parts along the line <code>x = p.x</code>. All nodes
of the left subtree lie to its left, all those in the right subtree
to its right. For the efficiency of searching this choice may be
bad. Fortunately, we may choose the dividing line differently. Let
us associate with each node <code>p</code> an interval
<code>[p.L .. p.R)</code>, ranging over all
<code>x</code> values including <code>p.L</code>
up to but excluding <code>p.R</code>.
This shall be the interval within which the
<code>x</code>-value of the node may lie. Then we postulate that the left
descendant (if any) must lie within the left half, the right
descendant within the right half of this interval. Hence, the
dividing line is not <code>p.x</code>, but
<code>(p.L+p.R)/2</code>.
For each descendant the interval is
halved, thus limiting the height of the tree to
<code>log(x<sub>max</sub>-x<sub>min</sub>)</code>.
This result holds only if no two
nodes have the same <code>x</code>-value, a condition
which, however, is guaranteed by the invariant. If we deal with
integer coordinates, this limit is at most equal to the wordlength
of the computer used. Effectively, the search proceeds like a
bisection or radix search, and therefore these trees are called
radix priority search trees [4-10]. They feature logarithmic bounds
on the number of operations required for searching, inserting, and
deleting an element, and are governed by the following invariants
for each node <code>p</code>:</p>
<div class='table'>
<p><code>p.left ≠ NIL  </code> implies
<code> (p.L ≤ p.left.x &lt; p.M) &amp; (p.y ≤ p.left.y)</code></p>
<p><code>p.right ≠ NIL </code> implies
<code> (p.M ≤ p.right.x &lt; p.R) &amp; (p.y ≤ p.right.y)</code></p>
</div>
<p>where</p>
<code class='large'>p.M         = (p.L + p.R) DIV 2
p.left.L    = p.L
p.left.R    = p.M
p.right.L   = p.M
p.right.R   = p.R</code>
<p>for all node <code>p</code>, and
<code>root.L = x<sub>min</sub>, root.R = x<sub>max</sub></code>.</p>

<p>A decisive advantage of the radix scheme is that maintenance
operations (preserving the invariants under insertion and deletion)
are confined to a single spine of the tree, because the dividing
lines have fixed values of <code>x</code> irrespective
of the <code>x</code>-values of the inserted nodes.</p>

<p>Typical operations on priority search trees are insertion,
deletion, finding an element with the least (largest) value of
<code>x</code> (or <code>y</code>) larger
(smaller) than a given limit, and enumerating the points lying
within a given rectangle. Given below are procedures for inserting
and enumerating. They are based on the following type
declarations:</p>
<code class='large'>TYPE Node = POINTER TO RECORD
  x, y: INTEGER;
  left, right: Node
END</code>

<p>Notice that the attributes
<code>x<sub>L</sub></code> and <code>x<sub>R</sub></code>
need not be recorded in the nodes themselves. They
are rather computed during each search. This, however, requires two
additional parameters of the recursive procedure
<code>insert</code>. Their values for the first call (with
<code>p = root</code>) are <code>x<sub>min</sub></code>
and <code>x<sub>max</sub></code> respectively. Apart from
this, a search proceeds similarly to that of a regular search tree.
If an empty node is encountered, the element is inserted. If the
node to be inserted has a <code>y</code>-value smaller
than the one being inspected, the new node is exchanged with the
inspected node. Finally, the node is inserted in the left subtree,
if its <code>x</code>-value is less than the middle
value of the interval, or the right subtree otherwise.</p>

<code class='large'>PROCEDURE insert (VAR p: Node; X, Y, xL, xR: INTEGER);
  VAR xm, t: INTEGER; <span>(* ADenS48_PrioritySearchTrees *)</span>
BEGIN
  IF p = NIL THEN (*not in tree, insert*)
    NEW(p); p.x := X; p.y := Y; p.left := NIL; p.right := NIL
  ELSIF p.x = X THEN (*found; don't insert*)
  ELSE
    IF p.y &gt; Y THEN
      t := p.x; p.x := X; X := t;
      t := p.y; p.y := Y; Y := t
    END;
    xm := (xL + xR) DIV 2;
    IF X &lt; xm THEN insert(p.left, X, Y, xL, xm)
    ELSE insert(p.right, X, Y, xm, xR)
    END
  END
END insert</code>

<p>The task of enumerating all points
<code>x</code>, <code>y</code> lying in a given
rectangle, i.e. satisfying <code>x0 ≤ x &lt; x1 and y ≤ y1</code> is
accomplished by the following procedure
<code>enumerate</code>. It calls a procedure <code>report(x,y)</code>
for each point found. Note that one side of the rectangle lies on the
<code>x</code>-axis, i.e. the lower bound for <code>y</code> is 0.
This guarantees that enumeration requires at
most <code>O(log(N) + s)</code> operations, where
<code>N</code> is the cardinality of the search space in
<code>x</code> and <code>s</code> is the
number of nodes enumerated.</p>

<code class='large'>PROCEDURE enumerate (p: Ptr; x0, x1, y1, xL, xR: INTEGER);
  VAR xm: INTEGER; <span>(* ADenS48_PrioritySearchTrees *)</span>
BEGIN
  IF p # NIL THEN
    IF (p.y &lt;= y1) &amp; (x0 &lt;= p.x) &amp; (p.x &lt; x1) THEN
      report(p.x, p.y)
    END;
    xm := (xL + xR) DIV 2;
    IF x0 &lt; xm THEN enumerate(p.left, x0, x1, y1, xL, xm) END;
    IF xm &lt; x1 THEN enumerate(p.right, x0, x1, y1, xm, xR) END
  END
END enumerate

</code>

<h3 id="4.exe"><a href='#4.exe'>Exercises</a></h3>

<p>4.1. Let us introduce the notion of a recursive type, to be
declared as</p>
<code>RECTYPE T = T0</code>
<p>and denoting the set of values defined by the type
<code>T0</code> enlarged by the single value <code>NONE</code>.
The definition of the type <code>person</code>,
for example, could then be simplified to</p>
<code class='large'>RECTYPE person = RECORD name: Name;
                   father, mother: person
                 END</code>

<p>Which is the storage pattern of the recursive structure
corresponding to Fig. 4.2? Presumably, an implementation of such a
feature would be based on a dynamic storage allocation scheme, and
the fields named father and mother in the above example would
contain pointers generated automatically but hidden from the
programmer. What are the difficulties encountered in the
realization of such a feature?</p>

<p>4.2. Define the data structure described in the last paragraph of
Section 4.2 in terms of records and pointers. Is it also possible
to represent this family constellation in terms of recursive types
as proposed in the preceding exercise?</p>

<p>4.3. Assume that a first-in-first-out (fifo) queue
<code>Q</code> with elements of type <code>T0</code> is
implemented as a linked list. Define a module with a suitable data
structure, procedures to insert and extract an element from
<code>Q</code>, and a function to test whether or not
the queue is empty. The procedures should contain their own
mechanism for an economical reuse of storage.</p>

<p>4.4. Assume that the records of a linked list contain a key field
of type <code>INTEGER</code>. Write a program to sort
the list in order of increasing value of the keys. Then construct a
procedure to invert the list.</p>

<p>4.5. Circular lists (see Fig. 4.52) are usually set up with a
so-called list header. What is the reason for introducing such a
header? Write procedures for the insertion, deletion, and search of
an element identified by a given key. Do this once assuming the
existence of a header, once without header.</p>

<p></p>

<img src="fig/4.52.png" width="400"/>
<p>Fig. 4.52. Circular list</p>

<p>4.6. A bidirectional list is a list of elements that are linked in
both ways. (See Fig. 4.53) Both links are originating from a
header. Analogous to the preceding exercise, construct a module
with procedures for searching, inserting, and deleting
elements.</p>


<img src="fig/4.53.png" width="560"/>
<p>Fig. 4.53. Bidirectional list</p>

<p>4.7. Does the given program for topological sorting work correctly
if a certain pair <code>&lt;x,y&gt;</code> occurs more
than once in the input?</p>

<p>4.8. The message "This set is not partially ordered" in the program
for topological sorting is not very helpful in many cases. Extend
the program so that it outputs a sequence of elements that form a
loop, if there exists one.</p>

<p>4.9. Write a program that reads a program text,
identifies all procedure definitions and calls, and tries to
establish a topological ordering among the subroutines. Let
<code>P 〈 Q</code> mean that <code>P</code>
is called by <code>Q</code>.</p>

<p>4.10. Draw the tree constructed by the program shown for
constructing the perfectly balanced tree, if the input consists of
the natural numbers <code>1, 2, 3, ... , n</code>.</p>

<p>4.11. Which are the sequences of nodes encountered when traversing
the tree of Fig. 4.23 in preorder, inorder, and postorder?</p>

<p>4.12. Find a composition rule for the sequence of
<code>n</code> numbers which, if applied to the program for straight
search and insertion, yields a perfectly balanced tree.</p>

<p>4.13. Consider the following two orders for traversing
binary trees: a1. Traverse the right subtree.</p>
<p>&nbsp; a1. Traverse the right subtree.</p>
<p>&nbsp; a2. Visit the root.</p>
<p>&nbsp; a3. Traverse the left subtree.</p>
<p>&nbsp; b1. Visit the root.</p>
<p>&nbsp; b2. Traverse the right subtree.</p>
<p>&nbsp; b3. Traverse the left subtree.</p>

<p>Are there any simple relationships between the sequences of nodes
encountered following these orders and those generated by the three
orders defined in the text?</p>

<p>4.14. Define a data structure to represent <code>n</code>-ary trees.
Then write a procedure that traverses the
<code>n</code>-ary tree and generates a binary tree
containing the same elements. Assume that the key stored in an
element occupies <code>k</code> words and that each pointer
occupies one word of storage. What is the gain in storage when
using a binary tree versus an <code>n</code>-ary
tree?</p>

<p>4.15. Assume that a tree is built upon the following definition of
a recursive data structure (see Exercise 4.1). Formulate a
procedure to find an element with a given key
<code>x</code> and to perform an operation <code>P</code>
on this element.</p>
<code class='large'>RECTYPE Tree = RECORD x: INTEGER;
                 left, right: Tree
               END</code>
<p>4.16. In a certain file system a directory of all files is
organized as an ordered binary tree. Each node denotes a file and
specifies the file name and, among other things the date of its
last access, encoded as an integer. Write a program that traverses
the tree and deletes all files whose last access was before a
certain date.</p>

<p>4.17. In a tree structure the frequency of access of each element
is measured empirically by attributing to each node an access
count. At certain intervals of time, the tree organization is
updated by traversing the tree and generating a new tree by using
the program of straight search and insertion, and inserting the
keys in the order of decreasing frequency count. Write a program
that performs this reorganization. Is the average path length of
this tree equal to, worse, or much worse than that of an optimal
tree?</p>

<p>4.18. The method of analyzing the tree insertion algorithm
described in Sect. 4.5 can also be used to compute the expected
numbers <code>C<sub>n</sub></code> of
comparisons and <code>M<sub>n</sub></code>
of moves (exchanges) which are performed by
<code>Quicksort</code>, sorting <code>n</code> elements
of an array, assuming that all <code>n!</code>
permutations of the <code>n</code> keys 1, 2, ...
<code>n</code> are equally likely. Find the analogy and
determine <code>C<sub>n</sub></code> and
<code>M<sub>n</sub></code>.</p>

<p>4.19. Draw the balanced tree with 12 nodes which has the maximum
height of all 12-node balanced trees. In which sequence do the
nodes have to be inserted so that the AVL-insertion procedure
generates this tree?</p>

<p>4.20. Find a sequence of <code>n</code> insertion keys
so that the procedure for insertion in an AVL-tree performs each of
the four rebalancing acts (LL, LR, RR, RL) at least once. What is
the minimal length n for such a sequence?</p>

<p>4.21. Find a balanced tree with keys 1 ... <code>n</code>
and a permutation of these keys so that, when applied
to the deletion procedure for AVL-trees, it performs each of the
four rebalancing routines at least once. What is the sequence with
minimal length <code>n</code>?</p>

<p>4.22. What is the average path length of the Fibonacci-tree
<code>T<sub>n</sub></code>?</p>

<p>4.23. Write a program that generates a nearly optimal tree
according to the algorithm based on the selection of a centroid as
root.</p>

<p>4.24. Assume that the keys 1, 2, 3, ... are inserted into an empty
B-tree of order 2. Which keys cause page splits to occur? Which
keys cause the height of the tree to increase? If the keys are
deleted in the same order, which keys cause pages to be merged (and
disposed) and which keys cause the height to decrease? Answer the
question for (a) a deletion scheme using balancing, and (b) a
scheme whithout balancing (upon underflow, a single item only is
fetched from a neighboring page).</p>

<p>4.25. Write a program for the search, insertion, and deletion of
keys in a binary B-tree. Use the node type and the insertion scheme
shown above for the binary B-tree.</p>

<p>4.26. Find a sequence of insertion keys which, starting from the
empty symmetric binary B-tree, causes the shown procedure to
perform all four rebalancing acts (LL, LR,
RR, RL) at least once. What is the shortest such sequence?</p>

<p>4.27. Write a procedure for the deletion of elements in a symmetric
binary B-tree. Then find a tree and a short sequence of deletions
causing all four rebalancing situations to occur at least once.</p>

<p>4.28. Formulate a data structure and procedures for the insertion
and deletion of an element in a priority search tree. The
procedures must maintain the specified invariants. Compare their
performance with that of the radix priority search tree.</p>

<p>4.29. Design a module with the following procedures operating on
radix priority search trees:</p>

<p>— insert a point with coordinates <code>x, y</code>.</p>
<p>— enumerate all points within a specified rectangle.</p>
<p>— find the point with the least <code>x</code>-coordinate in a specified rectangle.</p>
<p>— find the point with the largest <code>y</code>-coordinate within a specified rectangle.</p>
<p>— enumerate all points lying within two (intersecting)
rectangles.</p>

<h3 id="4.ref"><a href='#4.ref'>References</a></h3>

<p><a id='[4.1]' href='#[4.1]'>[4.1]</a>
G.M. Adelson-Velskii and E.M. Landis. <i>Doklady Akademia
Nauk SSSR, 146</i>, (1962), 263-66; English translation in Soviet
Math, 3, 1259-63.</p>

<p><a id='[4.2]' href='#[4.2]'>[4.2]</a>
R. Bayer and E.M. McCreight. Organization and Maintenance of
Large Ordered Indexes. <i>Acta Informatica,</i> 1, No. 3 (1972),
173-89.</p>

<p><a id='[4.3]' href='#[4.3]'>[4.3]</a>
R. Bayer and E.M. McCreight. Binary B-trees for Virtual
memory. <i>Proc. 1971 ACM SIGFIDET Workshop</i>, San Diego, Nov.
1971, pp. 219-35.</p>

<p><a id='[4.4]' href='#[4.4]'>[4.4]</a>
R. Bayer and E.M. McCreight. Symmetric Binary B-trees: Data
Structure and Maintenance Algorithms. <i>Acta Informatica</i>, 1,
No. 4 (1972), 290-306.</p>

<p><a id='[4.5]' href='#[4.5]'>[4.5]</a>
 T.C. Hu and A.C. Tucker. <i>SIAM J. Applied Math</i>, 21, No.
4 (1971) 514-32.</p>

<p><a id='[4.6]' href='#[4.6]'>[4.6]</a>
D. E. Knuth. Optimum Binary Search Trees. <i>Acta
Informatica</i>, 1, No. 1 (1971), 14-25. [4.7] W.A. Walker and C.C.
Gotlieb. A Top-down Algorithm for Constructing Nearly Optimal</p>

<p><a id='[4.7]' href='#[4.7]'>[4.7]</a> W.A. Walker and C.C. Gotlieb.
A Top-down Algorithm for Constructing Nearly Optimal
Lexicographic Trees, in: Graph Theory and Computing (New York:
Academic Press, 1972), pp.303-23.</p>

<p><a id='[4.8]' href='3[4.8]'>[4.8]</a>
D. Comer. The ubiquitous B-tree. <i>ACM Comp. Surveys</i>,
11, 2 (June 1979), 121-137.</p>

<p><a id='[4.9]' href='#[4.9]'>[4.9]</a>
J. Vuillemin. A unifying look at data structures. <i>Comm.
ACM</i>, 23, 4 (April 1980), 229-239. [4.10] E.M. McCreight.
Priority search trees. <i>SIAM J. of Comp.</i> (May 1985)</p>

</li>
</ol>

</li>

<p class="newpage"></p>

<li data-list-text="5" id="5"><h2><a href='#5'>Key Transformations (Hashing)</a></h2>
  <ol class="page" id="l100">
    <li data-list-text="5.1" id="5.1">
      <h3><a href='#5.1'>Introduction</a></h3>
<p>The principal question discussed in Chap. 4 at length is the
following: Given a set of items characterized by a key (upon which
an ordering relation is defined), how is the set to be organized so
that retrieval of an item with a given key involves as little
effort as possible? Clearly, in a computer store each item is
ultimately accessed by specifying a storage address. Hence, the
stated problem is essentially one of finding an appropriate mapping
<code>H</code> of keys (<code>K</code>) into
addresses (<code>A</code>):</p>
<code>H: K → A</code>

<p>In Chap. 4 this mapping was implemented in the form of various list
and tree search algorithms based on different underlying data
organizations. Here we present yet another approach that is
basically simple and very efficient in many cases. The fact that it
also has some disadvantages is discussed subsequently.</p>

<p>The data organization used in this technique is the array
structure. <code>H</code> is therefore a mapping
transforming keys into array indices, which is the reason for the
term <i>key transformation</i> that is generally used for this
technique. It should be noted that we shall not need to rely on any
dynamic allocation procedures; the array is one of the fundamental,
static structures. The method of key transformations is often used
in problem areas where tree structures are comparable
competitors.</p>

<p>The fundamental difficulty in using a key transformation is that
the set of possible key values is much larger than the set of
available store addresses (array indices). Take for example names
consisting of up to 16 letters as keys identifying individuals in a
set of a thousand persons. Hence, there are
<code>26<sup>16</sup></code> possible keys which are
to be mapped onto <code>10<sup>3</sup></code> possible indices.
The function <code>H</code> is therefore obviously a many-to-one function. Given
a key <code>k</code>, the first step in a retrieval
(search) operation is to compute its associated index
<code>h = H(k)</code>, and the second - evidently necessary - step
is to verify whether or not the item with the key
<code>k</code> is indeed identified by <code>h</code> in
the array (table) <code>T</code>, i.e., to check whether
<code>T[H(k)].key = k</code>. We are immediately
confronted with two questions:</p>
<ol id="l101">
<li data-list-text="1.">
<p>What kind of function <code>H</code> should be used?</p>
</li>
<li data-list-text="2.">
<p>How do we cope with the situation that <code>H</code>
does not yield the location of the desired item?</p>
</li>
</ol>

<p>The answer to the second question is that some method must be used
to yield an alternative location, say index <code>h'</code>,
and, if this is still not the location of the
wanted item, yet a third index <code>h"</code>, and so
on. The case in which a key other than the desired one is at the
identified location is called a <i>collision</i>; the task of
generating alternative indices is termed collision handling. In the
following we shall discuss the choice of a transformation function
and methods of collision handling.</p>

</li>

<li data-list-text="5.2" id="5.2">
<h3><a href='#5.2'>Choice of a Hash Function</a></h3>
<p>A prerequisite of a good transformation function is that it
distributes the keys as evenly as possible over the range of index
values. Apart from satisfying this requirement, the distribution is
not bound to any pattern, and it is actually desirable that it give
the impression of being entirely random. This property has given
this method the somewhat unscientific name <i>hashing</i>, i.e.,
chopping the argument up, or making a mess.
<code>H</code> is called the <i>hash function</i>. Clearly, it
should be efficiently computable, i.e., be composed of very few
basic arithmetic operations.</p>

<p>Assume that a transfer function <code>ORD(k)</code> is
available and denotes the ordinal number of the key
<code>k</code> in the set of all possible keys. Assume, furthermore,
that the array indices <code>i</code> range over the
intergers <code>0 .. N-1</code>, where <code>N</code>
is the size of the array. Then an obvious choice
is</p>
<code>H(k) = ORD(k) MOD N</code>
<p>
It has the property that the key values are spread evenly over the
index range, and it is therefore the basis of most key
transformations. It is also very efficiently computable, if
<code>N</code> is a power of 2. But it is exactly this
case that must be avoided, if the keys are sequences of letters.
The assumption that all keys are equally likely is in this case
mistaken. In fact, words that differ by only a few characters then
most likely map onto identical indices, thus effectively causing a
most uneven distribution. It is therefore particularly recommended
to let <code>N</code> be a prime number [5-2]. This has
the conseqeunce that a full division operation is needed that
cannot be replaced by a mere masking of binary digits, but this is
no serious drawback on most modern computers that feature a
built-in division instruction.</p>

<p>Often, hash funtions are used which consist of applying logical
operations such as the exclusive or to some parts of the key
represented as a sequence of binary digits. These operations may be
faster than division on some computers, but they sometimes fail
spectacularly to distribute the keys evenly over the range of
indices. We therefore refrain from discussing such methods in
further detail.</p>

</li>

<li data-list-text="5.3" id="5.3">
<h3><a href='#5.3'>Collision Handling</a></h3>
<p>If an entry in the table corresponding to a given key turns out not
to be the desired item, then a collision is present, i.e., two
items have keys mapping onto the same index. A second probe is
necessary, one based on an index obtained in a deterministic manner
from the given key. There exist several methods of generating
secondary indices. An obvious one is to link all entries with
identical primary index <code>H(k)</code> together in a
linked list. This is called direct chaining. The elements of this
list may be in the primary table or not; in the latter case,
storage in which they are allocated is usually called an
<i>overflow area</i>. This method has the disadvantage that
secondary lists must be maintained, and that each entry must
provide space for a pointer (or index) to its list of collided
items.</p>

<p>An alternative solution for resolving collisions is to dispense
with links entirely and instead simply look at other entries in the
same table until the item is found or an open position is
encountered, in which case one may assume that the specified key is
not present in the table. This method is called <i>open
addressing</i> [5-3]. Naturally, the sequence of indices of
secondary probes must always be the same for a given key. The
algorithm for a table lookup can then be sketched as follows:</p>

<code class='large'>h := H(k); i := 0;
REPEAT
  IF T[h].key = k THEN <i>item found</i>
  ELSIF T[h].key = free THEN <i>item is not in table</i>
  ELSE (*collision*)
    i := i+1; h := H(k) + G(i)
  END
UNTIL <i>found or not in table (or table full)</i></code>

<p>Various functions for resolving collisions have been proposed in
the literature. A survey of the topic by Morris in 1968 [4-8]
stimulated considerable activities in this field. The simplest
method is to try for the next location - considering the table to
be circular - until either the item with the specified key is found
or an empty location is encountered. Hence,
<code>G(i) = i</code>; the indices <code>h<sub>i</sub></code>
used for probing in this case are</p>
<code class='large'>h<sub>0</sub> = H(k)
h<sub>i</sub> = (h<sub>i-1</sub> + i) MOD N,  i = 1 ... N-1
</code>

<p>This method is called <i>linear probing</i> and has the
disadvantage that entries have a tendency to cluster around the
primary keys (keys that had not collided upon insertion). Ideally,
of course, a function <code>G</code> should be chosen
that again spreads the keys uniformly over the remaining set of
locations. In practice, however, this tends to be too costly,
and methods that offer a compromise by
being simple to compute and still superior to the linear function
are preferred. One of them consists of using a quadratic function
such that the sequence of indices for probing is</p>
<code class='large'>h<sub>0</sub> = H(k)
h<sub>i</sub> = (h<sub>0</sub> + i<sup>2</sup>) MOD N, i &gt; 0
</code>

<p>Note that computation of the next index need not
involve the operation of squaring, if we use the following
recurrence relations for
<code>h<sub>i</sub> = i<sup>2</sup></code> and
<code>d<sub>i</sub> = 2i + 1</code>.
</p>
<code class='large'>h<sub>i+1</sub> = h<sub>i</sub> + d<sub>i</sub>
d<sub>i+1</sub> = d<sub>i</sub> + 2, i &gt; 0</code>
<p>with <code>h<sub>0</sub> = 0</code> and
<code>d<sub>0</sub> = 1</code>.
This is called <em>quadratic probing</em>,
and it essentially avoids primary
clustering, although practically no additional computations are
required. A very slight disadvantage is that in probing not all
table entries are searched, that is, upon insertion one may not
encounter a free slot although there are some left. In fact, in
quadratic probing at least half the table is visited if its
size <code>N</code> is a prime number. This assertion can
be derived from the following deliberation. If the
<code>i</code>-th and the <code>j</code>-th probes
coincide upon the same table entry, we can express this by the
equation</p>
<code class='large'>i<sup>2</sup> MOD N = j<sup>2</sup> MOD N
(i<sup>2</sup> - j<sup>2</sup>) ≡ 0 (modulo N)</code>
<p>Splitting the differences up into two factors, we obtain</p>
<code>(i + j)(i - j) ≡ 0 (modulo N)</code>
<p>and since <code>i ≠ j</code>, we realize that either
<code>i</code> or <code>j</code> have to be at least
<code>N/2</code> in order to yield <code>i+j = c*N</code>,
with <code>c</code> being an integer. In
practice, the drawback is of no importance, since having to perform
<code>N/2</code> secondary probes and collision evasions
is extremely rare and occurs only if the table is already almost
full.</p>

<p>As an application of the scatter storage technique, the
cross-reference generator procedure shown in Sect. 4.4.3 is
rewritten. The principal differences lie in the procedure
<code>search</code> and in the replacement of the
pointer type <code>Node</code> by the global hash table
of words <code>T</code>. The hash function <code>H</code>
is the modulus of the table size; quadratic probing
was chosen for collision handling. Note that it is essential for
good performance that the table size be a prime number.</p>

<p>Although the method of key transformation is most effective in this
case — actually more efficient than tree organizations — it also
has a disadvantage. After having scanned the text and collected the
words, we presumably wish to tabulate these words in alphabetical
order. This is straightforward when using a tree organization,
because its very basis is the ordered search tree. It is not,
however, when key transformations are used. The full significance
of the word hashing becomes apparent. Not only would the table
printout have to be preceded by a sort process (which is omitted
here), but it even turns out to be advantageous to keep track of
inserted keys by linking them together explicitly in a list. Hence,
the superior performance of the hashing method considering the
process of retrieval only is partly offset by additional operations
required to complete the full task of generating an ordered
cross-reference index.</p>

<code class='large'>CONST N = 997; (*prime, table size*) <span>(* ADenS53_CrossRef *)</span>
  WordLen = 32; (*max length of keys*)
  Noc = 16; (*max no. of items per word*)

TYPE
  Word = ARRAY WordLen OF CHAR;
  Table = POINTER TO ARRAY N OF
    RECORD key: Word; n: INTEGER;
      lno: ARRAY Noc OF INTEGER
    END;

VAR line: INTEGER;

PROCEDURE search (T: Table; VAR a: Word);
  VAR i, d: INTEGER; h: LONGINT; found: BOOLEAN;
BEGIN (*compute hash index h for a; uses global variable line*)
  i := 0; h := 0;
  WHILE a[i] &gt; 0X DO h := (256*h + ORD(a[i])) MOD N; INC(i) END;
  d := 1; found := FALSE;
  REPEAT
    IF T[h].key = a THEN (*match*)
      found := TRUE; T[h].lno[T[h].n] := line;
      IF T[h].n &lt; Noc THEN INC(T[h].n) END
    ELSIF T[h].key[0] = " " THEN (*new entry*)
      found := TRUE; COPY(a, T[h].key); T[h].lno[0] := line; T[h].n := 1
    ELSE (*collision*) h := h+d; d := d+2;
      IF h &gt;= N THEN h := h-N END;
      IF d = N THEN
        Texts.WriteString(W," Table overflow"); HALT(88)
      END
    END
  UNTIL found
END search;

PROCEDURE Tabulate (T: Table); (*uses global writer W*)
  VAR i, k: INTEGER;
BEGIN
  FOR k := 0 TO N-1 DO
    IF T[k].key[0] # " " THEN
      Texts.WriteString(W, T[k].key); Texts.Write(W, TAB);
      FOR i := 0 TO T[k].n -1 DO Texts.WriteInt(W, T[k].lno[i], 4) END;
      Texts.WriteLn(W)
    END
  END
END Tabulate;

PROCEDURE CrossRef (VAR R: Texts.Reader);
  VAR i: INTEGER; ch: CHAR; w: Word;
    H: Table;
BEGIN
  NEW(H); (*allocate and clear hash table*)
  FOR i := 0 TO N-1 DO
    H[i].key[0] := " "
  END;
  line := 0;
  Texts.WriteInt(W, 0, 6); Texts.Write(W, TAB); Texts.Read(R, ch);
  WHILE ~R.eot DO
    IF ch = 0DX THEN (*line end*)
      Texts.WriteLn(W);
      INC(line); Texts.WriteInt(W, line, 6); Texts.Write(W, 9X);
      Texts.Read(R, ch)
    ELSIF ("A" &lt;= ch) &amp; (ch &lt;= "Z") OR ("a" &lt;= ch) &amp; (ch &lt;= "z") THEN
      i := 0;
      REPEAT
        IF i &lt; WordLen-1 THEN w[i] := ch; INC(i) END;
        Texts.Write(W, ch); Texts.Read(R, ch)
      UNTIL (i = WordLen-1) OR ~(("A" &lt;= ch) &amp; (ch &lt;= "Z")) &amp;
        ~(("a" &lt;= ch) &amp; (ch &lt;= "z")) &amp; ~(("0" &lt;= ch) &amp; (ch &lt;= "9"));
      w[i] := 0X; (*string terminator*)
      search(H, w)
    ELSE Texts.Write(W, ch); Texts.Read(R, ch)
    END;
    Texts.WriteLn(W); Texts.WriteLn(W); Tabulate(H)
  END
END CrossRef</code>

</li>

<li data-list-text="5.4" id="5.4">
<h3><a href='5.4'>Analysis of Key Transformation</a></h3>
<!-- strange break
</li>
</ol>
</li>
</ol>
 -->
<p>Insertion and retrieval by key transformation has evidently a
miserable worst-case performance. After all, it is entirely
possible that a search argument may be such that the probes hit
exactly all occupied locations, missing consistently the desired
(or free) ones. Actually, considerable confidence in the
correctness of the laws of probability theory is needed by anyone
using the hash technique. What we wish to be assured of is that on
the average the number of probes is small. The following
probabilistic argument reveals that it is even very small.</p>

<p>Let us once again assume that all possible keys are equally likely
and that the hash function <code>H</code> distributes
them uniformly over the range of table indices. Assume, then, that
a key has to be inserted in a table of size <code>N</code>
which already contains <code>k</code>
items. The probability of hitting a free location the first time is
then <code>(N-k)/N</code>. This is also the probability
<code>p<sub>1</sub></code>that a single
comparison only is needed. The probability that excatly one second
probe is needed is equal to the probability of a collision in the
first try times the probability of hitting a free location the next
time. In general, we obtain the probability <code>p<sub>i</sub></code>
of an insertion requiring
exactly <code>i</code> probes as</p>
<code class='large'>p<sub>1</sub> = (N-k)/N
p<sub>2</sub> = (k/N) × (N-k)/(N-1)
p<sub>3</sub> = (k/N) × (k-1)/(N-1) × (N-k)/(N-2)
  ………
p<sub>i</sub> = (k/N) × (k-1)/(N-1) × (k-2)/(N-2) × … × (N-k)/(N-(i-1))
</code>

<p>The expected number <code>E</code> of probes required
upon insertion of the <code>k+1</code>st key is
therefore</p>
<code class='large'>E<sub>k+1</sub>   = <strong>S</strong>i: 1 ≤ i ≤ k+1 : i × p<sub>i</sub>
      = 1 × (N-k)/N + 2 × (k/N) × (N-k)/(N-1) + ...
        + (k+1) * (k/N) × (k-1)/(N-1) × (k-2)/(N-2) × … × 1/(N-(k-1))
      = (N+1) / (N-(k-1))
</code>

<p>Since the number of probes required to insert an item is identical
with the number of probes needed to retrieve it, the result can be
used to compute the average number <code>E</code> of
probes needed to access a random key in a table. Let the table size
again be denoted by <code>N</code>, and let <code>m</code>
be the number of keys actually in the table. Then</p>
<code class='large'>E = (<strong>S</strong>k: 1 ≤ k ≤ m: E<sub>k</sub>) / m
  = (N+1) × (<strong>S</strong>k: 1 ≤ k ≤ m : 1/(N-k+2))/m
  = (N+1) × (H<sub>N+1</sub> - H<sub>N-m+1</sub>)
</code>
<p>where <code>H</code> is the harmonic function.
<code>H</code> can be approximated as
<code>H<sub>N</sub> = ln(N) + g</code>,
where <code>g</code> is Euler's constant. If, moreover,
we substitute <code>a</code> for <code>m/(N+1)</code>,
we obtain</p>
<code class='large'>E = (ln(N+1) - ln(N-m+1))/a = ln((N+1)/(N-m+1))/a = -ln(1-a)/a</code>

<p><code>a</code> is approximately the quotient of occupied
and available locations, called the <i>load factor</i>;
<code>a = 0</code> implies an empty table, <code>a = N/(N+1) ≈ 1</code>
a full table. The expected
number <code>E</code> of probes to retrieve or insert a
randomly chosen key is listed in Table 5.1 as a function of the
load factor.</p>

<div class='table'><table>
<tr><th>a</th><th>E</th></tr>
<tr><td>0.1</td><td>1.05</td></tr>
<tr><td>0.25 &nbsp;</td><td>1.15</td></tr>
<tr><td>0.5</td><td>1.39</td></tr>
<tr><td>0.75</td><td>1.85</td></tr>
<tr><td>0.9</td><td>2.56</td></tr>
<tr><td>0.95</td><td>3.15</td></tr>
<tr><td>0.99</td><td>4.66</td></tr>
</table></div>

<p>Table 5.1. Expected number of probes as a function of the load factor.</p>

<p>The numerical results are indeed surprising, and they explain the
exceptionally good performance of the key transformation method.
Even if a table is 90% full, on the average only 2.56 probes are
necessary to either locate the key or to find an empty location.
Note in particular that this figure does not depend on the absolute
number of keys present, but only on the load factor.</p>

<p>The above analysis was based on the use of a collision handling
method that spreads the keys uniformly over the remaining
locations. Methods used in practice yield slightly worse
performance. Detailed analysis for linear probing yields an
expected number of probes as</p>
<code>E = (1 - a/2) / (1 - a)</code>

<p>Some numerical values for <code>E(a)</code> are listed
in Table 5.2 <a href='#[5.4]'>[5.4]</a>.
</p>

<div class='table'>
<table cellspacing="1">
  <tr><th>a   </th><th>E    </th></tr>
  <tr><td>0.1 </td><td>1.06 </td></tr>
  <tr><td>0.25 &nbsp;</td><td>1.17 </td></tr>
  <tr><td>0.5 </td><td>1.50 </td></tr>
  <tr><td>0.75</td><td>2.50 </td></tr>
  <tr><td>0.9 </td><td>5.50 </td></tr>
  <tr><td>0.95</td><td>10.50</td></tr>
</table></div>
<p>Table 5.2. Expected number of probes for linear probing.</p>

<p>The results obtained even for the poorest method of collision
handling are so good that there is a temptation to regard key
transformation (hashing) as the panacea for everything. This is
particularly so because its performance is superior even to the
most sophisticated tree organization discussed, at least on the
basis of comparison steps needed for retrieval and insertion. It is
therefore important to point out explicitly some of the drawbacks
of hashing, even if they are obvious upon unbiased
consideration.</p>

<p>Certainly the major disadvantage over techniques using dynamic
allocation is that the size of the table is fixed and cannot be
adjusted to actual demand. A fairly good a priori estimate of the
number of data items to be classified is therefore mandatory if
either poor storage utilization or poor performance (or even table
overflow) is to be avoided. Even if the number of items is exactly
known — an extremely rare case — the desire for good performance
dictates to dimension the table slightly (say 10%) too large.</p>

<p>The second major deficiency of scatter storage techniques becomes
evident if keys are not only to be inserted and retrieved, but if
they are also to be deleted. Deletion of entries in a hash table is
extremely cumbersome unless direct chaining in a separate overflow
area is used. It is thus fair to say that tree organizations are
still attractive, and actually to be preferred, if the volume of
data is largely unknown, is strongly variable, and at times even
decreases.</p>

<h3 id="5.exe">Exercises</h3>

<div id="l102">
<ol class="noindent" id="l103">
<li data-list-text="5.1.">
If the amount of information associated with each key is relatively
large (compared to the key itself), this information should not be
stored in the hash table. Explain why and propose a scheme for
representing such a set of data.
</li>
<li data-list-text="5.2.">
Consider the proposal to solve the clustering problem by
constructing overflow trees instead of overflow lists, i.e., of
organizing those keys that collided as tree structures. Hence, each
entry of the scatter (hash) table can be considered as the root of
a (possibly empty) tree. Compare the expected performance of this
tree hashing method with that of open addressing.
</li>
<li data-list-text="5.3.">
Devise a scheme that performs insertions and deletions in a hash
table using quadratic increments for collision resolution. Compare
this scheme experimentally with the straight binary tree
organization by applying random sequences of keys for insertion and
deletion.
</li>
<li data-list-text="5.4.">
The primary drawback of the hash table technique is that the size
of the table has to be fixed at a time when the actual number of
entries is not known. Assume that your computer system incorporates
a dynamic storage allocation mechanism that allows to obtain
storage at any time. Hence, when the hash table <code>H</code>
is full (or nearly full), a larger table <code>H'</code>
is generated, and all keys in <code>H</code> are transferred to <code>H'</code>,
whereafter the store for <code>H</code> can be returned
to the storage administration. This is called rehashing. Write a
program that performs a rehash of a table <code>H</code>
of size <code>N</code>.
</li>
<li data-list-text="5.5.">
Very often keys are not integers but sequences of letters. These
words may greatly vary in length, and therefore they cannot
conveniently and economically be stored in key fields of fixed
size. Write a program that operates with a hash table and variable
length keys.
</li>
</ol>
</div>

<h3 id="5.ref"><a href='#5.ref'>References</a></h3>
<p><a href='#[5.1]' id='[5.1]'>[5.1]</a> W.D. Maurer. An Improved Hash Code for Scatter Storage.
<i>Comm. ACM</i>, 11, No. 1 (1968), 35-38.</p>

<p><a href='#[5.2]' id='[5.2]'>[5.2]</a>
R. Morris. Scatter Storage Techniques. <i>Comm. ACM</i>, 11,
No. 1 (1968), 38-43.</p>

<p><a href='#[5.3]' id='[5.3]'>[5.3]</a> W.W. Peterson. Addressing for Random-access Storage. <i>IBM
J. Res. &amp; Dev.</i>, 1 (1957), 130-46. [5.4] G. Schay and W.
Spruth. Analysis of a File Addressing Method. <i>Comm. ACM</i>, 5,
No. 8 (1962) 459-62.</p>

<p><a href='#[5.4]' id='[5.4]'>[5.4]</a>
G. Schay and W. Spruth. Analysis of a File Addressing Method. <i>Comm. ACM</i>, 5, No. 8 (1962)
459-62.</p>

</li>
</ol>
</li>
</ol>


<p class="newpage"></p>

<h2 id="Appendix-A"><a href='#Appendix-A'>Appendix A. The ASCII Character Set</a></h2>

<div class='table'><table>
<tr><td></td>
<td>0</td><td>10</td><td>20</td><td>30</td><td>40</td><td>50</td><td>60</td><td>70</td></tr>

<tr>
<td>0</td><td>nul</td><td>dle</td><td>

</td>
<td>0</td><td>@</td><td>P</td><td>`</td><td>p</td></tr>
<tr>
<td>1</td><td>soh</td><td>dc1</td><td>!</td><td>1</td><td>A</td><td>Q</td><td>a</td><td>q</td></tr>
<tr>
<td>2</td><td>stc</td><td>dc2</td><td>"</td><td>2</td><td>B</td><td>R</td><td>b</td><td>r</td></tr>
<tr>
<td>3</td><td>etx</td><td>dc3</td><td>#</td><td>3</td><td>C</td><td>S</td><td>c</td><td>s</td></tr>
<tr>
<td>4</td><td>eot</td><td>dc4</td><td>$</td><td>4</td><td>D</td><td>T</td><td>d</td><td>t</td></tr>
<tr>
<td>5</td><td>enq</td><td>nak</td><td>%</td><td>5</td><td>E</td><td>U</td><td>e</td><td>u</td></tr>
<tr>
<td>6</td><td>ack</td><td>syn</td><td>&amp;</td><td>6</td><td>F</td><td>V</td><td>f</td><td>v</td></tr>
<tr>
<td>7</td><td>bel</td><td>etb</td><td>'</td><td>7</td><td>G</td><td>W</td><td>g</td><td>w</td></tr>
<tr>
<td>8</td><td>bs</td><td>can</td><td>(</td><td>8</td><td>H</td><td>X</td><td>h</td><td>x</td></tr>
<tr>
<td>9</td><td>ht</td><td>em</td><td>)</td><td>9</td><td>I</td><td>Y</td><td>i</td><td>y</td></tr>
<tr>
<td>A</td><td>lf</td><td>sub</td><td>*</td><td>:</td><td>J</td><td>Z</td><td>j</td><td>z</td></tr>
<tr>
<td>B</td><td>vt</td><td>esc</td><td>+</td><td>;</td><td>K</td><td>[</td><td>k</td><td>{</td></tr>
<tr>
<td>C</td><td>ff</td><td>fs</td><td>,</td><td>&lt;</td><td>L</td><td>\</td><td>l</td><td>|</td></tr>
<tr>
<td>D</td><td>cr</td><td>gs</td><td>-</td><td>=</td><td>M</td><td>]</td><td>m</td><td>}</td></tr>
<tr>
<td>E</td><td>so</td><td>rs</td><td>.</td><td>&gt;</td><td>N</td><td>^</td><td>n</td><td>~</td></tr>
<tr>
<td>F</td><td>si</td><td>us</td><td>/</td><td>?</td><td>O</td><td>_</td><td>o</td><td>del</td></tr>
</table></div>

<p class="newpage"></p>

<h2 id="Appendix-B"><a href='#Appendix-B'>Appendix B</a>. The Syntax of Oberon</h2>
<ol id="l104" class="page">
<li data-list-text="1.">
<h3>The Syntax of Oberon</h3>
<p id="ident">ident = letter {letter | digit}. number = integer | real.</p>
<p id="integer">integer = digit {digit} | digit {hexDigit} "H".</p>
<p id="real">real = digit {digit} "." {digit} [ScaleFactor].</p>
<p id="ScaleFactor">ScaleFactor = ("E" | "D") ["+" | "-"] digit {digit}.</p>
<p id="hexDigit">hexDigit = digit | "A" | "B" | "C" | "D" | "E" | "F".</p>
<p id="digit">digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9".</p>
<p id="CharConstant">CharConstant = """ character """ | digit {hexDigit} "X".</p>
<p id="string">string = """ {character} """ .</p>
<p id="qualident">qualident = [ident "."] ident. identdef = ident ["*"].</p>
<p id="TypeDeclaration">TypeDeclaration = identdef "=" type.</p>
<p id="type">type = qualident | ArrayType | RecordType | PointerType | ProcedureType.
<p id="ArrayType">ArrayType = ARRAY length {"," length} OF type.</p>
<p id="length">length = ConstExpression.</p>
<p class="s23">RecordType = RECORD ["(" BaseType ")"] FieldListSequence END.</p>
<p>BaseType = qualident.</p>
<p class="s23">FieldListSequence = FieldList {";" FieldList}.</p>
<p>FieldList = [IdentList ":" type].</p>
<p class="s23">IdentList = identdef {"," identdef}.</p>
<p>PointerType = POINTER TO type.</p>
<p class="s23">ProcedureType = PROCEDURE [FormalParameters].</p>
<p>VariableDeclaration = IdentList ":" type.</p>
<p class="s23">designator = qualident {"." ident | "[" ExpList "]" | "(" qualident")" | "^" }.</p>
<p>ExpList = expression {"," expression}.</p>
<p class="s23">expression = SimpleExpression [relation SimpleExpression].</p>
<p>relation = "=" | "#" | "&lt;" | "&lt;=" | "&gt;" | "&gt;=" | IN | IS.</p>
<p>SimpleExpression = ["+"|"-"] term {AddOperator term}.</p>
<p class="s23">AddOperator = "+" | "-" | OR .</p>
<p class="s23">term = factor {MulOperator factor}. MulOperator = "*" | "/" | DIV | MOD | "&amp;" .</p>
<p class="s23">factor = number | CharConstant | string | NIL | set | designator [ActualParameters] | "(" expression ")" | "~" factor.
<p>set = "{" [element {"," element}] "}".</p>
<p class="s23">element = expression [".." expression].</p>
<p>ActualParameters = "(" [ExpList] ")" .</p>
<p>statement = [assignment | ProcedureCall | IfStatement | CaseStatement | WhileStatement | RepeatStatement | LoopStatement | WithStatement | EXIT | RETURN [expression] ].</p>
<p class="s23">assignment = designator ":=" expression.</p>
<p>ProcedureCall = designator [ActualParameters].</p>
<p>IfStatement = IF expression THEN StatementSequence<br/>
   {ELSIF expression THEN StatementSequence}<br/>
   [ELSE StatementSequence]<br/>
   END.</p>
<p class="s23">CaseStatement = CASE expression OF case {"|" case} [ELSE StatementSequence] END.</p>
<p>Case = [CaseLabelList ":" StatementSequence].</p>
<p class="s23">CaseLabelList = CaseLabels {"," CaseLabels}.</p>
<p>CaseLabels = ConstExpression [".." ConstExpression].</p>
<p class="s23">WhileStatement = WHILE expression DO StatementSequence END.</p>
<p>ProcedureDeclaration = ProcedureHeading ";" ProcedureBody ident.</p>
<p>ProcedureHeading = PROCEDURE identdef [FormalParameters].</p>
<p class="s23">ProcedureBody = DeclarationSequence [BEGIN StatementSequence] END.</p>
<p>ForwardDeclaration = PROCEDURE "^" identdef [FormalParameters].</p>
<p class="s23">FormalParameters = "(" [FPSection {";" FPSection}] ")" [":" qualident].</p>
<p>FPSection = [VAR] ident {"," ident} ":" FormalType.</p>
<p class="s23">FormalType = {ARRAY OF} qualident.</p>
<p class="s23">DeclarationSequence = {CONST {ConstantDeclaration ";"} | TYPE {TypeDeclaration ";"} | VAR {VariableDeclaration ";"}}</p>
<p class="s23">{ProcedureDeclaration ";" | ForwardDeclaration ";"}.</p>
<p class="s23">Module = MODULE ident ";" [ImportList] DeclarationSequence [BEGIN StatementSequence] END ident "." .</p>
<p>ImportList = IMPORT import {"," import} ";" .</p>
<p class="s23">Import = ident [":=" ident].</p>

</li>
<li data-list-text="2.">
<h3>Symbols and Keywords</h3>

<div class='table'><table>
<tr><td>+</td><td>:=</td><td>ARRAY</td><td>IS</td><td>TO</td></tr>
<tr><td>-</td><td>^</td><td>BEGIN</td><td>LOOP</td><td>TYPE</td></tr>
<tr><td>*</td><td>=</td><td>CASE</td><td>MOD</td><td>UNTIL</td></tr>
<tr><td>/</td><td>#</td><td>CONST</td><td>MODULE</td><td>VAR</td></tr>
<tr><td>~</td><td>&lt;</td><td>DIV</td><td>NIL</td><td>WHILE</td></tr>
<tr><td>&amp;</td><td>&gt;</td><td>DO</td><td>OF</td><td>WITH</td></tr>
<tr><td>.</td><td>&lt;=</td><td>ELSE</td><td>OR</td><td></td></tr>
<tr><td>,</td><td>&gt;=</td><td>ELSIF</td><td>POINTER</td><td></td></tr>
<tr><td>;</td><td>..</td><td>END</td><td>PROCEDURE</td><td></td></tr>
<tr><td>|</td><td>:</td><td>EXIT</td><td>RECORD</td><td></td></tr>
<tr><td>(</td><td>)</td><td>IF</td><td>REPEAT</td><td></td></tr>
<tr><td>[</td><td>]</td><td>IMPORT</td><td>RETURN</td><td></td></tr>
<tr><td>{</td><td>}</td><td>IN</td><td>THEN</td><td></td></tr>
</table></div>

</li>
<li data-list-text="3.">
<h3>Standard Data Types</h3>
<div class='table'><table>
  <tr><td><code>CHAR, BOOLEAN, SHORTINT</code></td><td>(8 bits)</td></tr>
  <tr><td><code>INTEGER</code></td><td>(16 or 32 bits)</td></tr>
  <tr><td><code>LONGINT, REAL, SET</code></td><td>(32 bits)</td></tr>
  <tr><td><code>LONGREAL</code></td><td>(64 bits)</td></tr>
</table></div>

</li>

<li data-list-text="4.">
<h3>Standard Functions and Procedures</h3>

<div class='table'><table>
<tr>
<td>Name</td>
<td>Argument type</td>
<td>Result type</td>
<td>absolutevalue</td>
</tr>

<tr>
<td><code>ABS(x)</code></td>
<td>numeric</td>
<td>type of <span class="s14">x</span></td>
<td>absolute value</td>
</tr>

<tr>
<td>ODD(x)</td>
<td>integer type</td>
<td>BOOLEAN</td>
<td>x MOD 2 = 1</td>
</tr>

<tr>
<td>CAP(x)</td>
<td>CHAR</td>
<td>CHAR</td>
<td>corresponding capital letter</td>
</tr>

<tr>
<td>ASH(x, n)</td>
<td>integer types</td>
<td>LONGINT</td>
<td>x × 2<sup>n</sup><span class="s42">(arithmetic shift)</span></td>
</tr>

<tr>
<td>LEN(v, n)</td>
<td><code>v</code>: array type</td>
<td>LONGINT</td>
<td>length of <code>v</code> in dimension <code>n</code></td>
</tr>

<tr>
<td>LEN(v)</td>
<td><code>v</code>: array type</td>
<td>LONGINT</td>
<td>length of <code>v</code> in dimension <code>0</code></td>
</tr>

<tr>
<td>ORD(x)</td>
<td>CHAR</td>
<td>INTEGER</td>
<td>ordinal number of character <code>x</code></td>
</tr>

<tr>
<td>CHR(x)</td>
<td>INTEGER</td>
<td>CHAR</td>
<td>character with ordinal number <code>x</code></td>
</tr>

<tr>
<td>SHORT(x)</td>
<td>LONGINT<br/>INTEGER<br/>LONGREAL</td>
<td>INTEGER<br/>SHORTINT<br/>REAL</td>
<td>identity (truncation possible!)</td>
</tr>

<tr>
<td>LONG(x)</td><td>SHORTINT<br/>INTEGER<br/>REAL</td>
<td>INTEGER<br/>LONGINT<br/>LONGREAL</td>
<td>identity</td>
</tr>

<tr>
<td>ENTIER(x)</td>
<td>real type</td>
<td>LONGINT</td>
<td>largest integer not greater <code>x</code></td>
</tr>

<tr>
<td>INC(v, n)</td>
<td>integer types</td>
<td></td>
<td>v := v + n</td>
</tr>

<tr>
<td>INC(v)</td>
<td>integer types</td>
<td></td>
<td>v := v + 1</td>
</tr>

<tr>
<td>DEC(v, n)</td>
<td>integer types</td>
<td></td>
<td>v := v – n</td>
</tr>

<tr>
<td>DEC(v)</td>
<td>integer types</td>
<td></td>
<td>v := v – 1</td>
</tr>

<tr>
<td>INCL(v, n)</td>
<td><code>v: SET; n:</code> integer type</td>
<td></td>
<td>v := v + {n}</td>
</tr>

<tr>
<td>EXCL(v, n)</td>
<td><code>v: SET; n:</code> integer type</td>
<td></td>
<td>v := v – {n}</td>
</tr>

<tr>
<td>COPY(x, v)</td>
<td><code>x</code>: character array, string</td>
<td></td>
<td>v := x</td>
</tr>

<tr>
<td>NEW(v)</td><td>pointer type</td>
<td></td>
<td>allocate <code>v^</code></td>
</tr>

<tr>
<td>HALT(x)</td><td>integer constant</td>
<td></td>
<td>terminate computation</td>
</tr>

</table></div>

</li>
</ol>

<p class="newpage"></p>

<h2 id="Appendix-C"><a href='#Appendix-C'>Appendix C</a>. The Dijkstra loop</h2>

<p>E.W. Dijkstra <a href="#[C.1]" >[C.1]</a> (see also <a href="#[C.2]">[C.2]</a>)
introduced and justified a
multibranch generalization of the conventional <code>WHILE</code>
loop in his theory of systematic derivation of
imperative programs. This loop proves convenient for expression and
— most importantly — for verification of the algorithms which are
usually expressed in terms of embedded loops, thus significantly
reducing the effort of debugging.</p>

<p>In the language Oberon-07 presented in
<a href="#[C.3]">[C.3]</a>, the syntax of this
loop is defined as follows:</p>
<code class='large'>
WhileStatement
= WHILE <i>logical expression</i> DO
    operator sequence
  {ELSIF <i>logical expression</i> DO
    <i>operator sequence</i>}
  END.</code>

<p>If any of the logical expressions (guards) is evaluated to
<code>TRUE</code> then the corresponding operator
sequence is executed. The evaluation of the guards and the
execution of the corresponding operator sequences is repeated until
all guards evaluate to <code>FALSE</code>. So, the
postcondition for this loop is the conjunction of negations of all
guards.</p>

<p>Example:</p>
<code class='large'>WHILE m &gt; n DO m := m - n ELSIF n &gt; m DO n := n - m END</code>
<p>Postcondition: <code class='large'>~(m &gt; n) &amp; ~(n &gt; m)</code>,
which is equivalent to <code>n = m</code>.</p>

<p>The loop invariant must hold at the beginning and at the end of
each branch.</p>

<p>Roughly speaking, an <code>n</code>-branch Dijkstra loop
corresponds to constructions with <code>n</code> usual
loops that are somehow embedded one into another and coupled via
logical variables, breaks etc.</p>

<p>The advantage of the Dijkstra loop is due to the fact that all the
logic of an arbitrarily complex multiple loop is expressed at the
same level and is radically clarified, so that algorithms with
various cases of embedded interacting ("braided") loops receive a
completely uniform treatement.
</p>

<p>An efficient way to construct such a loop consists in enumerating
all possible situations that can emerge, describing them by the
corresponding guards, and for each guard — independently of the
others — constructing operations that advance the algorithm towards
its goal, togethers with the operations that restore the invariant.
The enumeration of the guards is stopped when the disjunction
(<code>OR</code>) of all guards covers the assumed
precondition of the loop. It is useful to remember that the task of
construction of a correct loop is simplified if one postpones
worrying about the order of evaluation of the guards and execution
of the branches, optimizations of evaluation of the guards etc.,
until the loop is correctly constructed. Such lower-level
optimizations are rarely significant, and their implementation is
greatly simplified when the correctness of a complicated loop has
already been ensured.
</p>

<p>Although in Dijkstra's theory the order of guard evaluations is
undefined, in this book the guards are assumed to be evaluated (and
branches selected for execution) in their textual order.
</p>

<p>In most programming languages the Dijkstra loop has to be modelled.
In the older versions of Oberon (including Component Pascal) it is
sufficient to use the <code>LOOP</code> construct, with
the body consisting of a multibranch <code>IF</code>
operator that contains the single loop <code>EXIT</code>
operator in the <code>ELSE</code> branch:</p>

<code class='large'>LOOP IF <i>logical expression</i> THEN
  <i>operator sequence</i>
{ELSIF <i>logical expression</i> THEN
  <i>operator sequence</i>}
ELSE EXIT END END.</code>

<p>In other languages the construct may be more cumbersome, but that
is offset by the simplification of construction and debugging of
complicated loops.</p>

<h3 id='c.ref'><a href='#c.ref'>References</a></h3>
<ol class="page id">
  <li class="id" id="[C.1]">E.W. Dijkstra. A Discipline of Programming. Prentice-Hall, 1976.</li>
  <li class="id" id="[C.2]">D. Gries. The Science of Programming. Springer-Verlag, 1981.</li>
  <li class="id" id="[C.3]">N. Wirth. The Programming Language Oberon. Revision 1.9.2007.</li>
</ol>

</body>
</html>
